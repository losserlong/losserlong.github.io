<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"losserlong.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Stay Hungry,Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiang&#39;s Blog">
<meta property="og:url" content="https://losserlong.github.io/index.html">
<meta property="og:site_name" content="Xiang&#39;s Blog">
<meta property="og:description" content="Stay Hungry,Stay Foolish">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Xiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://losserlong.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Xiang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xiang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">与买桂花重载酒，终不似，少年游</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://losserlong.github.io/2022/01/18/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang">
      <meta itemprop="description" content="Stay Hungry,Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/mysql/" class="post-title-link" itemprop="url">mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-18 16:31:34 / 修改时间：18:09:26" itemprop="dateCreated datePublished" datetime="2022-01-18T16:31:34+08:00">2022-01-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务隔离级别-图文详解"><a href="#事务隔离级别-图文详解" class="headerlink" title="事务隔离级别(图文详解)"></a>事务隔离级别(图文详解)</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="常用的事务控制语法"><a href="#常用的事务控制语法" class="headerlink" title="常用的事务控制语法"></a>常用的事务控制语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 事务开始</span><br><span class="line">begin;</span><br><span class="line">- 事务提交，提交后就会写入物理磁盘中去</span><br><span class="line">commit;</span><br><span class="line">- 事务回滚，事务提交后，无法回滚</span><br><span class="line">rollback;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173945.png" alt="image-20211231191231001"></p>
<ol>
<li><strong><font color='red'>原子性（atomicity）</font>：</strong> <strong>事务是最小的执行单位，不允许分割。</strong>事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong><font color='red'>一致性（consistency）</font>：</strong> <strong>执行事务前后，数据保持一致</strong>，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong><font color='red'>隔离性（isolation）</font>：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，<strong>各并发事务之间数据库是独立的；</strong></li>
<li><strong><font color='red'>持久性（durability）</font>：</strong> <strong>一个事务被提交之后。它对数据库中数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h2 id="关闭mysql的事务自动提交"><a href="#关闭mysql的事务自动提交" class="headerlink" title="关闭mysql的事务自动提交"></a>关闭mysql的事务自动提交</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 0|1|ON|OFF;</span><br></pre></td></tr></table></figure>

<p>对取值的说明：</p>
<p>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。<br>值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</p>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><h3 id="事务隔离级别的定义"><a href="#事务隔离级别的定义" class="headerlink" title="事务隔离级别的定义"></a>事务隔离级别的定义</h3><p>事务指定一个隔离级别，该隔离级别<strong>定义一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。</strong>隔离级别从允许的并发副作用（例如，脏读或幻读的角度进行描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 查看隔离级别,8.0版本之前的，用SELECT @@tx_isolation</span><br><span class="line">select @@transaction_isolation;</span><br><span class="line"></span><br><span class="line">- 修改隔离级别</span><br><span class="line">set session transaction isolation level  READ UNCOMMITTED;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="隔离级别的分类"><a href="#隔离级别的分类" class="headerlink" title="隔离级别的分类"></a>隔离级别的分类</h3><p><strong>读未提交(READ-UNCOMMITTED)：</strong>A事务操作后没有执行commit提交命令，但是B事务也能察觉到A操作的数据变化，此时B重新查询，则能查询出A操作后的最新数据，但是当A事务rollback回滚后，A操作的数据其实没有变化，这时候B处的数据就变成了脏数据(容易导致脏读情形产生)</p>
<p>设置隔离级别为读未提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 设置隔离级别</span><br><span class="line">set session transaction isolation level    read uncommitted;</span><br><span class="line"> - 查看隔离级别</span><br><span class="line">select  @@transaction_isolation;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p><strong>读已提交(不可重复读 read committed)oracle默认的隔离级别</strong>:读已提交，表示只有执行了commit命令后，才能得知数据的变化，A修改了数据，没有提交，B不会察觉到数据的变化。这样虽然会避免脏读，但是会出现，当A读取某一条数据时候，B正在对该数据进行操作(修改)，但是B操作并没有结束，因此此时数据并没有发生变化，但是A在B事务提交前已经执行完了，那就会出现数据不一致现象，这种问题叫做不可重复读。</p>
<p>设置隔离级别为读已提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> - 设置隔离级别</span><br><span class="line">set session transaction isolation level    read committed;</span><br><span class="line">  - 查看隔离级别</span><br><span class="line">select  @@transaction_isolation;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>可重复读(repeatable read mysql 的默认隔离级别)</strong></p>
<p>可重复读与不可重复读很容易搞混淆，<strong>可重复读侧重于有没有进行行增加减少，也就是新增和删除，而不可重复读侧重于修改操作，不影响行数。</strong>可重复读是采用锁行形式，因为是锁行，所以无法保证对行数的操作限制隔离，只能保证当前锁住的行隔离影响。</p>
<p><strong>串行化</strong></p>
<p>最可靠的事务隔离级别。“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。因为串行化是锁表，因此虽然隔离级别最高，但是消耗资源最大</p>
<p>mysql数据库默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ ）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>修改数据库的事务隔离级别为<strong>不可重复读 READ-UNCOMMITTED</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-UNCOMMITTED        |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>



<p>这下面是MySQL8的事务隔离级别，MySQL5的话可重读读，还是会出现幻读</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，然后后一个事务进行回滚，将数据变成之前的值，那么前一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<font color='red'><strong>（读取未提交数据）</strong></font></li>
</ul>
<table>
<thead>
<tr>
<th align="center">时间顺序</th>
<th>转账事务</th>
<th>取款事务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td align="center">2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td></td>
<td>查询账户余额为2000元</td>
</tr>
<tr>
<td align="center">4</td>
<td></td>
<td>取款1000元，余额被更改为1000元</td>
</tr>
<tr>
<td align="center">5</td>
<td>查询账户余额为1000元（产生脏读）</td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td></td>
<td>取款操作发生未知错误，事务回滚，余额变更为2000元</td>
</tr>
<tr>
<td align="center">7</td>
<td>转入2000元，余额被更改为3000元（脏读的1000+2000）</td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td align="center">备注</td>
<td>按照正确逻辑，此时账户余额应该为4000元</td>
<td></td>
</tr>
</tbody></table>
<p>注意：这里要修改mysql的事务隔离级别为<strong>不可重复读（ READ-UNCOMMITTED ）</strong></p>
<p>account表中的原始状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173951.png" alt="image-20211231200932520"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173954.png" alt="image-20211231201320508"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173957.png" alt="image-20211231201342895"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173959.png" alt="image-20211231201534124"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174001.png" alt="image-20211231201641543"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174002.png" alt="image-20220101115134146"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174005.png" alt="image-20220101115237036"></p>
<ul>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
</ul>
<ul>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。**<font color='red'>（前后多次读取，数据内容不一致）</font>**</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174008.png" alt="image-20220101144933767"></p>
<img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174009.png" alt="image-20220101150808461" />

<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174011.png" alt="image-20220101150929999"></p>
<ul>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现<strong>多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。**<font color='red'>（前后多次读取，数据总量不一致）</font>**</li>
</ul>
<p>绿衣捧砚催题卷，红袖添香伴读书</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://losserlong.github.io/2022/01/16/juc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang">
      <meta itemprop="description" content="Stay Hungry,Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/16/juc/" class="post-title-link" itemprop="url">newpapername</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-16 18:36:04" itemprop="dateCreated datePublished" datetime="2022-01-16T18:36:04+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 17:30:18" itemprop="dateModified" datetime="2022-01-18T17:30:18+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="juc并发编程"><a href="#juc并发编程" class="headerlink" title="juc并发编程"></a>juc并发编程</h1><h2 id="juc简介"><a href="#juc简介" class="headerlink" title="juc简介"></a>juc简介</h2><p>java.util .concurrent，Java并发包</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172801.png" alt="image-20220103094918335"></p>
<h2 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h2><ol>
<li>手写单例模式</li>
<li>手写冒泡排序</li>
<li>生产者消费者变种题目</li>
</ol>
<h2 id="进程-线程回顾"><a href="#进程-线程回顾" class="headerlink" title="进程/线程回顾"></a>进程/线程回顾</h2><h3 id="进程-线程是什么？"><a href="#进程-线程是什么？" class="headerlink" title="进程/线程是什么？"></a>进程/线程是什么？</h3><p><strong>进程：</strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。（<strong>简单来说，进程就是后台运行的一个程序</strong>）</p>
<p><strong>线程：</strong>  <strong>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程</strong>，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把<strong>线程作为独立运行和独立调度的基本单位</strong>，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h3 id="进程-线程例子？"><a href="#进程-线程例子？" class="headerlink" title="进程/线程例子？"></a>进程/线程例子？</h3><p> 使用QQ，查看进程一定有一个QQ.exe的<strong>进程</strong>，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>
<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>
<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个<strong>线程</strong>：容灾备份，语法检查</p>
<h3 id="什么是并发？什么是并行？"><a href="#什么是并发？什么是并行？" class="headerlink" title="什么是并发？什么是并行？"></a>什么是并发？什么是并行？</h3><p><strong>并发：</strong>同一时刻多个线程在访问<strong>同一个资源</strong>，多个线程对一个点<br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br>**并行： ** <strong>多项工作一起执行</strong>，之后再汇总<br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172810.png" alt="image-20220114130053636"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172814.png" alt="image-20220103110849404"></p>
<h2 id="thread-start"><a href="#thread-start" class="headerlink" title="thread.start"></a>thread.start</h2><p>thread.start表示线程进入<strong>就绪状态</strong>（不是立刻进行调用），是在调用run方法是在cup和操作系统对这个<strong>线程进行调度</strong>的时候。</p>
<h2 id="Thread的状态"><a href="#Thread的状态" class="headerlink" title="Thread的状态"></a>Thread的状态</h2><p>waite()和sleep()的比较，wait放开去睡，放开了手里的锁。</p>
<p>sleep()捏紧了手去睡，醒了还有手里的锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172819.png" alt="image-20220103164224117"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread state for a thread which has not yet started.</span><br><span class="line"> */</span><br><span class="line">NEW,</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line"> * state is executing in the Java virtual machine but it may</span><br><span class="line"> * be waiting for other resources from the operating system</span><br><span class="line"> * such as processor.</span><br><span class="line"> */</span><br><span class="line">RUNNABLE,</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line"> * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line"> * to enter a synchronized block/method or</span><br><span class="line"> * reenter a synchronized block/method after calling</span><br><span class="line"> * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line"> */</span><br><span class="line">BLOCKED,</span><br></pre></td></tr></table></figure>



<h3 id="WAITING和TIMED-WAITING的区别"><a href="#WAITING和TIMED-WAITING的区别" class="headerlink" title="WAITING和TIMED_WAITING的区别"></a>WAITING和TIMED_WAITING的区别</h3><p>WAITING这个是一直等，死死的等，俗称不见不散</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">等待线程的线程状态。</span><br><span class="line"></span><br><span class="line">由于调用了一个</span><br><span class="line"></span><br><span class="line">以下方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"> * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"> * following methods:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"> * perform a particular action.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment"> * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WAITING,</span><br></pre></td></tr></table></figure>





<p>TIMED_WAITING是定时等待，俗称过时不候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">具有指定等待时间的等待线程的线程状态。</span><br><span class="line"></span><br><span class="line">由于调用其中一个线程，线程处于定时等待状态</span><br><span class="line"></span><br><span class="line">具有指定正等待时间的以下方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"> * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"> * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TIMED_WAITING,</span><br></pre></td></tr></table></figure>





<h2 id="经典卖票问题"><a href="#经典卖票问题" class="headerlink" title="经典卖票问题"></a>经典卖票问题</h2><p>一般多线程问题可以简化为：线程        操作（资源类暴露的方法）        资源类</p>
<h3 id="版本1使用匿名内部类"><a href="#版本1使用匿名内部类" class="headerlink" title="版本1使用匿名内部类"></a>版本1使用匿名内部类</h3><p><strong>资源类</strong>：这里也可以使用同步方法或者同步代码块（但是粒度太大）</p>
<p>这里使用的Lock的实现类ReentrantLock()可重入锁，相比synchronized同步锁来说更加灵活，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类：票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定初始值为30张</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReentrantLock可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作,这里使用synchronized就相当于把这个saleTicket全部都锁住了，粒度太大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先判断number是否大于0</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadName = &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;\t卖出第：&quot;</span> + (number--) + <span class="string">&quot;\t还剩下&quot;</span> + number);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;票已经卖完&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>抢票类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/03    10:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：三个售票员     卖出      30张票</span></span><br><span class="line"><span class="comment"> *多线程编程的企业套路+模板</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.在高内聚低耦合的前提下：线程         操作（资源类对外暴露的调用方法）          资源类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *抢票类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  <span class="comment">// main程序一切入口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程t1，t2</span></span><br><span class="line"><span class="comment">//        Thread t1 = new Thread();</span></span><br><span class="line"><span class="comment">//        Thread t2 = new Thread();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread(Runnable target, String name)</span></span><br><span class="line"><span class="comment">//        // 启动线程</span></span><br><span class="line"><span class="comment">//        t1.start();</span></span><br><span class="line"><span class="comment">//        t2.start();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面三个线程(A、B、C)操作同一个资源类</span></span><br><span class="line">        Ticket1 ticket = <span class="keyword">new</span> Ticket1();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="版本二使用lambda表达式"><a href="#版本二使用lambda表达式" class="headerlink" title="版本二使用lambda表达式"></a>版本二使用lambda表达式</h3><p>Lambda Express 使用的场景：当一个接口中只有一个抽象方法，其他的默认方法有几个无所谓。</p>
<p>Lambda Express表达式的小口诀： <strong>拷贝小括号（小括号是接口中的方法），写死右箭头，落地大括号。</strong></p>
<p>@FunctionalInterface注解声明式函数式接口，其实可以不用加，在底层默认给加上了</p>
<p>Foo接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有且只有一个抽象方法的接口称为“函数式接口”</span><br><span class="line"> */</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Foo &#123;</span><br><span class="line">//    public void sayHello();</span><br><span class="line"></span><br><span class="line">    int add(int a, int b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    default int div(int a, int b) &#123;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态方法实现</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    static int mv(int a, int b) &#123;</span><br><span class="line"></span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Foo接口中的Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpressDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*        Foo foo = new Foo() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void sayHello() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;*******************hello java 2022&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Foo foo = () -&gt; &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;*******************hello java lambda&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        foo.sayHello();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以把方法的参数类型省略</span></span><br><span class="line">        Foo foo = (a, b) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;a+b = &quot;</span> + a + b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        foo.add(<span class="number">1234</span>, <span class="number">45</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(foo.div(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(Foo.mv(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="线程交互问题：笔试题目之交替打印0和1"><a href="#线程交互问题：笔试题目之交替打印0和1" class="headerlink" title="线程交互问题：笔试题目之交替打印0和1"></a>线程交互问题：笔试题目之交替打印0和1</h2><p>这个就是<strong>生产者和消费者模型。</strong></p>
<p>笔试题目：<br>题目:现在两个线程，可以操作初始值为零的一个变量,<br>实现一个线程对该变量加，一个线程对该变量减i，<br>实现交替，来10轮，变量初始值为零。</p>
<h3 id="两个线程交替打印1-0版"><a href="#两个线程交替打印1-0版" class="headerlink" title="两个线程交替打印1.0版"></a>两个线程交替打印1.0版</h3><p>这里有一个坑，但是两个线程的时候不会出现，当线程多的时候就会出现。这里的判断条件不能用if，只能用while。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/03    18:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * 笔试题目：</span></span><br><span class="line"><span class="comment"> * 题目:现在两个线程，可以操作初始值为零的一个变量,</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加，一个线程对该变量减i，</span></span><br><span class="line"><span class="comment"> * 实现交替，来10轮，变量初始值为零。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 1.高内聚低耦合的前提下，线程       操作      资源类</span></span><br><span class="line"><span class="comment"> *    2.   判断/干活/通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者消费者复习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotifyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AirCondition airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生产蛋糕，做加法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费蛋糕，做减法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> *  1.0版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对number进行加1</span></span><br><span class="line"><span class="comment">     * 这里有三步，</span></span><br><span class="line"><span class="comment">     * 1、判断number的值是否为0</span></span><br><span class="line"><span class="comment">     * 2、做加法</span></span><br><span class="line"><span class="comment">     * 3、通知消费者来吃蛋糕</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 生产者线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断</span></span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.干活</span></span><br><span class="line">        number++;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通知(唤醒等待的线程)</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对number进行减1</span></span><br><span class="line"><span class="comment">     * synchronized加上同步锁</span></span><br><span class="line"><span class="comment">     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待</span></span><br><span class="line"><span class="comment">     * 消费者线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断，等于0，没有蛋糕，就得先等</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.干活</span></span><br><span class="line">        number--;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通知(唤醒等待的线程)</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两个线程交替打印2-0版（变成四个线程）"><a href="#两个线程交替打印2-0版（变成四个线程）" class="headerlink" title="两个线程交替打印2.0版（变成四个线程）"></a>两个线程交替打印2.0版（变成四个线程）</h3><p>这里升级为四个线程进行操作，一个加一个减，一个加一个减</p>
<p>/*        if (number != 0) {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  A可能没有执行下面的wait的时候，线程调度的时候就停止了，</span></span><br><span class="line">    <span class="comment">//  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)</span></span><br><span class="line">    <span class="comment">// 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了</span></span><br><span class="line">    <span class="keyword">this</span>.wait();</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotifyDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AirCondition1 ac1 = <span class="keyword">new</span> AirCondition1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程A</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    ac1.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程B</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">400</span>);</span><br><span class="line">                    ac1.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程C</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    ac1.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程D</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ac1.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> * 2.0版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对number进行加1</span></span><br><span class="line"><span class="comment">     * 这里有三步，</span></span><br><span class="line"><span class="comment">     * 1、判断number的值是否为0</span></span><br><span class="line"><span class="comment">     * 2、做加法</span></span><br><span class="line"><span class="comment">     * 3、通知消费者来吃蛋糕</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 生产者线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sleep不会释放线程的所有权(锁)而wait会，所以下面配合synchronized使用</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这个式调用无参的wait</span></span><br><span class="line"><span class="comment">         * 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。</span></span><br><span class="line"><span class="comment">         * 换句话说，这个方法的行为就好像简单地执行呼叫wait(0) 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * wait()</span></span><br><span class="line"><span class="comment">         * 当前的线程必须拥有该对象的显示器。 线程释放此监视器的所有权(锁)，并等待直到发生以下两种情况之一：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 另一个线程通知等待该对象的监视器的线程通过调用notify方法或notifyAll方法来唤醒。</span></span><br><span class="line"><span class="comment">         * 由timeout毫秒加nanos纳秒参数指定的超时时间已过。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment">         *          while (&lt;condition does not hold&gt;)</span></span><br><span class="line"><span class="comment">         *              obj.wait(timeout, nanos);</span></span><br><span class="line"><span class="comment">         *          ... // Perform action appropriate to condition</span></span><br><span class="line"><span class="comment">         *      &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.判断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里不能用if进行判断，如果使用if的话会出现虚假唤醒，因为if只判断一次（这个是最主要原因）</span></span><br><span class="line"><span class="comment">/*        if (number != 0) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //  A可能没有执行下面的wait的时候，线程调度的时候就停止了，</span></span><br><span class="line"><span class="comment">            //  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)</span></span><br><span class="line"><span class="comment">            // 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了</span></span><br><span class="line"><span class="comment">            this.wait();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.干活</span></span><br><span class="line">        number++;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产了数据:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通知(唤醒等待的线程)</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对number进行减1</span></span><br><span class="line"><span class="comment">     * synchronized加上同步锁</span></span><br><span class="line"><span class="comment">     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待</span></span><br><span class="line"><span class="comment">     * 消费者线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断，等于0，没有蛋糕，就得先等</span></span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.干活</span></span><br><span class="line">        number--;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了数据:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通知(唤醒等待的线程)</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172832.png" alt="image-20220104161856205"></p>
<h3 id="改编题目"><a href="#改编题目" class="headerlink" title="改编题目"></a>改编题目</h3><p>题目内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下:</span><br><span class="line">AA打印5次，BB打10次，CC打印15次接着  (这里又线程之间的通信,这里是精确通知)</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br></pre></td></tr></table></figure>

<p>由于这里是三个线程进行打印而且还有顺序，通过使用标志位加Condition接口中的signal();实现精准通知。当A线程进入执行完打印操作之后，将标志位进行改变，就精准通知B线程。同理B完成之后通知C，C然后再通知A实现A-&gt;B-&gt;C（其实都是number标志位起了作用）</p>
<p><strong>资源类的代码如下</strong></p>
<ul>
<li>第一种使用Lock锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> * 作业：将三个方法合并成一个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1:A  2:B   3:C   标志位1对于A,2对应B,3对应C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;    <span class="comment">// 设定标志位的初始值为1</span></span><br><span class="line">    <span class="comment">// lock就相当于锁，而下面的condition就相当于钥匙，一把锁配三把钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印五次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 进行等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.通知</span></span><br><span class="line">            <span class="comment">// 将标志位进行更改</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里精准唤醒2线程</span></span><br><span class="line">            <span class="comment">// 唤醒condition2锁了的线程（唤醒2线程）</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印十次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 进行等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.通知</span></span><br><span class="line">            <span class="comment">// 将标志位进行更改</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 唤醒等待的线程 （唤醒3线程）</span></span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印十五次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 进行等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.通知</span></span><br><span class="line">            <span class="comment">// 将标志位进行更改</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 唤醒等待的线程（唤醒1线程）</span></span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种使用同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/07    9:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * 也可以用synchronized同步方法和wait和notifyAll，其实就是number标志位起了作用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1代表A ，   2代表B    3代表C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print5s</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print10s</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        number = <span class="number">3</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print15s</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        number = <span class="number">1</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotifyDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AirCondition3 airCondition2 = <span class="keyword">new</span> AirCondition3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                airCondition2.print5s();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                airCondition2.print10s();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                airCondition2.print15s();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="使用lock替换synchronized"><a href="#使用lock替换synchronized" class="headerlink" title="使用lock替换synchronized"></a>使用lock替换<strong>synchronized</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172836.png" alt="image-20220104163122288"></p>
<p>将synchronized同步方法换成Lock锁，Lock更加灵活，<strong>synchronized使用的是Object类中wait和notify/notifyAll。</strong>而在Lock中<code>Lock</code>实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。  它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象<code>Condition</code>。</p>
<p><code>Condition</code>因素出<code>Object</code>监视器方法（ <a href="../../../../java/lang/Object.html#wait--"><code>wait</code></a> ， <a href="../../../../java/lang/Object.html#notify--"><code>notify</code></a>和<a href="../../../../java/lang/Object.html#notifyAll--"><code>notifyAll</code></a>  ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果<code>Lock</code>实现。 <code>Lock</code>替换<code>synchronized</code>方法和语句的使用，  <code>Condition</code>取代了对象监视器方法的使用。 <code>Condition</code>使用的是<code>await()</code> 和<code>signal()</code> /<code>signalAll()</code>对应Object类的<strong>wait和notify/notifyAll。</strong></p>
<p><strong>资源类和操作类的代码。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/04    16:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将锁换成Lock</span></span><br><span class="line"><span class="comment"> * 1.高内聚低耦合的前提下，线程       操作      资源类</span></span><br><span class="line"><span class="comment"> * 2.   判断/干活/通知</span></span><br><span class="line"><span class="comment"> * 3.   多线程交互的过程中，必须要防止多线程的虚假唤醒，也即(判断使用while，不能用if)</span></span><br><span class="line"><span class="comment"> * (在方法的判断中不许用if，只能用while)</span></span><br><span class="line"><span class="comment"> * 4.   注意标志位的修改和定位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotifyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AirCondition2 airCondition2 = <span class="keyword">new</span> AirCondition2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition2.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition2.decrease();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition2.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程C&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition2.decrease();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者对number的值进行加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对资源进行上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//    this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.干活</span></span><br><span class="line">            ++number;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产了&quot;</span> +<span class="string">&quot;\t&quot;</span>+ number);</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line"><span class="comment">//            this.notify();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 对资源进行释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者对number的值进行减1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对资源进行上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//    this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> +<span class="string">&quot;\t&quot;</span>+ number);</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line"><span class="comment">//            this.notify();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 对资源进行释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="多线程8锁"><a href="#多线程8锁" class="headerlink" title="多线程8锁"></a>多线程8锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：多线程8锁</span><br><span class="line">    其实下面就是看synchronized锁的是什么对象</span><br><span class="line">    普通同步方法锁的就是this这个当前对象，而不是锁住这个单独的synchronized方法，也就是说同一时间段，只能有一个线程进入当前类，访问一个synchronized方法</span><br><span class="line">    静态同步方法锁的就是类.Class这个对象也就是类对象，同时去复习一下static关键字</span><br><span class="line">    普通方法没有加synchronized就不会上锁</span><br><span class="line">    对于同步方法块，锁是Synchonized括号里配置的对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="line">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="line">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="line"> </span><br><span class="line">加个普通方法后发现和同步锁无关</span><br><span class="line">换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="line">具体表现为以下3种形式。</span><br><span class="line">对于普通同步方法，锁是当前实例对象。</span><br><span class="line">对于静态同步方法，锁是当前类的Class对象。</span><br><span class="line">对于同步方法块，锁是Synchonized括号里配置的对象</span><br><span class="line"> </span><br><span class="line">当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="line"> </span><br><span class="line">也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="line">可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</span><br><span class="line">所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</span><br><span class="line"> </span><br><span class="line">所有的静态同步方法用的也是同一把锁——类对象本身，</span><br><span class="line">这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</span><br><span class="line">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span><br><span class="line">而不管是同一个实例对象的静态同步方法之间，</span><br><span class="line">还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>1、标准访问，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>2、 停4秒在短信方法内，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>3 、普通的hello方法，是先打短信还是hello</li>
</ul>
<p><code>hello</code></p>
<ul>
<li>4 、现在有两部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<ul>
<li>5 、两个静态同步方法，1部手机，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>6 、两个静态同步方法，2部手机，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>7 、1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<ul>
<li>8 、1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于这里线程睡了0.2秒钟，线程A就已经完成启动和调度了</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//                phone.sendMsg();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            phone2.sendMsg();</span><br><span class="line"><span class="comment">//            phone.hello();</span></span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程睡四秒钟</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------------sendMsg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通方法，没有加锁，就不用争抢锁资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-------------------------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="交替打印100以内的奇数和偶数"><a href="#交替打印100以内的奇数和偶数" class="headerlink" title="交替打印100以内的奇数和偶数"></a>交替打印100以内的奇数和偶数</h2><p>这里有一个大坑，你要先将另一把锁唤醒之后，然后将自己进入等待状态。不然的话，会出现死锁，连哥哥线程都在等待对方唤醒。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>是指多个进程在运行过程中因争夺资源而造成的一种僵局，</strong>当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程T1，按照先锁R1再获得锁R2的的顺序获得锁，而在此同时又有另外一个线程T2，按照先锁T2再锁T1的顺序获得锁。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172842.png" alt="image-20220106100435845"></p>
<h3 id="第一种使用Lock锁"><a href="#第一种使用Lock锁" class="headerlink" title="第一种使用Lock锁"></a>第一种使用Lock锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareSource1 ss = <span class="keyword">new</span> ShareSource1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;ss.print();&#125;,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;ss.print();&#125;,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareSource1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + number);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="comment">//    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.</span></span><br><span class="line">                <span class="comment">// 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁</span></span><br><span class="line"><span class="comment">//                this.wait();</span></span><br><span class="line"><span class="comment">//                this.notify();</span></span><br><span class="line">                <span class="comment">// 为了避免死锁，得先将进行唤醒，然后再去等待</span></span><br><span class="line"></span><br><span class="line">                condition.signal();</span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种使用synchronized静态代码块"><a href="#第二种使用synchronized静态代码块" class="headerlink" title="第二种使用synchronized静态代码块"></a>第二种使用synchronized静态代码块</h3><p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareSource2 ss2 = <span class="keyword">new</span> ShareSource2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss2.print();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss2.print();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareSource2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">while</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + number);</span><br><span class="line">                number++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.</span></span><br><span class="line">                <span class="comment">// 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁</span></span><br><span class="line"><span class="comment">//                this.wait();</span></span><br><span class="line"><span class="comment">//                this.notify();</span></span><br><span class="line">                <span class="comment">// 为了避免死锁，得先将进行唤醒，然后再去等待</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="集合中的一些比较"><a href="#集合中的一些比较" class="headerlink" title="集合中的一些比较"></a>集合中的一些比较</h1><h2 id="请举例说明集合类是不安全的"><a href="#请举例说明集合类是不安全的" class="headerlink" title="请举例说明集合类是不安全的"></a>请举例说明集合类是不安全的</h2><h3 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h3><p>ArrayList、HashMap、HashSet都是线程不安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">// Collections.synchronizedList(new ArrayList&lt;String&gt;());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现异常java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">// 多线程条件下，既要读又要写</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>故障现象</strong></p>
<p>java.util.ConcurrentModificationException并发修改异常</p>
</li>
<li><p><strong>导致原因</strong><br>多线程条件下，既要读又要写</p>
</li>
<li><p><strong>解决方案</strong></p>
<p>3.1 用Vector,它的底层在add方法加了同步锁<br>3.2 Collections.synchronizedList(new ArrayList<String>());<br>3.3 new CopyOnWriteArrayList&lt;&gt;();    </p>
</li>
<li><p>将代码块抽取成方法的快捷键<strong>Ctrl+Alt+m</strong></p>
</li>
</ol>
<p>ArrayList的add方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="在多线程条件下不使用ArrayList"><a href="#在多线程条件下不使用ArrayList" class="headerlink" title="在多线程条件下不使用ArrayList"></a>在多线程条件下不使用ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        // 将数组转List</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span></span><br><span class="line"><span class="comment">        // 方法的引用</span></span><br><span class="line"><span class="comment">        list.forEach(System.out ::println);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成当前的时间戳</span></span><br><span class="line">        <span class="comment">//    System.currentTimeMillis();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种方法：（线程不安全） new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 第二种方法（不推荐）   new Vector&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 第三种：使用Collections.synchronizedList将线程不安全的的List转换成线程安全的</span></span><br><span class="line">        <span class="comment">// 第四种：使用  new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap线程不安全使用ConcurrentHashMap</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">// Collections.synchronizedList(new ArrayList&lt;String&gt;());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出现异常java.util.ConcurrentModificationException</span></span><br><span class="line">        <span class="comment">// 多线程条件下，既要读又要写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>多线程条件下，一般使用这个报下面的类，后面的三个都是java.util.concurrent并发包下面的。</p>
<ul>
<li>ArrayList   ——&gt;    CopyOnWriteArrayList</li>
<li>HashSet    ——&gt;    CopyOnWriteArraySet</li>
<li>HashMap   ——&gt;    ConcurrentHashMap</li>
</ul>
<h3 id="回忆集合的基础知识"><a href="#回忆集合的基础知识" class="headerlink" title="回忆集合的基础知识"></a>回忆集合的基础知识</h3><p>HashSet的底层数据结构是HashMap，存的是map的key，它的value是一个写死的Object的常量</p>
<p>HashSet的add方法是调用的HashMap的put方法</p>
<p>HashMap的底层1.8是<strong>Node数组+链表+红黑树，1.7是哈希表</strong></p>
<p>jdk1.8</p>
<p>构造求一个空的HashMap，默认的初始容量是（16），默认的负载因子是（0.75）</p>
<p>HashMap和HashSet都是无序的</p>
<p>无序性：无序性不等于随机性。指的是存储的数据在底层数组中并非按照数组索引的顺序进行添加的，而使根据数值的哈希值决定的。</p>
<p>ArrayList扩容是扩容为原来的1.5倍</p>
<p>HashMap扩容是扩大到原来的两倍，在使用的时候可以将他的初始容量设大，这样就可以避免它反复扩容了。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><strong>java.util.concurrent.CopyOnWriteArrayList<E></strong> </li>
</ul>
<p><font color='orange'><strong>写时复制技术原理</strong></font></p>
<p><strong>CopyOnWrite容器即写时复制的容器。</strong>往一个容器添加元素的时候，不直接往当前容器Object[]添加，<br>而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。<br>添加元素后，再将原容器的引用指向新的容器setArray(newElements)。<br>这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<hr>
<p>CopyOnWriteArrayList的原理：简单的来说当A线程去写的时候，先复制一份1.1版的，然后自己用这个1.1版的去写，如果其他的线程要读的时候就去读1.0版本的，当A写完之后再发布1.1版的。<strong>（其实也就是读写分离思想）</strong></p>
<p>CopyOnWriteArrayList是线程安全的，下面是它的add方法的源码，它会先将传入的集合进行复制一份，然后将新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment">     * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是复制一份新的，然后用Object数组进行接收</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获得原来的集合的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 对elements数组进行扩容长度加一得到新的newElements</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的e，添加到数组的最后</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 再将newElements重新设置回CopyOnWriteArrayList对象中，就是相当于1.1版本的替换1.0版本的 </span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="comment">// 添加完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>HashMap的put方法，put里面其实装的是一个个的Node结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HashMap的put装的是一个个的Node结点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><h2 id="复习获得多线程的方式"><a href="#复习获得多线程的方式" class="headerlink" title="复习获得多线程的方式"></a>复习获得多线程的方式</h2><p>面试题：获得多线程的方法几种？</p>
<ul>
<li>继承Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/06    19:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * 实现多线程的方式二继承Thread类，重写run方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread1 t1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(t1,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        t1.setName(&quot;线程A&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        MyThread1 t2 = new MyThread1();</span></span><br><span class="line"><span class="comment">        t2.setName(&quot;线程B&quot;);</span></span><br><span class="line"><span class="comment">        t2.start();*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/06    19:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * 实现多线程的方式一</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;\t\t&quot;</span>+ number);</span><br><span class="line">                    number--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable的简单使用"><a href="#Callable的简单使用" class="headerlink" title="Callable的简单使用"></a>Callable的简单使用</h2><ul>
<li>实现Callable接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172853.png" alt="image-20220108212709371"></p>
<p><strong>实现多线程的方式三之实现Callable接口</strong>，之前两种太简单了就不写了</p>
<p><strong>get方法</strong>一般请放在最后一行,因为如果实现的Callable类中有阻塞的话，它会等它执行完才会执行下面的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/06    20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 选中那个接口，然后使用Ctrl+Alt+U查看这个类或者接口的类图</span></span><br><span class="line"><span class="comment"> * get方法一般请放在最后一行,因为如果实现的Callable类中有阻塞的话</span></span><br><span class="line"><span class="comment"> * 它会等它执行完才会执行下面的</span></span><br><span class="line"><span class="comment"> *在·</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程实现方法三实现Callable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t\t  hello world&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interface RunnableFuture&lt;V&gt; 是Runnable的子接口 。FutureTask实现了RunnableFuture接口、</span></span><br><span class="line">        <span class="comment">// FutureTask的一个构造方法   FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line">        <span class="comment">// Thread(Runnable target, String name) ， 在Thread的构造器中只要传入Runnable或者Runnable的子接口或者实现类即可</span></span><br><span class="line">        <span class="comment">// 这里主要是多态的的思想</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印结果</span></span><br><span class="line"><span class="comment">         * hello world</span></span><br><span class="line"><span class="comment">         * 1024</span></span><br><span class="line"><span class="comment">         * main计算完成、</span></span><br><span class="line"><span class="comment">         * 这里只会打印一次hello world，因为它有缓存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;线程a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;线程b&quot;</span>).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;计算完成&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 面试题:callable接口与runnable接口的区别？</p>
<p> 答：（1）是否有返回值<br>       （2）是否抛异常<br>       （3）落地方法不一样，一个是run，一个是call</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>未来的任务，用它就干一件事，异步调用<br>main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p>
<p>  <img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220108213632391.png" alt="image-20220108213632391"></p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，<br>水买回来了放桌上，我需要的时候再去get。<br>（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，<br>FutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果<br>（3）高考：会做的先做，不会的放在后面做</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，<br>就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，<br>然后会返回结果或者抛出异常。 </p>
<p><strong>只计算一次</strong><br><strong>get方法放到最后</strong></p>
<p>FutureTask类图 <img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220107131432435.png" alt="image-20220107131432435"></p>
<h1 id="JUC强大的辅助类讲解"><a href="#JUC强大的辅助类讲解" class="headerlink" title="JUC强大的辅助类讲解"></a>JUC强大的辅助类讲解</h1><h2 id="CountDownLatch-减少计数"><a href="#CountDownLatch-减少计数" class="headerlink" title="CountDownLatch 减少计数"></a>CountDownLatch 减少计数</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>生活中的实例就是晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门，减少计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/07    15:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * CountDownLatch</span></span><br><span class="line"><span class="comment"> * 这个类似生活中的例子：晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门</span></span><br><span class="line"><span class="comment"> * 减少计数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 构造一个以给定计数 CountDownLatch CountDownLatch。 java.util.concurrent</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开教室&quot;</span>);</span><br><span class="line">                <span class="comment">//countDown() 减少锁存器的计数，如果计数达到零，释放所有等待的线程。</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导致当前线程等到锁存器计数到零，除非线程是 interrupted,</span></span><br><span class="line">        <span class="comment">// 其实也就是说当里面的count减少到0就不用等待了，唤醒线程</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t班长关闭教室&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开教室&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t班长关闭教室&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier  循环栅栏"></a>CyclicBarrier  循环栅栏</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><strong>CyclicBarrier</strong> 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞， 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p>
<p>这个可以举一个简单的例子就<strong>是，集齐七颗龙珠召唤神龙，还有就是开会，必须要等到人到齐了才能开会。</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/07    15:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * java.util.concurrent  CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 其实这个有点像生活中的例子：开会，还有七龙珠，集齐七颗龙珠召唤神龙</span></span><br><span class="line"><span class="comment"> * 开会必须等待所有人都到齐了才行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待所有parties已经在这个障碍上调用了await 。</span></span><br><span class="line"><span class="comment">         * 如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：</span></span><br><span class="line"><span class="comment">         * 最后一个线程到达; 要么</span></span><br><span class="line"><span class="comment">         * 一些其他线程当前线程为interrupts ; 要么</span></span><br><span class="line"><span class="comment">         * 一些其他线程interrupts其他等待线程之一; 要么</span></span><br><span class="line"><span class="comment">         * 一些其他线程在等待屏障时超时; 要么</span></span><br><span class="line"><span class="comment">         * 其他一些线程在这个屏障上调用reset() 。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集到的\t第&quot;</span> + temp + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待所有parties已经在这个障碍上调用了await 。</span></span><br><span class="line">                    <span class="comment">//如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：最后一个线程到了</span></span><br><span class="line">                    <span class="comment">// 也就是等到最后一个线程到了，然后就开始执行start，start之后，线程的调度顺序还得看操作系统和cup的调度</span></span><br><span class="line">                    cb.await();</span><br><span class="line">                    <span class="comment">// 执行完成之后，就调用CyclicBarrier(int parties, Runnable barrierAction) 里面的barrierAction线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程\t&quot;</span> + i).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore 信号灯"></a>Semaphore 信号灯</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在信号量上我们定义两种操作：</p>
<p>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</p>
<p> release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</p>
<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<p><strong>这个可以用生活中的抢车位来类比</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/07    16:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * Semaphore这个主要是应用于抢车位</span></span><br><span class="line"><span class="comment"> * 这个主要用于多线程的并发控制和资源的互斥</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟资源类，有三个空车位</span></span><br><span class="line">        <span class="comment">// 当permits设置为1就相当于synchronized了</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从此信号量获取许可证，阻止直到可用，否则线程为interrupted 。</span></span><br><span class="line">                    <span class="comment">//获得许可证，如果有可用并立即返回，则将可用许可证数量减少一个。</span></span><br><span class="line">                    <span class="comment">// 这里相当于抢占到车位</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t抢到了车位&quot;</span>);</span><br><span class="line">                    <span class="comment">// 线程睡4秒钟，模拟停车停了4秒钟</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//发放许可证，将可用许可证的数量增加一个。 如果任何线程尝试获取许可证，</span></span><br><span class="line">                    <span class="comment">// 那么选择一个被授予刚被释放的许可证。 （重新）线程调度用于线程调度。</span></span><br><span class="line">                    <span class="comment">// 这里相当于释放掉车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="ReentrantReadWriteLock读写锁"><a href="#ReentrantReadWriteLock读写锁" class="headerlink" title="ReentrantReadWriteLock读写锁"></a>ReentrantReadWriteLock读写锁</h1><h2 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h2><p>红蜘蛛、缓存、数据库的更新和查询操作。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/07    22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span></span><br><span class="line"><span class="comment"> * 但是</span></span><br><span class="line"><span class="comment"> * 如果有一个线程想去写共享资源来，就不应该再有其他线程可以对该资源进行读或者写</span></span><br><span class="line"><span class="comment"> * 小总结：</span></span><br><span class="line"><span class="comment"> *          读-读能共存</span></span><br><span class="line"><span class="comment"> *          读-写不能共存</span></span><br><span class="line"><span class="comment"> *          写-写不能共存</span></span><br><span class="line"><span class="comment"> * 使用读写锁，保证了数据的一致性操作  读锁是共享锁</span></span><br><span class="line"><span class="comment"> * 其实就是写加写锁,读就加读锁       写锁是排他锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加写锁</span></span><br><span class="line">            readWriteLock.writeLock().lock();</span><br><span class="line">            <span class="comment">// 写入开始</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t------写入开始&quot;</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t------写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加写锁</span></span><br><span class="line">            readWriteLock.readLock().lock();</span><br><span class="line">            <span class="comment">// 读取开始</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t~~~~~~~~~~~~~~~~~~~~~~读取开始&quot;</span>);</span><br><span class="line">            map.get(key);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t~~~~~~~~~~~~~~~~~~~~~~&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;.读取完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                myCache.put(temp + <span class="string">&quot;\t&quot;</span>, temp + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(temp + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>阻塞队列，空的时候不能消费，满的时候不能增加</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172859.png" alt="image-20220109110721761"></p>
<h1 id="BlockingQueueDemo-阻塞队列"><a href="#BlockingQueueDemo-阻塞队列" class="headerlink" title="BlockingQueueDemo  阻塞队列"></a>BlockingQueueDemo  阻塞队列</h1><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈：先进后出，<strong>后进先出</strong></p>
<p>队列：先进先出</p>
<h2 id="阻塞队列的简单说明"><a href="#阻塞队列的简单说明" class="headerlink" title="阻塞队列的简单说明"></a>阻塞队列的简单说明</h2><p><strong>阻塞：必须要阻塞/不得不阻塞</strong><br>阻塞队列是一个队列，在数据结构中起的作用如下图：<img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172904.png" alt="image-20220109154737709"></p>
<p>当队列是空的，从队列中<strong>获取</strong>元素的操作将会被<strong>阻塞</strong><br>当队列是满的，从队列中<strong>添加</strong>元素的操作将会被<strong>阻塞</strong></p>
<p>试图从<strong>空的队列中获取元素的线程将会被阻塞</strong>，<strong>直到其他线程往空的队列插入新的元素</strong></p>
<p>试图<strong>向已满的队列中添加新元素的线程将会被阻塞</strong>，<strong>直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</strong>    </p>
<h2 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h2><p>在多线程领域：所谓阻塞，在某些情况下会<strong>挂起</strong>线程（即阻塞），一旦条件满足，被挂起的线程又会自动<strong>被唤起</strong></p>
<p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，**我们每个程序员都必须去自己控制这些细节，尤其还要兼顾    **效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="阻塞队列的类图"><a href="#阻塞队列的类图" class="headerlink" title="阻塞队列的类图"></a>阻塞队列的类图</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172907.png" alt="image-20220109155943058"></p>
<p>下面三个最常用</p>
<ul>
<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</li>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172913.png" alt="image-20220109084253324"></p>
<h2 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172920.png" alt="image-20220109160455125"></p>
<table>
<thead>
<tr>
<th>抛出异常</th>
<th>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</th>
</tr>
</thead>
<tbody><tr>
<td>特殊值</td>
<td>插入方法，成功ture失败false<br/>移除方法，成功返回出队列的元素，队列里没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出<br/>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h2 id="阻塞队列代码"><a href="#阻塞队列代码" class="headerlink" title="阻塞队列代码"></a>阻塞队列代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/09    8:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 队列：先进先出，FIFO，就相当于食堂排队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 抛出异常</span></span><br><span class="line"><span class="comment">         * add:添加方法</span></span><br><span class="line"><span class="comment">         * remove：移除方法</span></span><br><span class="line"><span class="comment">         * element：检查方法， element是返回队首的元素，如果队列没有元素就返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add方法是添加元素</span></span><br><span class="line"> <span class="comment">/*       System.out.println(queue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(queue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(queue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">        // 队列满了</span></span><br><span class="line"><span class="comment">//        queue.add(&quot;d&quot;);  // Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;========================================================================================&quot;);</span></span><br><span class="line"><span class="comment">        // element是返回队首的元素</span></span><br><span class="line"><span class="comment">        System.out.println(queue.element());</span></span><br><span class="line"><span class="comment">        // remove是移除元素</span></span><br><span class="line"><span class="comment">        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.remove());</span></span><br><span class="line"><span class="comment">        // 队列为空了</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.remove()); // Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;========================================================================================&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 特殊值</span></span><br><span class="line"><span class="comment">         * offer：插入成功返回true</span></span><br><span class="line"><span class="comment">         * poll：移除操作(移除队首的操作)，成功返回出队列的元素，队列里面没有就返回null</span></span><br><span class="line"><span class="comment">         * peek：检索但不删除由此queue表示的队列的头部（换句话说，该deque的第一个元素），</span></span><br><span class="line"><span class="comment">         * 如果此deque为空，则返回 null 。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println(queue.offer(&quot;aa&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(queue.offer(&quot;bb&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(queue.offer(&quot;cc&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.offer(&quot;cc&quot;)); // false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(queue.peek());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.peek());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.peek());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(queue.poll()); // null</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;========================================================================================&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*      queue.put(&quot;aa&quot;);</span></span><br><span class="line"><span class="comment">        queue.put(&quot;aa&quot;);</span></span><br><span class="line"><span class="comment">        queue.put(&quot;aa&quot;);</span></span><br><span class="line"><span class="comment">//        queue.put(&quot;aa&quot;);    //这里本来只能放三个元素，但是想要添加四个元素，所以，最后的元素就会被阻塞，就相当于一直在等待消费去消费</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        queue.take();</span></span><br><span class="line"><span class="comment">        queue.take();</span></span><br><span class="line"><span class="comment">        queue.take();</span></span><br><span class="line"><span class="comment">//        queue.take();   // 这队列里面本来只有三个元素，这里要获取第四个，所以就得一直等着，等生产者生产第四个</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.take());</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        <span class="comment">// 这个是等三秒，三秒要是还没有蛋糕就走了，过时不候</span></span><br><span class="line">        System.out.println(queue.offer(<span class="string">&quot;aa&quot;</span>, <span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h2><ul>
<li><strong>方法</strong>，必须由其所在类或对象调用才有意义。若方法含有参数： <ul>
<li><strong>形参</strong>：方法声明时的参数 </li>
<li><strong>实参</strong>：方法调用时实际传给形参的参数值</li>
</ul>
</li>
</ul>
<p>Java的实参值如何传入方法呢？ Java里方法的参数传递方式只有一种：<strong>值传递。 即将实际参数值的副本 （复制品）传入方法内，而参数本身不受影响。</strong> </p>
<p>形参是<strong>基本数据类型</strong>：将实参基本数据类型变量的<strong>“数据值”</strong>传递给形参 </p>
<p>形参是<strong>引用数据类型</strong>：将实参引用数据类型变量的<strong>“地址值”</strong>传递给形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/09    10:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransferValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.setName(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;~~~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestTransferValue transferValue = <span class="keyword">new</span> TestTransferValue();</span><br><span class="line">        <span class="comment">//  在一个方法里面，基本类型只传复印件，原件不动</span></span><br><span class="line">        <span class="keyword">int</span> age =<span class="number">20</span>;</span><br><span class="line">        transferValue.changeValue1(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个自定义类型Person穿的是引用类型</span></span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;zsf&quot;</span>);</span><br><span class="line">        transferValue.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName -------------&gt;&quot;</span> + person.getName());</span><br><span class="line"></span><br><span class="line">        String str= <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        transferValue.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<p>Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172926.png" alt="image-20220109174059210"></p>
<h1 id="ThreadPool线程池"><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1><hr>
<h2 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h2><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>
<p><strong>线程池的优势：</strong><br>线程池做的工作只要是控制运行的线程数量，<strong>处理过程中将任务放入队列，</strong>然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量，超出数量的线程排队等候，</strong>等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>**它的主要特点为：线程复用;控制最大并发数;管理线程。                                                                       **</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="线程池如何使用"><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h2><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了<code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code>这几个类</p>
<p> <img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172930.png" alt="image-20220109172347156"></p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/09    14:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =================第一种=================</span></span><br><span class="line">        <span class="comment">// Executors是线程池的工具类</span></span><br><span class="line">        <span class="comment">// newFixedThreadPool创建	一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</span></span><br><span class="line">        <span class="comment">// 创建线程池，设置办理窗口(初始线程)为5</span></span><br><span class="line">        <span class="comment">// 一池5线程，类似一个银行有5个受理窗口</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =================第二种=================</span></span><br><span class="line">        <span class="comment">// 线程池只有一个工作线程，类似于，银行只有一个办理窗口</span></span><br><span class="line">        <span class="comment">//  ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">// 一池N线程，一个池子里面有多个线程，类似于银行有N个受理窗口，这和每个线程执行的事件有关</span></span><br><span class="line">        <span class="comment">// 创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =================第三种=================</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理完成&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 暂停1秒钟，模拟办理时候的耗时</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>其实他底层都是创建一个<strong>ThreadPoolExecutor</strong>，然后传入不同类型的参数，调用不同的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters and default thread factory and rejected execution handler.</span></span><br><span class="line"><span class="comment"> * It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125; factory</span></span><br><span class="line"><span class="comment"> * methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109181909648.png" alt="image-20220109181909648"></p>
<h2 id="线程池几个重要参数"><a href="#线程池几个重要参数" class="headerlink" title="线程池几个重要参数"></a>线程池几个重要参数</h2><ol>
<li><p><code>corePoolSize</code>：线程池中的常驻核心线程数</p>
</li>
<li><p><code>maximumPoolSize</code>：线程池中能够容纳同时<br>执行的最大线程数，此值必须大于等于1</p>
</li>
<li><p><code>keepAliveTime</code>：多余的空闲线程的存活时间<br>当前池中线程数量超过corePoolSize时，当空闲时间<br>达到<code>keepAliveTime</code>时，多余线程会被销毁直到<br>只剩下<code>corePoolSize</code>个线程为止</p>
</li>
<li><p><code>unit：</code> <code>keepAliveTime</code>的单位 </p>
</li>
<li><p><code>workQueue</code>：任务队列，被提交但尚未被执行的任务</p>
</li>
<li><p><code>threadFactory</code>：表示生成线程池中工作线程的线程工厂，<br>用于创建线程，一般默认的即可</p>
</li>
<li><p><code>handler</code>：拒绝策略，表示当队列满了，并且工作线程大于<br>等于线程池的最大线程数（<code>maximumPoolSize</code>）时如何来拒绝<br>请求执行的runnable的策略</p>
</li>
</ol>
<h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><p>步骤是下面的1到4</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172935.png" alt="image-20220109183737541"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172938.png" alt="image-20220109203111160"></p>
<p>下图的<code>corePoolSize</code>为2，<code>maximumPoolSize</code>为5，当一开始有两个客户（1，2线程）来办理业务的时候，两个今日窗口正好能够处理。当后面3，4，5又来时，<code>BlockingQueue</code>也正好满了（为5）；然后大堂经理就叫其他的员工来值班扩大到<code>maximumPoolSize</code>（也就是扩容到最大的线程数5）。当后面又进来三个线程（6，7，8）的时候就进入候客区（<code>BlockingQueue</code>），候客区也满了。但此时如果进来了另一个客户（9），就会告知本银行今天的业务繁忙，请到其他网点去办理业务（这里是按照拒绝策略处理）。如果设置了<code>keepAliveTime</code>的话，新增的扩容的员工，在处理完所有的业务之后，过<code>keepAliveTime</code>这么久时间，就会恢复到原来的<code>corePoolSize</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109195333905.png" alt="image-20220109195333905"></p>
<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109201025539.png" alt="image-20220109201025539"></p>
<p> <strong>以下重要：</strong></p>
<ol>
<li><p>在创建了线程池后，开始等待请求。</p>
</li>
<li><p>当调用**execute()**方法添加一个请求任务时，线程池会做出如下判断：</p>
<pre><code>  2.2如果正在运行的线程数量小于**corePoolSize**，那么马上创建线程运行这个任务；

  2.2如果正在运行的线程数量大于或等于**corePoolSize**，那么将这个任务放入队列；

  2.3如果这个时候队列满了且正在运行的线程数量还小于**maximumPoolSize**，那么还是要创建非核心线程立刻运行这个任务；

  2.4如果队列满了且正在运行的线程数量大于或等于**maximumPoolSize**，那么线程池会启动饱和拒绝策略来执行。
</code></pre>
</li>
</ol>
<p>3当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
<p>4当一个线程无事可做超过一定的时间（<strong>keepAliveTime</strong>）时，线程会判断：</p>
<p>如果当前运行的线程数大于<strong>corePoolSize</strong>，那么这个线程就被停掉。</p>
<p>所以线程池的所有任务完成后，它最终会收缩到<strong>corePoolSize</strong>的大小。</p>
<h2 id="线程池用哪个？生产中如设置合理参数"><a href="#线程池用哪个？生产中如设置合理参数" class="headerlink" title="线程池用哪个？生产中如设置合理参数"></a>线程池用哪个？生产中如设置合理参数</h2><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><strong>等待队列已经排满了</strong>，再也塞不下新任务了</p>
<p>同时，<strong>线程池中的max线程也达到了</strong>，无法继续为新任务服务。</p>
<p>这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<h4 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h4><ul>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不<br>会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中<br>尝试再次提交当前任务。</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</li>
</ul>
<h3 id="以上内置拒绝策略均实现了RejectedExecutionHandle接口"><a href="#以上内置拒绝策略均实现了RejectedExecutionHandle接口" class="headerlink" title="以上内置拒绝策略均实现了RejectedExecutionHandle接口"></a>以上内置拒绝策略均实现了RejectedExecutionHandle接口</h3><h2 id="在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多？超级大坑"><a href="#在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多？超级大坑" class="headerlink" title="在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑"></a>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</h2><ol>
<li>答案是一个都不用，我们工作中只能使用自定义的</li>
<li>Executors中JDK已经给你提供了，为什么不用？</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172949.png" alt="image-20220109184859628"></p>
<h1 id="Java8之流式计算复习"><a href="#Java8之流式计算复习" class="headerlink" title="Java8之流式计算复习"></a>Java8之流式计算复习</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="java-util-function"><a href="#java-util-function" class="headerlink" title="java.util.function"></a>java.util.function</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172952.png" alt="image-20220111120945026"></p>
<h3 id="java内置核心四大函数式接口"><a href="#java内置核心四大函数式接口" class="headerlink" title="java内置核心四大函数式接口"></a>java内置核心四大函数式接口</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172954.png" alt="image-20220111121004428"></p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//R apply(T t);函数型接口，一个参数，一个返回值</span></span><br><span class="line">Function&lt;String,Integer&gt; function = t -&gt;&#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean test(T t);断定型接口，一个参数，返回boolean</span></span><br><span class="line">Predicate&lt;String&gt; predicate = t-&gt;&#123;<span class="keyword">return</span> t.startsWith(<span class="string">&quot;a&quot;</span>);&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// void accept(T t);消费型接口，一个参数，没有返回值</span></span><br><span class="line">Consumer&lt;String&gt; consumer = t-&gt;&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;javaXXXX&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//T get(); 供给型接口，无参数，有返回值</span></span><br><span class="line">Supplier&lt;String&gt; supplier =()-&gt;&#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br><strong>“集合讲的是数据，流讲的是计算！”</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ol>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><ol>
<li>创建一个Stream：一个数据源（数组、集合）</li>
<li>中间操作：一个中间操作，处理数据源数据</li>
<li>终止操作：一个终止操作，执行中间操作链，产生结果</li>
</ol>
<p>过程：</p>
<p><strong>源头=&gt;中间流水线=&gt;结果</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/10    13:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (lambda表达式的几个步骤 ：</span></span><br><span class="line"><span class="comment"> *1 、 拷贝小括号 ( 如果只有一个参数的话, 可以省略参数类型和括号)</span></span><br><span class="line"><span class="comment"> *          2、写死右箭头</span></span><br><span class="line"><span class="comment"> *          3/落地大括号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 支持链式调用</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式编程 +   流式计算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目:请按照给出数据，找出同时满足以下条件的用户,也即以下条件全部满足</span></span><br><span class="line"><span class="comment"> * 偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> * 只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,  <span class="string">&quot;a&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>, <span class="string">&quot;b&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>, <span class="string">&quot;c&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>, <span class="string">&quot;d&quot;</span>, <span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>, <span class="string">&quot;e&quot;</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数组转换成list集合</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.stream().filter(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 过滤掉为id为偶数的</span></span><br><span class="line">            <span class="keyword">return</span> user.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 过滤年龄大于24的</span></span><br><span class="line">            <span class="keyword">return</span> user.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">            <span class="comment">// map是映射</span></span><br><span class="line">            <span class="comment">// sorted是stream的排序，默认是升序</span></span><br><span class="line">        &#125;).map(user -&gt; user.getUserName().toUpperCase()).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 降序排列</span></span><br><span class="line">            <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">            <span class="comment">// limit和MySQL中的类似，限制个数.forEach进行遍历，然后加</span></span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        list.stream().sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        for (User user : list) &#123;</span></span><br><span class="line"><span class="comment">            if (user.getId() % 2 == 0 &amp;&amp; user.getAge() &gt; 24) &#123;</span></span><br><span class="line"><span class="comment">                user.setUserName(user.getUserName().toUpperCase());</span></span><br><span class="line"><span class="comment">                users.add(user);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="分支合并框架"><a href="#分支合并框架" class="headerlink" title="分支合并框架"></a>分支合并框架</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173002.png" alt="image-20220111121606583"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173004.png" alt="image-20220111121613341"></p>
<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>和Exector相关，以及线程池有关</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173007.png" alt="image-20220111134910595"></p>
<p>分支合并池    类比=&gt;   线程池</p>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p> <img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173010.png" alt="image-20220111134928706"></p>
<p>ForkJoinTask    类比=&gt;   FutureTask</p>
<h3 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173012.png" alt="image-20220111135645753"></p>
<p>递归任务：继承后可以实现递归(自己调自己)调用的任务</p>
<p>伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">  Fibonacci(<span class="keyword">int</span> n) &#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">  <span class="function">Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">    Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    f1.fork();</span><br><span class="line">    Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ForkJoin的使用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/10    22:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> * ForkJoin框架</span></span><br><span class="line"><span class="comment"> * 用到了分治算法</span></span><br><span class="line"><span class="comment"> * 基础回顾：</span></span><br><span class="line"><span class="comment"> * 抽象类被继承</span></span><br><span class="line"><span class="comment"> * 接口被实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 当数值差小于等于10的时候就直接进行累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 这里是递归</span></span><br><span class="line">            <span class="comment">// 第一个任务从begin加到中间</span></span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">            <span class="comment">// 第二个任务从中间加到最末尾</span></span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 回来调用compute</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            <span class="comment">// 当 is done返回计算结果。</span></span><br><span class="line">            result = task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建forkjoin池</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算任务</span></span><br><span class="line">            ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(myTask);</span><br><span class="line">            <span class="comment">// 获取计算的结果</span></span><br><span class="line">            Integer integer = task.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;integer = &quot;</span> + integer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (forkJoinPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                forkJoinPool.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="异步回调CompletableFuture"><a href="#异步回调CompletableFuture" class="headerlink" title="异步回调CompletableFuture"></a>异步回调CompletableFuture</h1><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173016.png" alt="image-20220111145007736"></p>
<p>这一段，听得挺迷的，有点类似于ajax的异步请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: pzx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/01/10    22:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 没有返回值的</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t没有返回值&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步回调，有返回值supplyAsync供给型函数式接口</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t completableFuture2&quot;</span>);</span><br><span class="line"><span class="comment">//            return 10 / 0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//  whenComplete方法返回一个新的CompletableFuture，当CompletableFuture完成时完成，</span></span><br><span class="line">        <span class="comment">//  whenComplete(</span></span><br><span class="line">        <span class="comment">//        BiConsumer&lt;? super T, ? super Throwable&gt; action)</span></span><br><span class="line">        Integer result = completableFuture2.whenComplete((a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 不出异常就走这一步</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">            <span class="comment">// 这里为null就表示没有异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            <span class="comment">//结果是异常触发此CompletableFuture的完成特殊功能的给定功能;</span></span><br><span class="line">            <span class="comment">// 否则，如果此CompletableFuture正常完成，则返回的CompletableFuture也会以相同的值正常完成。</span></span><br><span class="line">        &#125;).exceptionally(f -&gt; &#123;</span><br><span class="line">            <span class="comment">//  CompletableFuture&lt;T&gt; exceptionally(</span></span><br><span class="line">            <span class="comment">//        Function&lt;Throwable, ? extends T&gt; fn)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个是当出现异常的时候就会走这一步</span></span><br><span class="line">            System.out.println(f.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://losserlong.github.io/2022/01/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang">
      <meta itemprop="description" content="Stay Hungry,Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/16/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-16 18:18:51 / 修改时间：18:18:23" itemprop="dateCreated datePublished" datetime="2022-01-16T18:18:51+08:00">2022-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiang</p>
  <div class="site-description" itemprop="description">Stay Hungry,Stay Foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
