[{"title":"存储过程和函数","url":"/2022/03/12/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/","content":"<h1 id=\"存储过程与存储函数\"><a class=\"markdownIt-Anchor\" href=\"#存储过程与存储函数\"></a> 存储过程与存储函数</h1>\n<p>MysQL从5.0版本开始支持存储过程和函数。<code>存储过程和函数</code>能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要<code>简单地调用</code>存储过程和函数即可。阿里开发手册不推荐使用存储过程。</p>\n<h2 id=\"存储过程概述\"><a class=\"markdownIt-Anchor\" href=\"#存储过程概述\"></a> 存储过程概述</h2>\n<h2 id=\"理解\"><a class=\"markdownIt-Anchor\" href=\"#理解\"></a> 理解</h2>\n<p><strong>含义</strong>:存储过程的英文是<code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的SQL语句的封装。执行过程：<code>存储过程</code>预先存储在MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列SQL语句全部执行。</p>\n<p><strong>好处:</strong></p>\n<ul>\n<li>\n<p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力</p>\n</li>\n<li>\n<p>2、减少操作过程中的失误，提高效率</p>\n</li>\n<li>\n<p>3、减少网络传输量（客户端不需要把所有的sQL语句通过网络发给服务器)</p>\n</li>\n<li>\n<p>4、减少了SQL语句暴露在网上的风险，也提高了数据查询的安全性</p>\n</li>\n</ul>\n<p><strong>和视图、函数的对比:</strong><br />\n它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，<strong>通常不对底层数据表直接操作</strong>，<strong>而存储过程是程序化的SQL</strong>，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。<br />\n一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。<code>相较于函数</code>，<strong>存储过程</strong>是<code>没有返回值</code>的。</p>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\"></a> 分类</h2>\n<p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下:</p>\n<p>1、没有参数（无参数无返回)</p>\n<p>2、仅仅带IN类型(有参数无返回)</p>\n<p>3、仅仅带OUT类型(无参数有返回)</p>\n<p>4、既带IN又带OUT(有参数有返回)</p>\n<p>5、带INOUT(有参数有返回)</p>\n<p>注意：IN、OUT、INOUT都可以在一个存储过程中带多个</p>\n<h2 id=\"创建存储过程\"><a class=\"markdownIt-Anchor\" href=\"#创建存储过程\"></a> 创建存储过程</h2>\n<h3 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\"></a> 语法分析</h3>\n<p>语法：</p>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE　PROCEDURE sp_name (  [ IN | OUT | INOUT  参数名，参数类型])\n    [characteristic ...] \nBEGIN\n\t存储过程体\n\nEND [end_label]\n</code></pre>\n<p>类似于Java中的方法</p>\n<pre class=\"highlight\"><code class=\"java\">访问修饰符 返回值类型 方法名 (参数列表)&#123;\n    方法体;\n&#125;\n</code></pre>\n<p>说明：</p>\n<p>1、参数里面的符号的意思</p>\n<ul>\n<li><code>IN</code>：当前参数为输入参数，也就是表示入参，存储过程只是读取到这个参数的值。如果没有定义参数种类，默认就是<code>IN</code>，表示输入参数。</li>\n<li><code>OUT</code>：当前参数作为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数的返回的值了</li>\n<li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li>\n</ul>\n<p>2、形参类型可以是MySQL数据库中的任意类型</p>\n<p>3、<code>characteristic</code>表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>\n<pre class=\"highlight\"><code class=\"mysql\">  | LANGUAGE SQL\n  | [NOT] DETERMINISTIC\n  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;\n  | SQL SECURITY &#123; DEFINER | INVOKER &#125;\n  | COMMENT 'st'\n</code></pre>\n<ul>\n<li>\n<p><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>\n</li>\n<li>\n<p><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。<code>DETERMINISTIC</code>表示结果是确定的。每次执行存储过程时，相同的输入会<code>得到相同的输出</code>。<code>NOT DETERMINISTIC</code>表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，<strong>默认为NOT DETERMINISTIC。</strong></p>\n</li>\n<li>\n<p>{<code>CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA</code> }：指明子程序使用的SQL语句限制。</p>\n<ul>\n<li>CONTAINS SQL表示当前存储过程的子程序<strong>包含SQL语句</strong>，<strong>但是并不包含读写数据的SQL语句;</strong></li>\n<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句;</li>\n<li>READS SQL DATA表示当前存储过程的子程序<strong>中包含读数据的SQL语句;</strong></li>\n<li>MODIFIES SQL DATA表示当前存储过程的子程序中<strong>包含写数据的SQL语句。</strong></li>\n</ul>\n</li>\n<li>\n<p><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>\n<ul>\n<li><code>DEFINER</code>表示只有当前存储过程的<strong>创建者或者定义者</strong>才能执行当前存储过程;</li>\n<li><code>INVOKER</code>表示拥有当前存储过程的<strong>访问权限</strong>的用户能够执行当前存储过程。</li>\n<li>如果没有设置相关的值，则MysQL默认指定值为DEFINER。</li>\n</ul>\n</li>\n<li>\n<p><code>COMMENT 'string'</code>:注释信息，可以用来描述存储过程。</p>\n</li>\n</ul>\n<p>4、存储过程体中可以有多条SQL语句，如果仅仅一条SQL语句，则可以省略BEGIN和END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的SQL语句。</p>\n<pre class=\"highlight\"><code class=\"mysql\">1． BEGIN...END:\t BEGIN...END中间包含了多个语句，每个语句都以( ;）号为结束符。\n2.DECLARE:  DECLARE用来声明变量，使用的位置在于 BEGIN...END语句中间，而且需要在其他语句使用之前进行变量的声明。\n3. SET:赋值语句，用于对变量进行赋值。\n4. SELECT... INTO:把从数据表中查询的结果存放到变量中，也就是为变量赋值。\n</code></pre>\n<p>5、需要设置新的结束标签</p>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER 新的结束标记\n</code></pre>\n<p>因为MySQL默认的语句结束符号为分号’;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p>\n<p>比如:<code>&quot;DELIMITER//&quot;</code>语句的作用是将MySQL的结束符设置为//，并以<code>&quot;END//&quot;</code>结束存储过程。存储过程定义完毕之后再使用<code>&quot;DELIMITER ;&quot;</code>恢复默认结束符。<code>DELIMITER</code>也可以指定其他符号作为结束符。</p>\n<p>当使用DELIMITER命令时，应该避免使用反斜杠（’\\’)字符，因为反斜线是MySQL的转义字符。</p>\n<ul>\n<li>示例：</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER $\nCREATE PROCEDURE 存储过程名\nBEGIN\nsql语句1;\nsql语句2;\nEND  $\n</code></pre>\n<h3 id=\"代码举例\"><a class=\"markdownIt-Anchor\" href=\"#代码举例\"></a> 代码举例</h3>\n<ul>\n<li>示例：这里使用$来作为结束符创建一个存储过程select_all_data，查看employees表的所有数据</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER $\nCREATE PROCEDURE select_all_data()\nBEGIN\nSELECT * FROM employees;\nEND  $;\n</code></pre>\n<ul>\n<li>调用存储过程</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\"># 2.存储过程的调用\nCALL select_all_data();\n</code></pre>\n<h3 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\"></a> 题目</h3>\n<h4 id=\"类型一无参数无返回值\"><a class=\"markdownIt-Anchor\" href=\"#类型一无参数无返回值\"></a> 类型一：无参数无返回值</h4>\n<ul>\n<li>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER $\nCREATE  PROCEDURE avg_employee_salary()\nBEGIN\n\nSELECT AVG(salary) FROM employees;\n\nEND  $;\n\nCALL avg_employee_salary();\n\n\n</code></pre>\n<ul>\n<li>举例3:创建存储过程show_max_salary()，用来查看&quot;emps&quot;表的最高薪资值。</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER //\nCREATE PROCEDURE show_max_salary()\nBEGIN\nSELECT MAX(salary) FROM employees;\n\nEND // ; \n\nCALL show_max_salary();\n\n</code></pre>\n<h4 id=\"类型2带out\"><a class=\"markdownIt-Anchor\" href=\"#类型2带out\"></a> 类型2:带OUT</h4>\n<ul>\n<li>举例4:创建存储过程show_min_salary()，查看&quot;emps&quot;表的最低薪资值。并将最低薪资<strong>通过OUT参数&quot;ms&quot;&quot;输出</strong></li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER //\nCREATE PROCEDURE show_min_salary(OUT ms DOUBLE)\nBEGIN\nSELECT MIN(salary) INTO ms \nFROM employees;\n\nEND //;\n\n# 调用\nCALL show_min_salary(@ms);\n\n# 查看变量值\nSELECT @ms;\n</code></pre>\n<h4 id=\"类型2带in\"><a class=\"markdownIt-Anchor\" href=\"#类型2带in\"></a> 类型2:带IN</h4>\n<ul>\n<li>举例5:创建存储过程show_someone_salary()，查看&quot;emps&quot;表的某个员工的薪资，并用IN参数empname输入员工姓名。</li>\n</ul>\n<pre class=\"highlight\"><code class=\"java\">DROP PROCEDURE  IF EXISTS  show_someone_salary;\n\nDELIMITER <span class=\"hljs-comment\">// </span>\n<span class=\"hljs-function\">CREATE PROCEDURE <span class=\"hljs-title\">show_someone_salary</span><span class=\"hljs-params\">(IN empname  VARCHAR(<span class=\"hljs-number\">20</span>)</span>)\nBEGIN\nSELECT salary \nFROM employees\nWHERE last_name</span>=empname;\nEND <span class=\"hljs-comment\">//;</span>\n# 调用方式<span class=\"hljs-number\">1</span>，使用常量\n<span class=\"hljs-function\">CALL <span class=\"hljs-title\">show_someone_salary</span><span class=\"hljs-params\">(<span class=\"hljs-string\">'King'</span>)</span></span>;\n\n\n# 调用方式<span class=\"hljs-number\">2</span>，使用变量\nSET <span class=\"hljs-meta\">@empname</span> :=<span class=\"hljs-string\">'Kochhar'</span>;\n<span class=\"hljs-function\">CALL <span class=\"hljs-title\">show_someone_salary</span><span class=\"hljs-params\">(@empname)</span></span>;\n       \n</code></pre>\n<h4 id=\"带in和out的\"><a class=\"markdownIt-Anchor\" href=\"#带in和out的\"></a> 带in和out的</h4>\n<p>#举例6:创建存储过程show_someone_salary2()，查看&quot;emps“表的某个员工的薪资，<br />\n#并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p>\n<p>带IN和OUT的就表示既有输入又有输出</p>\n<pre class=\"highlight\"><code class=\"mysql\">DROP PROCEDURE IF EXISTS show_someone_salary2;\nDELIMITER //\nCREATE PROCEDURE show_someone_salary2\n(IN empname VARCHAR(20),OUT empsalary DOUBLE(8,2))\nBEGIN\nSELECT salary INTO empsalary\nFROM `employees`\nWHERE last_name=empname;\n\nEND //;\n</code></pre>\n<h4 id=\"带inout的\"><a class=\"markdownIt-Anchor\" href=\"#带inout的\"></a> 带INOUT的</h4>\n<p>举例7:创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数&quot;empname&quot;输入员工姓名输出领导的姓名。</p>\n<pre class=\"highlight\"><code class=\"mysql\">DELIMITER $\nCREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(25))\nBEGIN\nSELECT  e2.last_name INTO empname\nFROM `employees` e1, `employees` e2\nWHERE e1.manager_id=e2.employee_id\nAND e1.last_name=empname;\nEND $\n\nSET @empname:='Whalen';\nCALL show_mgr_name(@empname)\nSELECT @empname;\n</code></pre>\n<h1 id=\"存储函数的使用\"><a class=\"markdownIt-Anchor\" href=\"#存储函数的使用\"></a> 存储函数的使用</h1>\n<p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p>\n<h2 id=\"语法分析-2\"><a class=\"markdownIt-Anchor\" href=\"#语法分析-2\"></a> 语法分析</h2>\n<p>学过的函数：LENGTH、SUBSTR、CONCAT等</p>\n<p>语法格式：</p>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE FUNCTION 函数名（参数名，参数类型，...）\nRETURNS 返回值类型\n[characteristics ...]\nBEGIN\n函数体 \t#函数体中肯定有RETURN 语句\nEND\n</code></pre>\n<p>说明：</p>\n<p>1、参数列表：指定参数IN、OUT、INOUT只对PROCEDURE（存储过程）是合法的，FUNCTION中<code>总是默认为IN参数</code></p>\n<p>2、RETURNS types语句表示函数返回值类型；</p>\n<p>RETURNS字句只能对FUNCTION做指定，对函数而言是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句</p>\n<p>3、characteristic创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p>\n<p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END.</p>\n<h2 id=\"举例\"><a class=\"markdownIt-Anchor\" href=\"#举例\"></a> 举例</h2>\n<h3 id=\"创建存储函数名称为email_by_name\"><a class=\"markdownIt-Anchor\" href=\"#创建存储函数名称为email_by_name\"></a> 创建存储函数，名称为email_by_name()</h3>\n<pre class=\"highlight\"><code class=\"mysql\"># 举例1：创建存储函数，名称为email_by_name()，参数定义为空，\n#该函数查询Abel的email，并返回，数据类型为字符串型。\n# 创建函数前\t执行此语句，保证函数的创建会成功\nSET GLOBAL log_bin_trust_function_creators=1;\n\nDELIMITER //\nCREATE FUNCTION email_by_name()\nRETURNS VARCHAR(25)\nDETERMINISTIC\nCONTAINS SQL\nREADS SQL DATA\nBEGIN\nRETURN (SELECT email FROM employees WHERE last_name='Abel');\nEND// \n\nSELECT email_by_name();\n\n</code></pre>\n<h3 id=\"举例2创建存储函数名称为email_by_id\"><a class=\"markdownIt-Anchor\" href=\"#举例2创建存储函数名称为email_by_id\"></a> 举例2：创建存储函数，名称为email_by_id()</h3>\n<pre class=\"highlight\"><code class=\"mysql\"># 举例2：创建存储函数，名称为email_by_id()\nSET GLOBAL log_bin_trust_function_creators=1;\n\nDELIMITER //\nCREATE FUNCTION email_by_id(empid INT)\nRETURNS VARCHAR(25)\nDETERMINISTIC\nCONTAINS SQL\nREADS SQL DATA\nBEGIN\nRETURN (SELECT email FROM employees WHERE employee_id=empid);\nEND// \n\nSET @emp_id=102;\nSELECT email_by_id(@emp_id);\n\n</code></pre>\n<h2 id=\"存储过程和存储过程的比较\"><a class=\"markdownIt-Anchor\" href=\"#存储过程和存储过程的比较\"></a> 存储过程和存储过程的比较</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>关键字</th>\n<th>调用语法</th>\n<th>返回值</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储过程</td>\n<td>PROCEDURE</td>\n<td>CALL 存储过程()</td>\n<td>理解为有0个或者多个</td>\n<td>一般用于更新</td>\n</tr>\n<tr>\n<td>存储函数</td>\n<td>FUNCTION</td>\n<td>SELECT  函数()</td>\n<td>只能是一个</td>\n<td>一般用于查询结果为一个值并返回时</td>\n</tr>\n</tbody>\n</table>\n<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>\n","categories":["mysql"],"tags":["存储过程和函数"]},{"title":"视图学习","url":"/2022/03/11/%E8%A7%86%E5%9B%BE%E5%AD%A6%E4%B9%A0/","content":"<h1 id=\"视图\"><a class=\"markdownIt-Anchor\" href=\"#视图\"></a> 视图</h1>\n<h2 id=\"为什么使用视图\"><a class=\"markdownIt-Anchor\" href=\"#为什么使用视图\"></a> 为什么使用视图</h2>\n<p>**视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。**比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。<br />\n刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220310132740.png\" alt=\"image-20220310132740728\" /></p>\n<h2 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\"></a> 基本概念</h2>\n<p>视图(VIEW)：一个或者多个数据表里的数据的逻辑显示，视图并不存储数据（一般用来隐藏敏感数据，例如：工资，银行卡等）</p>\n<ul>\n<li>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是SQL中的一个重要概念。</li>\n<li><strong>视图建立在已有表的基础上</strong>，视图赖以建立的这些表称为<strong>基表</strong>。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220310131532.png\" alt=\"image-20220310131524928\" /></p>\n<ul>\n<li>\n<p><code>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化</code>，反之亦然。</p>\n</li>\n<li>\n<p>向视图提供数据内容的语句为SELECT语句,可以将视图理解为<strong>存储起来的SELECT语句</strong></p>\n<ul>\n<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化;反之亦然。</li>\n</ul>\n</li>\n<li>\n<p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>\n</li>\n<li>\n<p>视图的优点：简化查询；控制数据的访问</p>\n</li>\n</ul>\n<h2 id=\"创建视图\"><a class=\"markdownIt-Anchor\" href=\"#创建视图\"></a> 创建视图</h2>\n<ul>\n<li>在CREATE VIEW语句中嵌入子查询</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE [OR REPLACE] \n[ALGORITHM = &#123;UNDEFINED MERGE |TEMPTABLE&#125;]  (这里是算法)\nVIEW view_name [(字段列表)]\nAS 查询语句\n[WITH [CASCADED |LOCAL ] CHECK OPTION]\n</code></pre>\n<ul>\n<li>精简版</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE \nVIEW view_name [(字段列表)]\nAS 查询语句\n</code></pre>\n<h3 id=\"创建单表视图\"><a class=\"markdownIt-Anchor\" href=\"#创建单表视图\"></a> 创建单表视图</h3>\n<ul>\n<li>针对单表创建视图</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\"># 针对单表创建视图\n\n\nCREATE VIEW emps_view\nAS SELECT * FROM emps;\n\nSELECT * FROM emps_view;\n\n</code></pre>\n<ul>\n<li>确定视图中字段名的方式1</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE VIEW emps_view2\n# 查询语句中字段的别名会作为视图的字段名\nAS SELECT employee_id emp_id,last_name lname,salary  \nFROM emps\nWHERE salary&gt;8000;\n</code></pre>\n<ul>\n<li>确定视图中字段名的方式2</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\"># 小括号内字段的个数与SELECT中字段的个数相同\nCREATE VIEW emps_view3 (emp_id,NAME,monthly_sal)\nAS SELECT employee_id emp_id,last_name lname,salary \nFROM emps\nWHERE salary&gt;8000;\n\nSELECT * FROM emps_view3;\t\n\n</code></pre>\n<ul>\n<li>情况二：视图中的字段在基表中可能没有对应的字段（用了函数）</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">CREATE VIEW emp_sal\nAS \nSELECT department_id,AVG(salary) avg_sal\nFROM emps\nWHERE department_id IS NOT NULL\nGROUP BY department_id;\n\nSELECT * FROM emp_sal;\n</code></pre>\n<h3 id=\"针对多表创建联合视图\"><a class=\"markdownIt-Anchor\" href=\"#针对多表创建联合视图\"></a> 针对多表（创建联合视图）</h3>\n<pre class=\"highlight\"><code class=\"mysql\">SELECT e.`employee_id`,e.`department_id`,d.`department_name`\nFROM `depts` d JOIN  `emps` e\nON d.`department_id`=e.`department_id`;\n</code></pre>\n<ul>\n<li>利用视图对数据进行格式化</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysq\">CREATE VIEW vu_emp_dept1\nAS \nSELECT CONCAT(e.last_name,'(',d.department_name,')') emp_info\nFROM `emps` e JOIN\n`depts` d\nON e.department_id=d.department_id;\n\nSELECT * FROM vu_emp_dept1;\n</code></pre>\n<h3 id=\"基于视图创建视图\"><a class=\"markdownIt-Anchor\" href=\"#基于视图创建视图\"></a> 基于视图创建视图</h3>\n<pre class=\"highlight\"><code class=\"mysql\"># 2.3基于视图创建视图\nCREATE VIEW vu_emp4\nAS SELECT first_name , last_name\nFROM emps_view;\n\nSELECT * FROM vu_emp4;\n</code></pre>\n<h2 id=\"查看视图其实和显示表差不多\"><a class=\"markdownIt-Anchor\" href=\"#查看视图其实和显示表差不多\"></a> 查看视图（其实和显示表差不多）</h2>\n<ul>\n<li>语法一：查看数据库的表对象、视图对象</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">SHOW TABLES;\n</code></pre>\n<ul>\n<li>语法二：查看试视图的结构</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">DESC / DESCRIBE 视图名称;\n</code></pre>\n<ul>\n<li>语法三：查看视图的属性信息</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">#查看视图的属性信息\n\nSHOW TABLE STATUS LIKE '视图名称';\n</code></pre>\n<p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他信息为null，说明这是一个虚表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220310183242.png\" alt=\"image-20220310183242006\" /></p>\n<ul>\n<li>语法四：查看视图的详细定义信息</li>\n</ul>\n<pre class=\"highlight\"><code class=\"mysql\">SHOW CREATE VIEW  vu_emp4; \t\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220310183347.png\" alt=\"image-20220310183347480\" /></p>\n<h2 id=\"视图的dml操作\"><a class=\"markdownIt-Anchor\" href=\"#视图的dml操作\"></a> 视图的DML操作</h2>\n<p>视图的DML操作和对表的操作几乎没有什么差别，就不再赘述了。</p>\n","categories":["mysql"],"tags":["视图"]},{"title":"ssm简单笔记","url":"/2022/01/22/ssm%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"ssm\"><a class=\"markdownIt-Anchor\" href=\"#ssm\"></a> SSM</h1>\n<p>Javaweb的三大组件：Servlet，Filter，Listener；</p>\n<h2 id=\"复习javaweb\"><a class=\"markdownIt-Anchor\" href=\"#复习javaweb\"></a> 复习JavaWeb</h2>\n<h3 id=\"filter流程\"><a class=\"markdownIt-Anchor\" href=\"#filter流程\"></a> filter流程</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210806085801.png\" alt=\"image-20210806085748742\" /></p>\n<span id=\"more\"></span>\n<h3 id=\"listener\"><a class=\"markdownIt-Anchor\" href=\"#listener\"></a> Listener</h3>\n<p>八个：ServletRequest（2）、HttpSession（2）、ServletContext（2）</p>\n<p>2：生命周期监听器，属性变化监听器</p>\n<p>4（HttpSession）：除了上面那两个外，还有额外的两个（活化钝化监听器、绑定解绑监听器）</p>\n<p>掌握的监听器：</p>\n<p>ServlertContextListener（生命周期）：监听ServletContext的创建和销毁（监听服务器的启动和停止）；服务器启动创建一个ServletContext对象，服务器停止，销毁创建的ServletContext对象；</p>\n<p><font color='red'>ServletContext:</font></p>\n<p>​\t\t\t\t1、一个web项目对应一个ServletContext，它代表web项目的信息</p>\n<p>​\t\t\t\t2、还可以作为最大的域对象在整个项目的运行期间共享数据</p>\n<p><font color='red'>监听器的使用方法：</font></p>\n<p>​\t\t\t\t1.先实现对应的监听器接口</p>\n<p>​\t\t\t\t2.去web.xml进行配置；注意：有两个Listener是JavaBean需要实现的接口，（HttpSessionActivitionListener，HttpSessionBindingListener）</p>\n<h3 id=\"ajax和json\"><a class=\"markdownIt-Anchor\" href=\"#ajax和json\"></a> AJAX和JSON</h3>\n<p>JSON:(js对象表法)是一种轻量级的数据交换格式（与xml相比较）</p>\n<p>一个复杂的js对象</p>\n<pre class=\"highlight\"><code class=\"js\">    <span class=\"hljs-keyword\">var</span> student = &#123;\n        <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"张山\"</span>,\n        <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span>,\n        <span class=\"hljs-attr\">car</span>: &#123;<span class=\"hljs-attr\">pp</span>: <span class=\"hljs-string\">\"baoma\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-string\">\"15555555555\"</span>&#125;,\n        <span class=\"hljs-attr\">infos</span>: [&#123;<span class=\"hljs-attr\">bookName</span>: <span class=\"hljs-string\">\"西游记\"</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">19</span>&#125;, <span class=\"hljs-number\">18</span>, <span class=\"hljs-literal\">true</span>]\n    &#125;;\n</code></pre>\n<p>如果服务器返回给浏览器的样子是js对象这个样子的，浏览器使用js解析就很方便；</p>\n<p>JSON</p>\n<pre class=\"highlight\"><code class=\"js\"> <span class=\"hljs-comment\">//json要求和js对象是一样的，只不过key必须是字符串</span>\n   <span class=\"hljs-comment\">//js对象在声明的时候是否加双引号是可以选择的</span>\n    <span class=\"hljs-keyword\">var</span> student2 = &#123;\n        <span class=\"hljs-string\">\"lastName\"</span>: <span class=\"hljs-string\">\"张山\"</span>,\n        <span class=\"hljs-string\">\"age\"</span>: <span class=\"hljs-number\">18</span>\n       \n    &#125;;\n    <span class=\"hljs-comment\">//JSON(js的内置对象)这个是js提供的将js对象转换成json(应该是js对象的字符串表示法)字符串</span>\n   <span class=\"hljs-keyword\">var</span> strjson= <span class=\"hljs-built_in\">JSON</span>.stringify(student2);\n   alert(<span class=\"hljs-keyword\">typeof</span> strjson);\n    alert(strjson);\n\n</code></pre>\n<p>两个重要的API：</p>\n<p>​\t\t<font color='red'>\t1、将js对象转换为JSON</font></p>\n<pre class=\"highlight\"><code class=\"js\"><span class=\"hljs-built_in\">JSON</span>.stringify(js对象)\n</code></pre>\n<p>​\t\t\t2、将JSON对象转换成js’对象</p>\n<pre class=\"highlight\"><code class=\"\">JSON.parse(JSON对象);\n</code></pre>\n<h3 id=\"ajax\"><a class=\"markdownIt-Anchor\" href=\"#ajax\"></a> AJAX</h3>\n<p>AJAX：synchronous Javascript And XML（异步JavaScript和XML）<br />\nAJAX：是一种无刷新页面与服务器的交互技术。（保持页面不刷新就能得到服务器的数据）</p>\n<p><font color='red'>原来的交互：</font></p>\n<p>1、发送请求</p>\n<p>2、服务器收到请求，调用队对应的servlet进行处理；servlet处理完成之后会有响应信息生成；</p>\n<p>3、浏览器收到了服务器响应的数据，把之前的页面清空，展示新的数据；（效果就是页面刷新）</p>\n<p>现在的交互：（XmlHttpRequest对象）</p>\n<p>1、XmlHttpRequest对象帮我们发送请求</p>\n<p>2、服务器收到请求后，调用对应的servlet进行处理；servlet处理完成会有响应信息生成；</p>\n<p>3、XmlHttpRequest对象收数据（浏览器就感受不到这个数据了；xml对象收到这个数据）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210806185957.png\" alt=\"image-20210806185956945\" /></p>\n<p><font color='red'>将fJava中的Object对象转换成Json对象的包</font></p>\n<p>代码演示：</p>\n<pre class=\"highlight\"><code class=\"JAVA\"> \t Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n        map.put(<span class=\"hljs-string\">\"lastName\"</span>,<span class=\"hljs-string\">\"zs\"</span>);\n        map.put(<span class=\"hljs-string\">\"age\"</span>,<span class=\"hljs-number\">18</span>);\n        <span class=\"hljs-comment\">//1、转成json</span>\n        Gson gson = <span class=\"hljs-keyword\">new</span> Gson();\n        String str = gson.toJson(map);\n        response.getWriter().write(str);\n</code></pre>\n<p>引入的依赖：（去maven仓库下载就可以了）</p>\n<pre class=\"highlight\"><code class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.google.code.gson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>gson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.8.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>改变了我们传统的交互反射光hi就</p>\n<p>1、发请求；</p>\n<p>2、服务器收到请求，处理请求经常要给页面携带数据。request.setAtteribute(“map”,map);转发到页面</p>\n<p>3、浏览器收到页面数据，在页面中使用el表达式获取数据；</p>\n<p>导致页面整个刷新，造成了很大的服务器负担；</p>\n<p>只让服务器返回我们需要的部分数据即可；不用返回整个页面；xhr代替浏览器来接收响应，发送请求；利用dom增删给的方式改变页面的效果；</p>\n<p><font color='red'>异步无刷新页面技术</font></p>\n<p>异步：不会阻塞浏览器</p>\n<p>同步：会阻塞浏览器；因为需要等到服务器处理完整个请求，完成响应后才能做其他事情</p>\n<p><font color='red'>什么是ajax：</font></p>\n<p>​\t\t\t\tajax就是xhr对象向服务器发送请求，并受到响应数据，利用dom增删改的方式改变页面效果</p>\n<p>Ajax中get请求和post请求的用法是一样的，只是一个发送的是get请求一个发送的是post请求，区别是get请求时将数据封装在请求的？后面，而post请求是将数据封装在了请求体中</p>\n<p>post请求封装的数据</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210807101457.png\" alt=\"image-20210807101446208\" /></p>\n<p>get请求封装数据</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210807101900.png\" alt=\"image-20210807101855937\" /></p>\n<h2 id=\"ioc和di\"><a class=\"markdownIt-Anchor\" href=\"#ioc和di\"></a> IOC和DI</h2>\n<p>IOC：（Inversion（反转） Of Control）控制反转；</p>\n<p>​\t\t控制：资源获取的方式；</p>\n<p>​\t\t\t\t\t<font color='red'>主动式</font>：(要什么资源都自己创建即可)</p>\n<pre class=\"highlight\"><code class=\"java\">BookServlet&#123;\nBookService bs= <span class=\"hljs-keyword\">new</span> BookService();\nAirPlane ap=<span class=\"hljs-keyword\">new</span> AirPlane();\n&#125;\n</code></pre>\n<p>​\t\t\t\t\t<font color='red'>被动式:</font>资源的获取不是我们自己创建，而是交给一个容器来创建和设置；</p>\n<pre class=\"highlight\"><code class=\"java\">BookService&#123;\n\tBookService bs;\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test01</span><span class=\"hljs-params\">()</span></span>&#123;\n\tbs.checkout();\n\t&#125;\n&#125;\n</code></pre>\n<p>容器：管理所有的组件（有功能的类）</p>\n<p>假设，BookServlet受容器管理，BookService也受容器管理;容器可以自动的探查出那些组件(类)需要用到另一写组件(类）﹔容器帮我们创建BookService对象，并把BookService对象赋值过去;<br />\n容器：主动的new资源变为被动的接收咨源·</p>\n<p>（容器）婚介所：主动获取变为被动接收；</p>\n<p>DI（Dependency Injection）依赖注入；</p>\n<p>​\t容器能知道哪个组件（类）运行的时候，需要另一个类（组件）；容器通过反射的形式，将容器中准备好BookService对象注入（利用反射给属性赋值）到BookServce中</p>\n<hr>\n<p>HelloWorld；（通过各种方式给容器中注册对象（类似于婚庆所的注册会员）），以前是自己new对象现在所有的对象都交给容器创建；<font color='red'>给容器中注册组件</font></p>\n<p>以后编写的流程；</p>\n<p>HelloWorld</p>\n<p>1、导包(4个jar包：spring-context、spring-core、spring-beans、spring-expression)</p>\n<pre class=\"highlight\"><code class=\"xml\">    <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-context<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>5.3.9<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>5.3.9<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-beans<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>5.3.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.logging.log4j<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>log4j-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.14.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-expression<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>5.3.9<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n\n</code></pre>\n<p>2、写配置（ioc.xml）</p>\n<pre class=\"highlight\"><code class=\"xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n       <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n       <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--    注册一个person对象，Spring会自动创建一个Person对象--&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--\n    一个bean标签可以注册一个组件（对象、类）\n    id：这个对象的唯一标识\n    class:要写的注册的组件的全类名\n    --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"person\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.pzx.spring.bean.Person\"</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--  property 标签为对象的属性赋值\n              name是用来指定属性名称，\n              value是用来指定属性值\n              --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"lastName\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"张三\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"age\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"18\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"email\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"zs@guigu.com\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">property</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"gender\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"男\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">property</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bean</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>3、测试  (<font color='red'>ClassPathXmlApplicationContext当前配置文件在ClassPath下)</font></p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;\n    <span class=\"hljs-comment\">//ApplicationContext：表示ioc容器</span>\n    <span class=\"hljs-comment\">//当前应用的xml配置文件在内路径下</span>\n    <span class=\"hljs-comment\">//ClassPathXmlApplicationContext当前配置文件在ClassPath下</span>\n    <span class=\"hljs-comment\">//根据Spring的配置文件得到ioc容器对象</span>\n    ApplicationContext ioc = <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"ioc.xml\"</span>);\n    Person person = ioc.getBean(<span class=\"hljs-string\">\"person\"</span>, Person<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    System.out.println(person);\n\n&#125;\n\n<span class=\"hljs-comment\">//结果   Person&#123;lastName='张三', age=18, gender='男', email='zs@guigu.com'&#125;</span>\n</code></pre>\n<h3 id=\"helloworld的小总结\"><a class=\"markdownIt-Anchor\" href=\"#helloworld的小总结\"></a> HelloWorld的小总结</h3>\n<p>有几个小细节：(<font color='red'>对象的创建都是通过反射来实现的</font>)</p>\n<p>1、ApplicationContext（IOC容器的接口）</p>\n<p>2、给容器注册了一个组件；我们也从容器中按照id拿到了这个组件的对象?</p>\n<ul>\n<li>组件的创建工作是容器来替我们完成的<br />\n*      Person对象是什么时候创建好的呢？<br />\n* <font color='red'>容器中对象的创建是在容器创建完成之后就已经创建好了；</font></li>\n</ul>\n<p>3、<font color='red'>同一个组件在ioc容器中是单实例的，容器启动完成就已经创建好了</font></p>\n<p>4、容器中如果没有这个组件，获取组件会报异常</p>\n<pre><code> * org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'person3' available\n</code></pre>\n<p>5、<font color='red'>ioc容器在创建这个组件对象时，(property)会利用setter方法为JavaBean的属性赋值</font></p>\n<p>6、JavaBean的属性名使用什么决定的？<font color='red'>getter/setter方法</font>，属性名是去掉set，后面那串字母首字母小写</p>\n<pre><code> * 注意不要随便该getter/setter，所有的getter/setter都要自动生成\n</code></pre>\n<h3 id=\"泛型依赖注入的原理\"><a class=\"markdownIt-Anchor\" href=\"#泛型依赖注入的原理\"></a> 泛型依赖注入的原理</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210810195822.png\" alt=\"image-20210810195813570\" /></p>\n<h3 id=\"将数组转换成集合\"><a class=\"markdownIt-Anchor\" href=\"#将数组转换成集合\"></a> 将数组转换成集合</h3>\n<pre class=\"highlight\"><code class=\"java\">Arrays.asList(数组名)\n</code></pre>\n<h2 id=\"aop\"><a class=\"markdownIt-Anchor\" href=\"#aop\"></a> AOP</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220122221334.png\" alt=\"image-20210812165605661\" /></p>\n<h3 id=\"如何将spring中的一个类定义为一个切面类\"><a class=\"markdownIt-Anchor\" href=\"#如何将spring中的一个类定义为一个切面类\"></a> 如何将Spring中的一个类定义为一个切面类</h3>\n<p>将Spring中的一个类定义为切面类</p>\n<p>​\t\t\t\t\t在类上加上<font color='red'>@Aspect </font>和<font color='red'> @Component</font>这两个注解<br />\n​\t\t\t\t\t其中@Aspect的作用是将这个类<font color='red'>声明为一个切面类</font><br />\n​\t\t\t\t\t@Component这个注解的作用是表示<font color='red'>将这个类注入到IOC容器中</font></p>\n<h3 id=\"springaop五大通知注解\"><a class=\"markdownIt-Anchor\" href=\"#springaop五大通知注解\"></a> SpringAOP五大通知注解</h3>\n<p>在以下方法上面加上这些注解之后，<font color='red'>还得在注解里面加上execution()</font></p>\n<ul>\n<li>\n<p><font color='red'>@Before</font>：在目标方法执行之前运行                     前置通知</p>\n</li>\n<li>\n<p><font color='red'>@After</font>：在目标方法执行完成之后运行                   后置通知</p>\n</li>\n<li>\n<p><font color='red'> @AfterReturning</font>：在目标方法正常返回后               返回通知      这个注解里面可能还要加上</p>\n<pre class=\"highlight\"><code class=\"java\"> <span class=\"hljs-meta\">@AfterReturning</span>(value = <span class=\"hljs-string\">\"hahaMyPoint()\"</span> ,returning=<span class=\"hljs-string\">\"result\"</span>)\n<span class=\"hljs-meta\">@AfterReturning</span> 这个注解里面可能还要加上returning的值用来表明返回的执行结果\n</code></pre>\n</li>\n<li>\n<p><font color='red'>@AfterThrowing</font>：在目标方法抛出异常后执行          异常通知</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-meta\">@AfterThrowing</span>(value = <span class=\"hljs-string\">\"hahaMyPoint()\"</span>,throwing=<span class=\"hljs-string\">\"exception\"</span>)\n这个注解也有可能要加上throwing，用来表示返回的异常信息\n</code></pre>\n</li>\n</ul>\n<p><font color='orange'>代码演示</font></p>\n<pre class=\"highlight\"><code class=\"java\">    <span class=\"hljs-comment\">/**\n     * 细节四：我们可以在通知方法运行的时候，拿到目标方法的详细信息学；\n     * 1）只需要为通知方法的参数列表上写一个参数：\n     *              JoinPoint joinPoint:封装了目标方法的详细信息\n     *\n     * 2)、告诉Spring哪个参数是用来接收异常的\n     *\n     *\n     * 3）、Exception exception：指定通知方法可以接收哪些异常（一般都是往大的方面写）\n     *\n     * 有点像ajax请求\n     * ajax.post(url,function(abc)&#123;\n     * alert(abc);\n     * &#125;)\n     *\n     */</span>\n    <span class=\"hljs-comment\">//想在目标方法出现异常后执行</span>\n<span class=\"hljs-comment\">//    @AfterThrowing(value = \"execution(public int com.pzx2.impl.MyMathCalculator.*(int ,int ))\",throwing=\"exception\")</span>\n    <span class=\"hljs-meta\">@AfterThrowing</span>(value = <span class=\"hljs-string\">\"hahaMyPoint()\"</span>,throwing=<span class=\"hljs-string\">\"exception\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">logException</span><span class=\"hljs-params\">(JoinPoint joinPoint , Exception exception)</span> </span>&#123;\n\n        Signature signature = joinPoint.getSignature();\n        String name = signature.getName();\n        System.out.println(<span class=\"hljs-string\">\"[LogUtils-异常]【\"</span>+name+<span class=\"hljs-string\">\"】方法出现异常了，异常信息是\"</span>+exception+ <span class=\"hljs-string\">\":已经通知测试小组进行排查\"</span>);\n\n    &#125;\n</code></pre>\n<ul>\n<li><font color='red'>@Around:环绕  </font>  (这个功能最强大)                                                       环绕通知</li>\n</ul>\n<p><font color='red'>四个通知方法的执行顺序</font></p>\n<pre class=\"highlight\"><code class=\"java\"> <span class=\"hljs-keyword\">try</span> &#123;\n       <span class=\"hljs-meta\">@Before</span>\n       method.invoke(obj,args);\n       <span class=\"hljs-meta\">@AfterReturning</span>\n            &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            <span class=\"hljs-meta\">@AfterThrowing</span>\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n        <span class=\"hljs-meta\">@After</span>\n        &#125;\n</code></pre>\n<h3 id=\"切入点表达式的几种常见的写法\"><a class=\"markdownIt-Anchor\" href=\"#切入点表达式的几种常见的写法\"></a> 切入点表达式的几种常见的写法</h3>\n<pre class=\"highlight\"><code class=\"java\">切入点表达式的固定写法\n固定格式：execution(访问权限符 返回值类型  方法的全签名(参数类型))\n\n    <span class=\"hljs-comment\">/**\n     * 切入点表达式的写法；\n     * 固定格式：execution(访问权限符 返回值类型  方法的全签名(参数类型))\n     * 通配符：\n     *         *  ：1）、匹配一个或者多个字符：execution(public int com.pzx2.impl.MyMath*.*(int ,int ))\n     *             2）、匹配任意一个参数：第一个是int类型，第二个参数是任意类型；（一共匹配两个类型）\n     *             execution(public int com.pzx2.impl.MyMathCalculator.*(int ,* ))\n     *            3）、只能匹配一层路径\n     *            4)、权限位置的*不能表示任意的权限值，权限位置不写，就带表任意的访问修饰符（public【是可选项的】）\n     *\n     *\n     *       .. ： 1）、匹配任意多个参数\n     *              execution(public int com.pzx2.impl.MyMathCalculator.*(..))\n     *             2)匹配任意多层路径\n     *             execution(public int com.pzx2.impl..MyMathCalculator.*(..))\n     *\t\n     * 记住两种：\n     * 最精确的写法：execution(public int com.pzx2.impl.MyMathCalculator.add(int,int))\n     * 最模糊的：execution(* *.*(..)):千万别写\n     *\n     * 还可以使用下面的表达式\n     * \"&amp;&amp;\"、\"||\"、\"!\"\n     * MyMathCalculator.add(int , double)\n     * 切入点表达式要满足下面两个表达式才行\n     * execution(public int com.pzx..MyMath*.*(..))  &amp;&amp;  execution(*  *.*(int,int))\n     *||：满足一个表达式即可\n     *\n     *\n     */</span>\n</code></pre>\n<p>将切入点表达式抽取出来可重复使用（<font color='red'>同一个类里面的引用</font>直接用<font color='red'>方法名加上参数列表</font>即可，而不是<font color='red'>同一个类之间的引用的话要用全类</font><font color='red'>名</font>）</p>\n<pre class=\"highlight\"><code class=\"java\"> <span class=\"hljs-comment\">/** 抽取可重用的切入点表达式；\n     * 1、随便声明一个没有实现的返回void的空方法\n     * 2、给方法上标注<span class=\"hljs-doctag\">@Pointcut</span>\n     */</span>\n     \n    <span class=\"hljs-meta\">@Pointcut</span>(<span class=\"hljs-string\">\"execution(* com.pzx2.impl..MyMathCalculator.*(..))\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hahaMyPoint</span><span class=\"hljs-params\">()</span></span>&#123;\n\n    &#125;\n</code></pre>\n<h3 id=\"环绕通知代码演示\"><a class=\"markdownIt-Anchor\" href=\"#环绕通知代码演示\"></a> 环绕通知代码演示</h3>\n<pre class=\"highlight\"><code class=\"java\">   <span class=\"hljs-comment\">/**\n     * <span class=\"hljs-doctag\">@Around</span> :环绕通知是Spring中最强大的通知方法\n     * <span class=\"hljs-doctag\">@Around</span>：环绕动态代理；\n     *\n     * try&#123;\n     *          //前置通知\n     *          method.invoke(obj,args);\n     *          //返回通知\n     *   &#125;catch(Exception e)&#123;\n     *              //异常通知\n     *   &#125;finally&#123;\n     *          //后置通知\n     *   &#125;\n     *\n     *  四合一就是环绕通知\n     *  环绕通知中有一个参数  :  ProceedingJoinPoint pjp\n     *\n     * 环绕通知：是优先于普通通知执行，执行顺序；\n     * [普通方法执行]\n     * &#123;\n     *      try&#123;\n     *             环绕前置\n     *            环绕执行：目标方法执行\n     *            环绕返回\n     *      &#125;catch()&#123;\n     *            环绕出现异常\n     *      &#125;finally&#123;\n     *            环绕后置\n     *      &#125;\n     *\n     *\n     *\n     *\n     * &#125;\n     * [普通后置]\n     * [普通方法返回 / 方法异常]\n     *\n     *\n     *  新的顺序；\n     *          注意：这个是Spring4的运行顺序   环绕前置--&gt;普通方法前置--&gt;目标方法执行--&gt;环绕正常返回/出现异常--&gt;环绕后置--&gt;普通后置--&gt;普通返回或者异常\n     *             Spring5的顺序不同\n     *\n     *\n     *\n     */</span>\n\n\n    <span class=\"hljs-meta\">@Around</span>(<span class=\"hljs-string\">\"hahaMyPoint()\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">myAround</span><span class=\"hljs-params\">(ProceedingJoinPoint pjp)</span> </span>&#123;\n        Object proceed=<span class=\"hljs-keyword\">null</span>;\n        Signature signature = pjp.getSignature();\n        String name = signature.getName();\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Object[] args = pjp.getArgs();\n            <span class=\"hljs-comment\">//利用反射推进目标方法即可，就是method.invoke(obj,args);</span>\n            <span class=\"hljs-comment\">//Before</span>\n            System.out.println(<span class=\"hljs-string\">\"【环绕前置】【\"</span> + name + <span class=\"hljs-string\">\"方法开始】\"</span>);\n            proceed = pjp.proceed(args);\n            <span class=\"hljs-comment\">//@AfterReturning</span>\n            System.out.println(<span class=\"hljs-string\">\"【环绕返回通知】【\"</span>+name+<span class=\"hljs-string\">\"方法返回，返回值\"</span>+proceed+<span class=\"hljs-string\">\"】\"</span>);\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Throwable throwable) &#123;\n            <span class=\"hljs-comment\">//@AfterThrowing</span>\n             System.out.println(<span class=\"hljs-string\">\"【环绕方法出现异常】【\"</span> + name + <span class=\"hljs-string\">\"】方法出现异常，异常原因：\"</span> + throwable);\n                <span class=\"hljs-comment\">//为了让外界知道这个原因，这个异常一定要抛出去</span>\n            <span class=\"hljs-keyword\">throw</span>  <span class=\"hljs-keyword\">new</span> RuntimeException(throwable);\n\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n<span class=\"hljs-comment\">//            @After()</span>\n            System.out.println(<span class=\"hljs-string\">\"【环绕后置通知】 【\"</span> + name + <span class=\"hljs-string\">\"】方法结束\"</span>);\n\n\n        &#125;\n\n        <span class=\"hljs-comment\">//反射调用后，返回值一定也返回出去</span>\n        <span class=\"hljs-keyword\">return</span> proceed;\n\n\n    &#125;\n\n\n</code></pre>\n<h3 id=\"当普通方法与环绕方法一起执行的时候的方法执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#当普通方法与环绕方法一起执行的时候的方法执行顺序\"></a> 当普通方法与环绕方法一起执行的时候的方法执行顺序</h3>\n<p><font color='red'>Spring5的执行顺序</font></p>\n<p>环绕前置–&gt;普通方法前置–&gt;目标方法执行–&gt;普通正常返回/出现异常–&gt;普通后置–&gt;环绕正常返回/出现异常–&gt;环绕后置</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210816101109.png\" alt=\"image-20210816101059968\" /></p>\n<h3 id=\"多切面执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#多切面执行顺序\"></a> 多切面执行顺序</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210816101159.png\" alt=\"image-20210816101158530\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210816101233.png\" alt=\"image-20210816101224967\" /></p>\n<h3 id=\"xml格式配置通知方法\"><a class=\"markdownIt-Anchor\" href=\"#xml格式配置通知方法\"></a> xml格式配置通知方法</h3>\n<pre class=\"highlight\"><code class=\"xml\">  <span class=\"hljs-comment\">&lt;!--  需要AOP名称空间  --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:config</span>&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!--    声明一个全局的切入点表达式    --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:pointcut</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"globalPoint\"</span> <span class=\"hljs-attr\">expression</span>=<span class=\"hljs-string\">\"execution(* com.xml.impl.*.*(..))\"</span>/&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!--    指定切面  @Aspect   --&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:aspect</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"logUtils\"</span>&gt;</span>\n                    <span class=\"hljs-comment\">&lt;!--    配置哪个方法是前置通知;method指定方法名\n                        logStart@Before(\"切入点表达式\")\n                    --&gt;</span>\n                    <span class=\"hljs-comment\">&lt;!--    这个表达式只能当前切面能用        --&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:pointcut</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mypoint\"</span> <span class=\"hljs-attr\">expression</span>=<span class=\"hljs-string\">\"execution(* com.xml.impl.*.*(..))\"</span>/&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:before</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logStart\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"mypoint\"</span>/&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after-returning</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logReturn\"</span> <span class=\"hljs-attr\">returning</span>=<span class=\"hljs-string\">\"result\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"mypoint\"</span>/&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after-throwing</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logException\"</span> <span class=\"hljs-attr\">throwing</span>=<span class=\"hljs-string\">\"exception\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"mypoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:after-throwing</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logEnd\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"mypoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:after</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:around</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"myAround\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"mypoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:around</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:aspect</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:aspect</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"validateApsect\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:before</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logStart\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"globalPoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:before</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after-returning</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logReturn\"</span> <span class=\"hljs-attr\">returning</span>=<span class=\"hljs-string\">\"result\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"globalPoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:after-returning</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after-throwing</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logException\"</span> <span class=\"hljs-attr\">throwing</span>=<span class=\"hljs-string\">\"exception\"</span>\n                                <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"globalPoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:after-throwing</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aop:after</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"logEnd\"</span> <span class=\"hljs-attr\">pointcut-ref</span>=<span class=\"hljs-string\">\"globalPoint\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:after</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:aspect</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aop:config</span>&gt;</span>\n</code></pre>\n<p>高版本的tomcat，在SpringMVC使用DELETE、PUT请求时爆错405</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210818103226.png\" alt=\"image-20210818103218030\" /></p>\n<p>解决办法，在jsp页面上加上</p>\n<pre class=\"highlight\"><code class=\"jsp\">&lt;%@ page contentType=<span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"hljs-string\">\"java\"</span>\nisErrorPage=<span class=\"hljs-string\">\"true\"</span> \n%&gt; 其实主要是加上isErrorPage=<span class=\"hljs-string\">\"true\"</span> ，告诉tomcat可能会报错\n</code></pre>\n<p><strong>ModelAttribute原理</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220122221350.png\" alt=\"image-20210819225004017\" /></p>\n<h2 id=\"springmvc的运行流程\"><a class=\"markdownIt-Anchor\" href=\"#springmvc的运行流程\"></a> SpringMVC的运行流程</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210828203148.png\" alt=\"image-20210828203135169\" /></p>\n<p>SpringMVC和Spring进行整合时，Spring的Service不能自动装配SpringMVC的Controller是因为在Spring中默认讲Spring作为父容器，SpringMVC作为子容器。子容器可以拿父容器的东西，父容器不能拿子容器</p>\n<img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220122221357.png\" alt=\"image-20210829100815284\" style=\"zoom:60%;\" />\n<h2 id=\"mybatis中的知识点的简单记录\"><a class=\"markdownIt-Anchor\" href=\"#mybatis中的知识点的简单记录\"></a> mybatis中的知识点的简单记录</h2>\n<p><a href=\"https://199604.com/709\">https://199604.com/709</a></p>\n<h3 id=\"mybatis中一级缓存和二级缓存的示意图\"><a class=\"markdownIt-Anchor\" href=\"#mybatis中一级缓存和二级缓存的示意图\"></a> mybatis中一级缓存和二级缓存的示意图</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220122221305.png\" alt=\"image-20210906104506413\" /></p>\n","categories":["ssm"],"tags":["ssm"]},{"title":"javaweb复习","url":"/2022/01/22/javaweb%E5%A4%8D%E4%B9%A0/","content":"<h1 id=\"javaweb复习\"><a class=\"markdownIt-Anchor\" href=\"#javaweb复习\"></a> Javaweb复习</h1>\n<p><font color='red'>学Servlet程序、Filter过滤器、Listener监听器、Cookie技术、Session会话、JSON使用这几个即可</font></p>\n<h2 id=\"cookie的工作机制\"><a class=\"markdownIt-Anchor\" href=\"#cookie的工作机制\"></a> Cookie的工作机制</h2>\n<p>Cookie是由服务器端创建的，放在响应头中推送到浏览器，浏览器保存到本地缓存中</p>\n<pre class=\"highlight\"><code class=\"java\">Cookie cookie=<span class=\"hljs-keyword\">new</span> Cookie(name,value);\nJava代码   response.addCookie(cookie对象);\nHTTP响应消息头：Set-Cookie：Cookie的名字=Cookie的值\n</code></pre>\n<p>浏览器接收到服务端返回的cookie，以后每次都会把cookie带上</p>\n<p>HTTP请求消息头：Set-Cookie：Cookie的名字=Cookie的值</p>\n<h2 id=\"session的工作机制\"><a class=\"markdownIt-Anchor\" href=\"#session的工作机制\"></a> Session的工作机制</h2>\n<p>获取Session对象：request.getSession()</p>\n<ul>\n<li>检查当前请求是否携带<font color='red'>JSESSIONID</font>这个Cookie</li>\n<li>带了：根据JSESSIONID在服务端查找对应的Session对象</li>\n<li>能找到：就把找到的Session对象返回</li>\n<li>没有找到：新建Session对象返回，同时返回JSESSIONID的Cookie</li>\n<li>没带：新建Session对象返回，同时返回JSESSIONID的Cookie</li>\n</ul>\n<span id=\"more\"></span>\n<p>javaWeb的三大组件（Servlet、Filter、Linstener）</p>\n<h2 id=\"filter的工作流程\"><a class=\"markdownIt-Anchor\" href=\"#filter的工作流程\"></a> Filter的工作流程</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210709210920.png\" alt=\"image-20210709210911765\" /></p>\n<h2 id=\"linstener\"><a class=\"markdownIt-Anchor\" href=\"#linstener\"></a> Linstener</h2>\n<h3 id=\"监听器\"><a class=\"markdownIt-Anchor\" href=\"#监听器\"></a> 监听器</h3>\n<p>linstener八个监听器：ServletRequest（2）、HttpSession（2）、ServeltContext（4）</p>\n<p>2：生命周期监听器、属性变化监听器</p>\n<p>4（HttpSession）：2、额外的两个（活化钝化监听器、绑定解绑监听器）</p>\n<p>掌握的监听器：</p>\n<p>ServletContextListenter：（生命周期监听器）；监听ServletContext的创建和销毁（监听服务器的启动、停止）；服务器一启动为当前项目创建ServletContext对象，服务器停止销毁创建的ServletContext；</p>\n<p>ServletContext：</p>\n<ol>\n<li>一个web项目对应一个ServletContext，它代表当前web项目的信息</li>\n<li>还可以作为最大域对象在整个项目的运行期间共享数据</li>\n</ol>\n<h3 id=\"用法\"><a class=\"markdownIt-Anchor\" href=\"#用法\"></a> 用法</h3>\n<ol>\n<li>\n<p>实现对应的监听器接口</p>\n</li>\n<li>\n<p>去web.xml中进行配置</p>\n<p>​\t注意：有两个Listener是JavaBean需要实现的接口，（HttpSessionActivitionListener，HttpSessionBindingListener）</p>\n</li>\n</ol>\n<h2 id=\"ajax和json\"><a class=\"markdownIt-Anchor\" href=\"#ajax和json\"></a> AJAX和JSON</h2>\n<p><em>JSON</em>(JavaScript Object Notation, JS 对象简谱) （js对象表示法）是一种轻量级（和xml相比和轻量）的数据交换格式。</p>\n<pre class=\"highlight\"><code class=\"javascript\">&#123;<span class=\"hljs-attr\">key</span>:value,<span class=\"hljs-attr\">key</span>:value&#125;;\n</code></pre>\n","categories":["javaweb"],"tags":["javaweb"]},{"title":"nginx学习","url":"/2022/01/20/nginx%E5%AD%A6%E4%B9%A0/","content":"<h1 id=\"nginx安装\"><a class=\"markdownIt-Anchor\" href=\"#nginx安装\"></a> nginx安装</h1>\n<h2 id=\"第一步-安装-pcre\"><a class=\"markdownIt-Anchor\" href=\"#第一步-安装-pcre\"></a> 第一步， 安装 pcre</h2>\n<pre class=\"highlight\"><code class=\"bash\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n</code></pre>\n<h3 id=\"解压文件\"><a class=\"markdownIt-Anchor\" href=\"#解压文件\"></a> 解压文件</h3>\n<pre class=\"highlight\"><code class=\"bash\">tar -zxvf pcre-8.37.tar.gz\n./configure 完成后，回到 pcre 目录下执行 make，\n</code></pre>\n<h2 id=\"第二步-安装-openssl\"><a class=\"markdownIt-Anchor\" href=\"#第二步-安装-openssl\"></a> 第二步， 安装 openssl</h2>\n<h2 id=\"第三步-安装-zlib\"><a class=\"markdownIt-Anchor\" href=\"#第三步-安装-zlib\"></a> 第三步， 安装 zlib</h2>\n<pre class=\"highlight\"><code class=\"bash\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n</code></pre>\n<h2 id=\"第四步-安装-nginx\"><a class=\"markdownIt-Anchor\" href=\"#第四步-安装-nginx\"></a> 第四步， 安装 nginx</h2>\n<p>1、 解压缩 nginx-xx.tar.gz 包</p>\n<p>2、 进入解压缩目录， 执行./configure。</p>\n<p>3、 make &amp;&amp; make install</p>\n<h3 id=\"设置nginx的环境变量\"><a class=\"markdownIt-Anchor\" href=\"#设置nginx的环境变量\"></a> 设置nginx的环境变量</h3>\n<pre class=\"highlight\"><code class=\"bash\">ln -s /usr/<span class=\"hljs-built_in\">local</span>/nginx/sbin/nginx /usr/<span class=\"hljs-built_in\">local</span>/bin/\n</code></pre>\n<h3 id=\"查看开放的端口号\"><a class=\"markdownIt-Anchor\" href=\"#查看开放的端口号\"></a> 查看开放的端口号</h3>\n<pre class=\"highlight\"><code class=\"bash\">firewall -cmd --list-all\n</code></pre>\n<h3 id=\"设置开放的端口号\"><a class=\"markdownIt-Anchor\" href=\"#设置开放的端口号\"></a> 设置开放的端口号</h3>\n<pre class=\"highlight\"><code class=\"bash\">firewall -cmd --add-service=http –permanent\nsudo firewall -cmd --add-port=80/tcp --permanent\n</code></pre>\n<h3 id=\"重启防火墙\"><a class=\"markdownIt-Anchor\" href=\"#重启防火墙\"></a> 重启防火墙</h3>\n<pre class=\"highlight\"><code class=\"bash\">firewall-cmd –reload\n</code></pre>\n<span id=\"more\"></span>\n<h1 id=\"nginx的常用指令\"><a class=\"markdownIt-Anchor\" href=\"#nginx的常用指令\"></a> nginx的常用指令</h1>\n<pre><code>## （ 1）启动命令  \n</code></pre>\n<pre class=\"highlight\"><code class=\"bash\">在/usr/<span class=\"hljs-built_in\">local</span>/nginx/sbin 目录下执行 ./nginx\n因为配置了环境变量，可以直接使用nginx\n</code></pre>\n<pre><code>## （ 2）关闭命令  \n</code></pre>\n<pre class=\"highlight\"><code class=\"bash\">在/usr/<span class=\"hljs-built_in\">local</span>/nginx/sbin 目录下执行 ./nginx -s stop\n</code></pre>\n<h2 id=\"3-重新加载命令-这个是热加载的方式\"><a class=\"markdownIt-Anchor\" href=\"#3-重新加载命令-这个是热加载的方式\"></a> （ 3） 重新加载命令  这个是热加载的方式</h2>\n<pre class=\"highlight\"><code class=\"bash\">在/usr/<span class=\"hljs-built_in\">local</span>/nginx/sbin 目录下执行 ./nginx -s reload\n</code></pre>\n<h2 id=\"tomtcat的安装目录\"><a class=\"markdownIt-Anchor\" href=\"#tomtcat的安装目录\"></a> tomtcat的安装目录</h2>\n<pre class=\"highlight\"><code class=\"txt\">/usr/src/apache-tomcat-9.0.52/bin\n</code></pre>\n<h1 id=\"配置反向代理1\"><a class=\"markdownIt-Anchor\" href=\"#配置反向代理1\"></a> 配置反向代理（1）</h1>\n<p>先要在Windows的C:\\Windows\\System32\\drivers\\etc下的hosts里面加上192.168.58.130   <a href=\"http://www.123.com\">www.123.com</a></p>\n<p><font color='red'>注意这个要用editplus打开，管理员运行</font></p>\n<pre class=\"highlight\"><code class=\"txt\">这个是在nginx.config\n</code></pre>\n<p>这个nginx的配置文件是在**/usr/local/nginx/conf**</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195047.png\" alt=\"image-20210909110313430\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">这个proxy_pass http://127.0.0.1:8080这个是要转发的路径\t\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195050.png\" alt=\"image-20210909113916794\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195117.png\" alt=\"image-20220118203823143\" /></p>\n<h1 id=\"nginx配置实例-反向代理2\"><a class=\"markdownIt-Anchor\" href=\"#nginx配置实例-反向代理2\"></a> Nginx配置实例-反向代理（2）</h1>\n<p>实现效果：使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中<br />\nnginx 监听端口为 9001，<br />\n访问 <a href=\"http://127.0.0.1:9001/edu/\">http://127.0.0.1:9001/edu/</a> 直接跳转到 127.0.0.1:8081<br />\n访问 <a href=\"http://127.0.0.1:9001/vod/\">http://127.0.0.1:9001/vod/</a> 直接跳转到 127.0.0.1:8082</p>\n<h2 id=\"这个是在nginxconf里面配置\"><a class=\"markdownIt-Anchor\" href=\"#这个是在nginxconf里面配置\"></a> 这个是在nginx.conf里面配置</h2>\n<pre class=\"highlight\"><code class=\"bash\">    server &#123;\n        listen       9001;\n        server_name  192.168.58.130;\n\n\t\t<span class=\"hljs-comment\"># 这个~表示的是后面是正则表达式的意思，如果路径中有edu就跳转到http://127.0.0.1:8080</span>\n        location ~ /edu/ &#123;\n           proxy_pass http://127.0.0.1:8080;\n\n &#125;\n        location ~ /vod/ &#123;\n           proxy_pass http://127.0.0.1:8081;\n&#125;\n\n   &#125;\n\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195906.png\" alt=\"image-20210909144804339\" /></p>\n<h2 id=\"开放对外访问的端口9001-8080-8081\"><a class=\"markdownIt-Anchor\" href=\"#开放对外访问的端口9001-8080-8081\"></a> 开放对外访问的端口9001 8080 8081</h2>\n<h3 id=\"查看开放的端口号-2\"><a class=\"markdownIt-Anchor\" href=\"#查看开放的端口号-2\"></a> 查看开放的端口号</h3>\n<pre class=\"highlight\"><code class=\"bash\">firewall-cmd  --list-all\n</code></pre>\n<h3 id=\"打开指定的端口号\"><a class=\"markdownIt-Anchor\" href=\"#打开指定的端口号\"></a> 打开指定的端口号</h3>\n<pre class=\"highlight\"><code class=\"bash\">firewall-cmd --zone=public --add-port=端口号/tcp --permanent\n</code></pre>\n<h2 id=\"效果\"><a class=\"markdownIt-Anchor\" href=\"#效果\"></a> 效果</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195122.png\" alt=\"image-20220118211444270\" /></p>\n<p><img src=\"https://github.com/losserlong/pictures/blob/main/20220121101059.png?raw=true\" alt=\"20220121101059.png\" /></p>\n<h1 id=\"nginx实现负载均衡的效果\"><a class=\"markdownIt-Anchor\" href=\"#nginx实现负载均衡的效果\"></a> nginx实现负载均衡的效果</h1>\n<h2 id=\"实现nginx的负载均衡效果\"><a class=\"markdownIt-Anchor\" href=\"#实现nginx的负载均衡效果\"></a> 实现nginx的负载均衡效果</h2>\n<blockquote>\n<p>1、实现效果<br />\n(1）浏览器地址栏输入地址http://192.168.17.129/edu/a.html，负载均衡效果，平均8080和8081端口中</p>\n<p>2、准备工作<br />\n(1）准备两台tomcat服务器，一台8080,一台8081<br />\n(2）在两台tomcat里面webapps,目录中，创建名称是edu文件夹，在edu,文件夹中创建页面a.html,用于测试</p>\n<p>3、/usr/local/nginx/conf下面配置nginx的配置文件</p>\n</blockquote>\n<p>这个是在nginx.conf文件的配置</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195127.png\" alt=\"image-20220118213235623\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195131.png\" alt=\"image-20220118214750883\" /></p>\n<p>负载均均衡效果</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220121100741.png\" alt=\"image-20220118220151429\" /></p>\n<h2 id=\"nginx的负载均衡策略\"><a class=\"markdownIt-Anchor\" href=\"#nginx的负载均衡策略\"></a> nginx的负载均衡策略</h2>\n<p>**1、**轮询（默认）</p>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>\n<p><strong>2、</strong>    <strong>weight</strong></p>\n<p>weight 代表权,重默认为 1,权重越高被分配的客户端越多</p>\n<blockquote>\n<p>upstream server_pool{  server 192.168.5.21 weight=10;   server 192.168.5.22 weight=10;</p>\n<p>}</p>\n</blockquote>\n<p>3、<strong>ip_hash</strong></p>\n<p>每个请求按访问 ip 的 hash 结果分配，<strong>这样每个访客固定访问一个后端服务器</strong>，<strong>可以解决 session 的问题。 例如：</strong> （可以用来解决session共享的问题）</p>\n<blockquote>\n<p>upstream server_pool{  ip_hash;   server 192.168.5.21:80;   server 192.168.5.22:80;   }</p>\n</blockquote>\n<p>4、<strong>fair</strong>（第三方）</p>\n<p><strong>按后端服务器的响应时间来分配请求</strong>，响应时间短的优先分配。</p>\n<blockquote>\n<p>upstream  server_pool{  server 192.168.5.21:80;   server  192.168.5.22:80;   ![img](file:///C:/Users/losser/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)  fair;     }</p>\n</blockquote>\n<h1 id=\"nginx配置实例-动静分离\"><a class=\"markdownIt-Anchor\" href=\"#nginx配置实例-动静分离\"></a> Nginx配置实例-动静分离</h1>\n<h2 id=\"什么是动静分离\"><a class=\"markdownIt-Anchor\" href=\"#什么是动静分离\"></a> 什么是动静分离</h2>\n<p><code>Nginx</code> <strong>动静分离简单来说就是把动态跟静态请求分开</strong>，不能理解成只是单纯的把动态页面和静态页面物理分离。<strong>严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面</strong>。动静分离从目前实现角度来讲大致分为两种，</p>\n<p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。</p>\n<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码</p>\n<p>304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>\n<h2 id=\"动静分离示意图\"><a class=\"markdownIt-Anchor\" href=\"#动静分离示意图\"></a> 动静分离示意图</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195141.png\" alt=\"image-20220119161042681\" /></p>\n<p>准备工作</p>\n<p>1）在Linux系统中准备静态资源，用于进行访问</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195147.png\" alt=\"image-20220119162157558\" /></p>\n<p>2）具体配置</p>\n<p>（1）在nginx配置文件中进行配置，这里面的autoindex on表示的是列出文件夹中的内容</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195149.png\" alt=\"image-20220119163051587\" /></p>\n<p>4）最终测试</p>\n<p>（1）浏览器中输入地址</p>\n<p><a href=\"http://192.168.60.10/image/author.jpg\">http://192.168.60.10/image/author.jpg</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195153.png\" alt=\"image-20220119163417185\" /><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220121101150.png\" alt=\"image-20220119163426202\" /></p>\n<p>也能访问</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195158.png\" alt=\"image-20220119163658273\" /></p>\n<h1 id=\"nginx的高可用\"><a class=\"markdownIt-Anchor\" href=\"#nginx的高可用\"></a> nginx的高可用</h1>\n<h2 id=\"什么是高可用\"><a class=\"markdownIt-Anchor\" href=\"#什么是高可用\"></a> 什么是高可用</h2>\n<p><strong>单点故障</strong>（英语：single point of failure，缩写SPOF）是指系统中一点失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。</p>\n<p><strong>高可用性</strong>（英语：high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行。<br />\n<strong>高可用性通常通过提高系统的容错能力来实现。定义一个系统怎样才算具有高可用性往往需要根据每一个案例的具体情况来具体分析。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195237.png\" alt=\"image-20220119171907161\" /></p>\n<p>（1）需要两台nginx服务器</p>\n<p>（2）需要keeplived（用来检测nginx服务器是否还活着）</p>\n<p>（3）需要虚拟IP</p>\n<h2 id=\"配置高可用的准备工作\"><a class=\"markdownIt-Anchor\" href=\"#配置高可用的准备工作\"></a> 配置高可用的准备工作</h2>\n<ol>\n<li>要有两个虚拟机的环境（我这里是直接用第一台进行克隆）</li>\n</ol>\n<p>​\t一台是192.168.60.11</p>\n<p>​\t另一台是192.168.60.10</p>\n<ol start=\"2\">\n<li>在两台服务器上安装nginx</li>\n<li>在两台服务器上安装keeplived，使用yum命令进行安装</li>\n</ol>\n<pre class=\"highlight\"><code class=\"bash\">yum install -y keepalived\n</code></pre>\n<p>安装完成之后，keepalived的配置文件的位置/etc/keepalived</p>\n<h2 id=\"完成高可用的配置主从配置\"><a class=\"markdownIt-Anchor\" href=\"#完成高可用的配置主从配置\"></a> 完成高可用的配置（主从配置）</h2>\n<p>（1）修改/etc/keepalived/keepalived.conf  的配置文件</p>\n<pre class=\"highlight\"><code class=\"\">global_defs &#123;\n\tnotification_email &#123;\n\t\tacassen@firewall.loc\n\t\tfailover@firewall.loc\n\t\tsysadmin@firewall.loc\n\t&#125;\n\tnotification_email_from Alexandre.Cassen@firewall.loc\n\tsmtp_server 192.168.60.11\n\tsmtp_connect_timeout 30\n\trouter_id LVS_DEVEL  #访问主机\n&#125;\n\nvrrp_script chk_http_port &#123;\n\tscript &quot;/usr/local/src/nginx_check.sh&quot;\n\tinterval 2 #（检测脚本执行的间隔）\n\tweight -20   # 权重，如果当前的条件成立，就将当前的主机的权重降低20\n&#125;\n\nvrrp_instance VI_1 &#123;\n\tstate BACKUP # 备份服务器上将 MASTER 改为 BACKUP\n\tinterface ens33 //网卡名称\n\tvirtual_router_id 51 # 主、备机的 virtual_router_id 必须相同\n\tpriority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小，值越大，优先级越高 \n\tadvert_int 1 # 发送心跳，检测主备服务器是否还活着，这里是1秒\n\tauthentication &#123; # 权限校验的方式用的是密码四个1\n\t\tauth_type PASS\n\t\tauth_pass 1111\n\t&#125;\n\tvirtual_ipaddress &#123;\n\t\t192.168.60.50 // VRRP H 虚拟地址\n\t&#125;\n&#125;\n</code></pre>\n<p>（2）在/usr/local/src下面添加检测nginx是否还活着的脚本nginx_check.sh</p>\n<pre class=\"highlight\"><code class=\"sh\"><span class=\"hljs-meta\">#!/bin/bash</span>\nA=`ps -C nginx –no-header |wc -l`\n<span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-variable\">$A</span> -eq 0 ];<span class=\"hljs-keyword\">then</span>\n    /usr/<span class=\"hljs-built_in\">local</span>/nginx/sbin/nginx  <span class=\"hljs-comment\">#nginx启动脚本的位置</span>\n    sleep 2\n    <span class=\"hljs-keyword\">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0 ];<span class=\"hljs-keyword\">then</span>\n        killall keepalived\n    <span class=\"hljs-keyword\">fi</span>\n<span class=\"hljs-keyword\">fi</span>\n</code></pre>\n<p>（3）把两台服务器上的nginx和keepalived启动</p>\n<p>启动nginx：./nginx</p>\n<p>启动keepalived：systemctl  start  keepalived.service</p>\n<p>（5）最终测试</p>\n<p>（1）在浏览器地址栏中输入虚拟的IP地址192.168.60.50，说明虚拟IP绑定是正确的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195241.png\" alt=\"image-20220119230324269\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195244.png\" alt=\"image-20220119230207848\" /></p>\n<p>（2）把主服务器（192.168.60.10）的nginx和keepalived停止，发现ngin已经切换到了备份服务器上，而且浏览器访问，还是有nginx（因为当主服务器挂掉之后，keepalived通过脚本检测到备份服务器还活着，就切换到备份服务器）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195247.png\" alt=\"image-20220120185354530\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195249.png\" alt=\"image-20220120185437883\" /></p>\n<h2 id=\"nginx的原理解析\"><a class=\"markdownIt-Anchor\" href=\"#nginx的原理解析\"></a> nginx的原理解析</h2>\n<h3 id=\"master和worker\"><a class=\"markdownIt-Anchor\" href=\"#master和worker\"></a> master和worker</h3>\n<pre class=\"highlight\"><code class=\"bash\">ps -ef | grep nginx\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120214838.png\" alt=\"image-20220120191125667\" /></p>\n<p>这个master相当于是一个领导，一般不做具体的工作，一般是用来分配任务。master分配任务给手下的worker，worker去做具体的事情</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195253.png\" alt=\"image-20220120191813067\" /></p>\n<h3 id=\"worker是如何进行工作的\"><a class=\"markdownIt-Anchor\" href=\"#worker是如何进行工作的\"></a> worker是如何进行工作的</h3>\n<p>worker是使用争抢的机制，抢到一个任务，就调用tomcat或者反向代理完成具体操作操作。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195255.png\" alt=\"image-20220120191803483\" /></p>\n<h3 id=\"一个master和多个worker的好处\"><a class=\"markdownIt-Anchor\" href=\"#一个master和多个worker的好处\"></a> 一个master和多个worker的好处</h3>\n<ol>\n<li>可以使用nginx -s reload 热部署的方式，利于nginx进行热部署操作</li>\n<li>每个worker是一个<strong>独立的进程</strong>，如果说有其中的一个worker出现问题，那其他的worker独立的，继续进行争抢，实现请求过程，不会造成服务的中断。</li>\n</ol>\n<blockquote>\n<p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。需要设置多少个 <strong>worker</strong></p>\n<p>Nginx 同 redis 类似都采用了 <strong>io 多路复用机制</strong>，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。**所以 worker 数和服务器的 cpu 数相等是最为适宜的。**设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p>\n</blockquote>\n<h3 id=\"一些参数设置\"><a class=\"markdownIt-Anchor\" href=\"#一些参数设置\"></a> 一些参数设置</h3>\n<blockquote>\n<p>设置worker的数量和cpu的数量相等是最为适宜的</p>\n</blockquote>\n<blockquote>\n<p>连接数worker connection</p>\n<p>第一个：发送请求，占用了worker的几个连接数</p>\n<p>2个或者4个</p>\n</blockquote>\n<p>连接数：</p>\n<blockquote>\n<p>连接数 <strong>worker_connection</strong></p>\n<p>这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请求本地资源来说，能够支持的最大并发数量是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>\n</blockquote>\n<p>如果是静态资源的话就是两个连接数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195258.png\" alt=\"image-20220120193446745\" />，</p>\n<p>如果是要访问tomcat就是四个连接数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195302.png\" alt=\"image-20220120193702496\" /></p>\n<p>第二个: nginx,有一个master，有四个woker，每个woker支持最大的连接数据1024，支持的最大并发数是多少？\t\t(1024*4)/2（<strong>静态访问</strong>）\t\t或者\t  （1024*4)/4  （<strong>作为反向代理</strong>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220120195302.png\" alt=\"image-20220120194458610\" /></p>\n","categories":["nginx"],"tags":["nginx学习"]},{"title":"linux基础","url":"/2022/01/19/linux%E5%9F%BA%E7%A1%80/","content":"<h1 id=\"vim和vi的基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#vim和vi的基本介绍\"></a> vim和vi的基本介绍</h1>\n<p>所有的 Linux 系统都会内建 vi 文本编辑器。 Vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别 语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别 丰富，在程序员中被广泛使用。</p>\n<h2 id=\"vim和vi的常用的三种模式\"><a class=\"markdownIt-Anchor\" href=\"#vim和vi的常用的三种模式\"></a> vim和vi的常用的三种模式</h2>\n<p><strong>正常模式：</strong></p>\n<ul>\n<li>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用 『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。</li>\n</ul>\n<p><strong>插入模式：</strong></p>\n<ul>\n<li>按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可</li>\n</ul>\n<p><strong>命令行模式：</strong></p>\n<ul>\n<li>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的 动作则是在此模式中达成的！</li>\n</ul>\n<p>vi和vim的基本使用</p>\n<pre class=\"highlight\"><code class=\"txt\">使用vim Hello.java 对Hello.java进行编辑\n</code></pre>\n<span id=\"more\"></span> \n<h2 id=\"vim和vi模式的相互切换\"><a class=\"markdownIt-Anchor\" href=\"#vim和vi模式的相互切换\"></a> vim和vi模式的相互切换</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522201350810.png\" alt=\"image-20210522201350810\" /></p>\n<h3 id=\"强制退出vim编辑器\"><a class=\"markdownIt-Anchor\" href=\"#强制退出vim编辑器\"></a> 强制退出vim编辑器</h3>\n<pre class=\"highlight\"><code class=\"bash\">在插入模式下，先按esc，然后再按下:q!\n</code></pre>\n<h2 id=\"vim和vi快捷键的使用\"><a class=\"markdownIt-Anchor\" href=\"#vim和vi快捷键的使用\"></a> vim和vi快捷键的使用</h2>\n<p><strong>快捷键练习使用</strong>：</p>\n<ul>\n<li>\n<ol>\n<li><font color='red'><strong>拷贝</strong></font>当前行 yy , 拷贝当前行向下的5行 5yy，并粘贴。</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>**<font color='red'>删除</font>**当前行 dd , 删除当前行向下的5行 5dd *</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]</li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li>编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg]</li>\n</ol>\n</li>\n<li>\n<ol start=\"6\">\n<li>在一个文件中输入 “hello” ,然后又撤销这个动作 u</li>\n</ol>\n</li>\n<li>\n<ol start=\"7\">\n<li>编辑 /etc/profile 文件，并将光标移动到 20行 shift+g</li>\n</ol>\n</li>\n<li>\n<ol start=\"8\">\n<li>更多的看整理的文档</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20191219104939654.jpg\" alt=\"20191219104939654\" /></p>\n<h1 id=\"基本的指令\"><a class=\"markdownIt-Anchor\" href=\"#基本的指令\"></a> 基本的指令</h1>\n<h2 id=\"关机重启命令\"><a class=\"markdownIt-Anchor\" href=\"#关机重启命令\"></a> 关机&amp;重启命令</h2>\n<p>基本介绍</p>\n<p>shutdown  -h  now          立即进行关机</p>\n<p>shutdown  -h   1\t\t\t\t“hello,一分钟之后关机”</p>\n<p>shutdown  -r    now           现在重启计算机</p>\n<p>halt \t\t\t\t\t\t\t\t\t关机，作用和上面一样<font color='red'> (CentOS6)</font></p>\n<p>reboot\t\t\t\t\t\t\t\t现在重新启动计算机</p>\n<p>sync\t\t\t\t\t\t\t\t\t把内存的数据同步到磁盘中</p>\n<p>poweroff也是关机指令</p>\n<p><strong>注意细节</strong></p>\n<p>不管是重启系统还是关闭系统，首先要运行sync命，把内存中的数据写到磁盘中</p>\n<h2 id=\"用户管理\"><a class=\"markdownIt-Anchor\" href=\"#用户管理\"></a> 用户管理</h2>\n<p>基本介绍: 1) 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可 以利用普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份. 2) 在提示符下输入 logout 即可注销用户</p>\n<p><strong>在命令行里注销用户</strong></p>\n<p>直接输入logout（使用细节：logout注销指令在图形界面运行级别无效，在运行级别3有效）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210521112912370.png\" alt=\"image-20210521112912370\" /></p>\n<h2 id=\"添加用户\"><a class=\"markdownIt-Anchor\" href=\"#添加用户\"></a> 添加用户</h2>\n<p><strong>基本语法</strong></p>\n<p>useradd [选项]   用户名</p>\n<p>cd   表示change directory，是切换目录</p>\n<p><strong>应用案例</strong></p>\n<p>1）添加一个用户xiaoming</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210521114644804.png\" alt=\"image-20210521114644804\" /></p>\n<p><strong>细节说明</strong></p>\n<p>1）当创建用户成功后，会自动的创建和用户同名的家目录</p>\n<p>2）也可以通过useradd -d指定目录    新的用户名，给新创建的用户指定家目录</p>\n<h3 id=\"修改指定密码在工作中密码必须复杂\"><a class=\"markdownIt-Anchor\" href=\"#修改指定密码在工作中密码必须复杂\"></a> 修改/指定密码（在工作中密码必须复杂）</h3>\n<p>指定密码</p>\n<pre class=\"highlight\"><code class=\"bash\">passwd 用户名\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522095342857.png\" alt=\"image-20210522095342857\" /></p>\n<p>修改密码</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522095537757.png\" alt=\"image-20210522095537757\" /></p>\n<h3 id=\"删除用户\"><a class=\"markdownIt-Anchor\" href=\"#删除用户\"></a> 删除用户</h3>\n<p><strong>基本语法</strong></p>\n<pre class=\"highlight\"><code class=\"bash\">userdel [选项] 用户名  选项：-r 表示删除的同时，将其家目录也一同删除了\n</code></pre>\n<p>引用案例</p>\n<p>1）删除用户xm，但是要保留家目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522100131970.png\" alt=\"image-20210522100131970\" /></p>\n<p>2）删除用户xh以及用户主目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522100617709.png\" alt=\"image-20210522100617709\" /></p>\n<p><strong>细节</strong>：在删除用户时，我们一般不删除家目录</p>\n<h2 id=\"查询用户信息\"><a class=\"markdownIt-Anchor\" href=\"#查询用户信息\"></a> 查询用户信息</h2>\n<h3 id=\"基本语法\"><a class=\"markdownIt-Anchor\" href=\"#基本语法\"></a> <strong>基本语法</strong></h3>\n<p>id 用户名</p>\n<p>应用示例：查询root用户信息</p>\n<p>如果用户不存在，则返回无此用户</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522101318669.png\" alt=\"image-20210522101318669\" /></p>\n<h3 id=\"切换用户\"><a class=\"markdownIt-Anchor\" href=\"#切换用户\"></a> 切换用户</h3>\n<pre class=\"highlight\"><code class=\"bash\">su   -  切换用户名\n</code></pre>\n<p><strong>应用实例</strong></p>\n<p>1）创建一个用户zf，指定密码，然后切换到zf</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522101645802.png\" alt=\"image-20210522101645802\" /></p>\n<p>从普通用户切换回root用户两种方式</p>\n<p>1）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522101841615.png\" alt=\"image-20210522101841615\" /></p>\n<p>2）<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522101909970.png\" alt=\"image-20210522101909970\" /></p>\n<p><strong>细节说明</strong></p>\n<p>1）从权限高的用户切换到权限低的用户，不需要输入密码，繁殖需要。</p>\n<p>2）当需要返回到用户时，使用<strong>exit</strong>指令</p>\n<h3 id=\"查看当前用户登录用户\"><a class=\"markdownIt-Anchor\" href=\"#查看当前用户登录用户\"></a> 查看当前用户/登录用户</h3>\n<ul>\n<li>基本语法</li>\n</ul>\n<p>whoami  /   who  am  I</p>\n<h3 id=\"用户组\"><a class=\"markdownIt-Anchor\" href=\"#用户组\"></a> 用户组</h3>\n<p>介绍：类似于角色，系统可以对共性的多个用户进行统一的管理。</p>\n<h4 id=\"增加组\"><a class=\"markdownIt-Anchor\" href=\"#增加组\"></a> 增加组</h4>\n<p>groupadd  组名</p>\n<p><strong>案例演示</strong>（创建一个组）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522104425849.png\" alt=\"image-20210522104425849\" /></p>\n<h4 id=\"删除组\"><a class=\"markdownIt-Anchor\" href=\"#删除组\"></a> 删除组</h4>\n<p>指令（基本语法）</p>\n<p>groupdel  组名</p>\n<p><strong>案例演示</strong></p>\n<p>增加用户时直接加上组</p>\n<ul>\n<li>\n<p>指令（基本语法)</p>\n<p>useradd -g 用户组   用户名</p>\n<p>案例演示</p>\n<p>增加一个用户zwj，直接将zwj指定到wudang</p>\n<p>步骤如下演示</p>\n</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522105120132.png\" alt=\"image-20210522105120132\" /></p>\n<h4 id=\"修改用户组\"><a class=\"markdownIt-Anchor\" href=\"#修改用户组\"></a> 修改用户组</h4>\n<p>指令（基本语法）</p>\n<p>usermod    -g   用户组（新的用户组）  用户名</p>\n<p><strong>案例演示</strong></p>\n<p>创建一个shaolin组，将zwj修改到shaolin</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522105739973.png\" alt=\"image-20210522105739973\" /></p>\n<h2 id=\"解释指令man\"><a class=\"markdownIt-Anchor\" href=\"#解释指令man\"></a> 解释指令man</h2>\n<pre class=\"highlight\"><code class=\"bash\">man + 指令  表示的是查看这个指令的用法以及意思\n有问题问男人\n</code></pre>\n<h1 id=\"linux实操篇-实用指令\"><a class=\"markdownIt-Anchor\" href=\"#linux实操篇-实用指令\"></a> Linux实操篇   实用指令</h1>\n<h2 id=\"指定运行级别七个级别\"><a class=\"markdownIt-Anchor\" href=\"#指定运行级别七个级别\"></a> 指定运行级别（七个级别）</h2>\n<h3 id=\"运行级别的示意图centos6\"><a class=\"markdownIt-Anchor\" href=\"#运行级别的示意图centos6\"></a> 运行级别的示意图（centos6）</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522204033286.png\" alt=\"image-20210522204033286\" /></p>\n<h2 id=\"切换到指定运行级别的指令\"><a class=\"markdownIt-Anchor\" href=\"#切换到指定运行级别的指令\"></a> 切换到指定运行级别的指令</h2>\n<h3 id=\"基本语法-2\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-2\"></a> 基本语法</h3>\n<p>init[0123456]</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210522204639476.png\" alt=\"image-20210522204639476\" /></p>\n<h3 id=\"应用实例\"><a class=\"markdownIt-Anchor\" href=\"#应用实例\"></a> 应用实例</h3>\n<p>案例1：通过init来切换不同的运行级别，比如从5-----&gt;3，然后关机</p>\n<p>init   3</p>\n<p>init   5</p>\n<p>init   0</p>\n<h3 id=\"指定运行级别\"><a class=\"markdownIt-Anchor\" href=\"#指定运行级别\"></a> 指定运行级别</h3>\n<ul>\n<li><strong>面试题</strong></li>\n</ul>\n<p>如何找回root密码，如果不小心忘记了root密码，怎么找回？</p>\n<p>思路:进入到单用户模式，然后修改root密码。因为进入单用户模式，root不需要密码就可以登录。</p>\n<p>演示</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210523091441667.png\" alt=\"image-20210523091441667\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210523092131294.png\" alt=\"image-20210523092131294\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210523091556602.png\" alt=\"image-20210523091556602\" /></p>\n<p>开机  —&gt;在引导时输入  回车键   -----&gt;看到一个界面输入  e   ----&gt;看到一个新的界面，选中第二行（编辑内核）</p>\n<p>再输入   e  ----&gt;在这一行的最后输入  1 ，再输入回车键 -----&gt;再次输入b，这时就进入了单用户模式 再用paswd root进行更改密码（上面的图片没有截完整）</p>\n<p>2）请设置我们的运行级别，Linux运行后，直接进入到命令行界面，即进入到3运行级别vim  /etc/inittab</p>\n<p>将id：initdefault：这一行中的数字，5这个数改成3即可</p>\n<h2 id=\"centos7运行级别\"><a class=\"markdownIt-Anchor\" href=\"#centos7运行级别\"></a> centos7运行级别</h2>\n<h3 id=\"进入不同运行级别的方式\"><a class=\"markdownIt-Anchor\" href=\"#进入不同运行级别的方式\"></a> 进入不同运行级别的方式</h3>\n<pre class=\"highlight\"><code class=\"bash\">init 0   <span class=\"hljs-comment\">#关机</span>\ninit 3   <span class=\"hljs-comment\">#进入3级别字符界面</span>\ninit 5   <span class=\"hljs-comment\">#进入5级别图形界面</span>\ninit 6   <span class=\"hljs-comment\">#重启</span>\n</code></pre>\n<h3 id=\"设置系统默认的运行级别\"><a class=\"markdownIt-Anchor\" href=\"#设置系统默认的运行级别\"></a> 设置系统默认的运行级别</h3>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-comment\">#设置默认第三启动级别</span>\n[root@node5 ~]<span class=\"hljs-comment\"># systemctl set-default multi-user.target</span>\n\n<span class=\"hljs-comment\">#设置默认第五启动级别</span>\n[root@node5 ~]<span class=\"hljs-comment\"># systemctl set-default graphical.target</span>\n[root@node5 ~]<span class=\"hljs-comment\"># runlevel</span>\n3 5   <span class=\"hljs-comment\">#表示从3级别切换到了5级别</span>\n\n<span class=\"hljs-comment\">#查看当前默认的启动级别</span>\n[root@node5 ~]<span class=\"hljs-comment\"># systemctl get-default</span>\ngraphical.target\n\n[root@node5 ~]<span class=\"hljs-comment\"># systemctl get-default</span>\nmulti-user.target\n</code></pre>\n<h2 id=\"帮助指令\"><a class=\"markdownIt-Anchor\" href=\"#帮助指令\"></a> 帮助指令</h2>\n<h3 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\"></a> 介绍</h3>\n<p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解指令的使用方法。</p>\n<h3 id=\"man基本语法\"><a class=\"markdownIt-Anchor\" href=\"#man基本语法\"></a> man基本语法</h3>\n<ul>\n<li>man[命令或配置文件]（功能描述：获得帮助信息）</li>\n</ul>\n<h3 id=\"应用实例-2\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-2\"></a> 应用实例</h3>\n<p>案例：查看ls命令的帮助信息</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524090540904.png\" alt=\"image-20210524090540904\" /></p>\n<p>help指令</p>\n<ul>\n<li>\n<p>基本语法</p>\n</li>\n<li>\n<p>help  命令（功能描述，获得shell内置命令的帮助信息）</p>\n</li>\n<li>\n<p>应用实例</p>\n<p>​\t\t案例：查看cd命令的帮助信息</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524091140179.png\" alt=\"image-20210524091140179\" /></p>\n</li>\n</ul>\n<h1 id=\"文件目录类\"><a class=\"markdownIt-Anchor\" href=\"#文件目录类\"></a> 文件目录类</h1>\n<h2 id=\"目录结构的基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#目录结构的基本介绍\"></a> 目录结构的基本介绍</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524180130847.png\" alt=\" \" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/d0c50-linux2bfile2bsystem2bhierarchy.jpg\" alt=\"d0c50-linux2bfile2bsystem2bhierarchy\" /></p>\n<h2 id=\"pwd指令\"><a class=\"markdownIt-Anchor\" href=\"#pwd指令\"></a> pwd指令</h2>\n<h3 id=\"基本语法-3\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-3\"></a> 基本语法</h3>\n<p>pwd（功能描述：显示当前工作目录的绝对路径）</p>\n<h3 id=\"应用案例\"><a class=\"markdownIt-Anchor\" href=\"#应用案例\"></a> 应用案例</h3>\n<ul>\n<li>案例：显示当前工作目录的绝对路径</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524180318080.png\" alt=\"image-20210524180318080\" /></p>\n<h2 id=\"ls指令\"><a class=\"markdownIt-Anchor\" href=\"#ls指令\"></a> ls指令</h2>\n<h3 id=\"基本语法-4\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-4\"></a> 基本语法</h3>\n<pre><code>\tls  [选项]   [目录或是文件]\n</code></pre>\n<h3 id=\"常用选项\"><a class=\"markdownIt-Anchor\" href=\"#常用选项\"></a> 常用选项</h3>\n<p>​    \t-a   ：显示当前目录所有的文件和目录，<strong>包括隐藏的</strong>。</p>\n<p>​\t\t-l\t：以列表的方式显示信息</p>\n<h3 id=\"应用实例-3\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-3\"></a> 应用实例</h3>\n<p>​\t\t案例：查看当前目录所有内容信息</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524181654591.png\" alt=\"image-20210524181654591\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/image-20210524181749175.png\" alt=\"image-20210524181749175\" /></p>\n<h2 id=\"cd指令\"><a class=\"markdownIt-Anchor\" href=\"#cd指令\"></a> cd指令</h2>\n<h3 id=\"基本语法-5\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-5\"></a> 基本语法</h3>\n<ul>\n<li>cd\t[参数]\t\t\t（功能描述：切换到指定目录）</li>\n</ul>\n<h3 id=\"绝对和相对路径\"><a class=\"markdownIt-Anchor\" href=\"#绝对和相对路径\"></a> <strong>绝对和相对路径</strong></h3>\n<p>重点是脑海中要有一个目录树</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525083657.png\" alt=\"image-20210525083654467\" /></p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> ~ 或者<span class=\"hljs-built_in\">cd</span>：  回到自己的家目录(home目录)\n<span class=\"hljs-built_in\">cd</span> ..回到当前目录的上一级目录  \n<span class=\"hljs-built_in\">cd</span> . 代表的是当前路径\n</code></pre>\n<p><strong>思考题：</strong></p>\n<p>1）当前工作目录是/root，我们希望进入到/home下</p>\n<p><strong><font color='red'>绝对路径：</font></strong>/home，即从<font color='orange'>根目录</font>开始定位。</p>\n<p><strong><font color='red'>相对路径</font></strong>：. ./home（. .代表回到上级目录，然后再去找到home目录，<font color='orange'>从当前工作目录</font>开始定位到需要的目录去）</p>\n<h3 id=\"应用实例-4\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-4\"></a> 应用实例</h3>\n<p>案例1：使用绝对路径切换到root目录</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> /root\n</code></pre>\n<p>案例2：使用相对路径切换到/root目录</p>\n<p>这里我们要知道该用户目前在哪个目录下，才能写出这个指令，假设在/usr/lib</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> ../../root\n</code></pre>\n<p><font size=4px color='red'>非常重要：. .</font>代表的是上级目录(在<font color='orange'>相对路径</font>中)</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> ../home\t\n</code></pre>\n<p>案例3：表示回到当前目录的上一级目录</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> ..\n</code></pre>\n<p>案例4：回到家目录</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span>\n<span class=\"hljs-built_in\">cd</span> ~\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525083529.png\" alt=\"image-20210525083526253\" /></p>\n<h2 id=\"mkdir指令\"><a class=\"markdownIt-Anchor\" href=\"#mkdir指令\"></a> mkdir指令</h2>\n<ul>\n<li>mkdir指令用于创建目录（make directory）</li>\n</ul>\n<h3 id=\"基本语法-6\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-6\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">mkdir [选项]  要创建的目录\n</code></pre>\n<h3 id=\"案例\"><a class=\"markdownIt-Anchor\" href=\"#案例\"></a> 案例</h3>\n<h4 id=\"一次性创建单个目录\"><a class=\"markdownIt-Anchor\" href=\"#一次性创建单个目录\"></a> 一次性创建单个目录</h4>\n<p>在home目录下创建pig目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525084517.png\" alt=\"image-20210525084515832\" /></p>\n<h4 id=\"一次性创建多级目录\"><a class=\"markdownIt-Anchor\" href=\"#一次性创建多级目录\"></a> 一次性创建多级目录</h4>\n<p>在home目录下同时创建animal，同时创建tiger，记住<font color='red'>创建多级目录</font>要带上<font color='orange'>-p这个选项</font></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525084736.png\" alt=\"image-20210525084731183\" /></p>\n<h2 id=\"rmdir指令\"><a class=\"markdownIt-Anchor\" href=\"#rmdir指令\"></a> rmdir指令</h2>\n<h3 id=\"介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#介绍-2\"></a> 介绍</h3>\n<pre class=\"highlight\"><code class=\"bash\">rmdir 指令删除空目录\n</code></pre>\n<h3 id=\"应用实例-5\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-5\"></a> 应用实例</h3>\n<ul>\n<li>案例一：删除一个目录 /home/pig</li>\n<li><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525103102.png\" alt=\"image-20210525103052767\" /></li>\n</ul>\n<h3 id=\"font-colorred使用细节font\"><a class=\"markdownIt-Anchor\" href=\"#font-colorred使用细节font\"></a> <font color='red'>使用细节</font></h3>\n<p>rmdir删除的是空目录，如果目录下有内容时无法删除。</p>\n<p><font color='red'>提示</font>：如果需要删除的非空目录，如要使用<font size=25px color='red'>rm  -rf</font>要删除的目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525164146.png\" alt=\"image-20210525164144426\" /></p>\n<h2 id=\"touch指令\"><a class=\"markdownIt-Anchor\" href=\"#touch指令\"></a> touch指令</h2>\n<h3 id=\"介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#介绍-3\"></a> 介绍</h3>\n<ul>\n<li>touch指令创建空文件</li>\n</ul>\n<h3 id=\"基本语法-7\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-7\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">touch   文件名称(后面可以接多个文件名，用于创建多个文件)\t\n</code></pre>\n<h3 id=\"应用实例-6\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-6\"></a> 应用实例</h3>\n<ul>\n<li>案例一：创建一个空的hello.txt</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525164658.png\" alt=\"image-20210525164656803\" /></p>\n<ul>\n<li>案例二：创建多个文件夹</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525164955.png\" alt=\"image-20210525164953364\" /></p>\n<h2 id=\"cp指令重要\"><a class=\"markdownIt-Anchor\" href=\"#cp指令重要\"></a> cp指令（重要）</h2>\n<h3 id=\"介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#介绍-4\"></a> 介绍</h3>\n<ul>\n<li>cp指令拷贝文件到指定目录(cp就是copy)</li>\n</ul>\n<h3 id=\"基本语法-8\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-8\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">cp [选项] <span class=\"hljs-built_in\">source</span> dest    （<span class=\"hljs-built_in\">source</span>就是源文件的位置，dest就是要拷贝的目标文件的位置）\n常用选项\n-r：递归复制整个文件夹\n</code></pre>\n<h3 id=\"应用实例-7\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-7\"></a> 应用实例</h3>\n<ul>\n<li>\n<p>案例一：将/home/aaa.txt拷贝到/home/bbb目录下面</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210525170528.png\" alt=\"image-20210525170523307\" /></p>\n</li>\n<li>\n<p>案例二：递归复制整个文件夹，举例</p>\n</li>\n</ul>\n<p>将/home/test<font size=5px color='red'>整个目录拷贝</font>到/home/zwj目录(用<font color='orange'>-r</font>表示递归复制)</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528175624.png\" alt=\"image-20210525171619686\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210729104257.png\" alt=\"image-20210729104248532\" /></p>\n<h3 id=\"使用细节\"><a class=\"markdownIt-Anchor\" href=\"#使用细节\"></a> 使用细节</h3>\n<ul>\n<li>强制复制不提示方法：\\cp</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173714.png\" alt=\"image-20210526173712937\" /></p>\n<p><strong>技术小技巧</strong></p>\n<p>可以通过 上下箭头键，调出原来使用过的指令。</p>\n<h2 id=\"rm指令\"><a class=\"markdownIt-Anchor\" href=\"#rm指令\"></a> rm指令</h2>\n<h3 id=\"基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍\"></a> 基本介绍</h3>\n<p>rm指令移除文件或目录</p>\n<h3 id=\"基本语法-9\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-9\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">rm [选项] 要删除的文件或目录\n常用选项\n-r：递归删除整个文件夹\n-f：强制删除不提示\n</code></pre>\n<h3 id=\"应用实例-8\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-8\"></a> 应用实例</h3>\n<p>案例一：将/home/aaa.txt删除</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173806.png\" alt=\"image-20210526173805144\" /></p>\n<p>案例二：递归删除整个文件夹/home/bbb</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173817.png\" alt=\"image-20210526173816579\" /></p>\n<ul>\n<li><font color='red'>使用细节</font></li>\n</ul>\n<p><font color='red'>强制删除</font>不提示的方法：<font color='orange'>带上-f参数</font>即可</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173826.png\" alt=\"image-20210526173824951\" /></p>\n<h2 id=\"mv指令\"><a class=\"markdownIt-Anchor\" href=\"#mv指令\"></a> mv指令</h2>\n<h3 id=\"基本介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-2\"></a> 基本介绍</h3>\n<p>mv移动文件与目录或重命名（move）</p>\n<h3 id=\"基本语法-10\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-10\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">mv oldNameFile newNameFile   (功能描述：重命名)可以理解为，把当前文件夹下的oldNameFile，移动到当前目录下面，发现已经有了，就是重名了\nmv/temp/movefile/targetFolder  (功能描述，移动文件)\n</code></pre>\n<h3 id=\"应用实例-9\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-9\"></a> 应用实例</h3>\n<p>案例一：将\t/home/aaa.txt文件  重新命名为pig.txt</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173837.png\" alt=\"image-20210526173836313\" /></p>\n<p>案例二：将/home/pig.txt文件移动到 /root目录下</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526173846.png\" alt=\"image-20210526173845362\" /></p>\n<h2 id=\"cat指令\"><a class=\"markdownIt-Anchor\" href=\"#cat指令\"></a> cat指令</h2>\n<h3 id=\"基本介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-3\"></a> 基本介绍</h3>\n<p>cat 查看文件内容，是以<font color='red'>只读的方式打开</font></p>\n<h3 id=\"基本语法-11\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-11\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">cat [选项]  要查看的文件\t\n常用选项\n-n  :   显示行号\n</code></pre>\n<h3 id=\"应用实例-10\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-10\"></a> 应用实例</h3>\n<p>案例一：/etc /profile   文件内容，并显示行号</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210526213648.png\" alt=\"image-20210526213646596\" /></p>\n<h3 id=\"使用细节-2\"><a class=\"markdownIt-Anchor\" href=\"#使用细节-2\"></a> 使用细节</h3>\n<p>cat<font color='red'>只能浏览文件</font>，而<font color='orange'>不能修改文件</font>，为了浏览方便，一般会带上  <font color='red'> 管道命令 | more</font></p>\n<p>cat 文件名  | more[分页浏览]</p>\n<h2 id=\"more指令\"><a class=\"markdownIt-Anchor\" href=\"#more指令\"></a> more指令</h2>\n<h3 id=\"基本介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-4\"></a> 基本介绍</h3>\n<p>more指令是一个基于VI编辑器的文本过滤器，它以<font color='red'>全屏幕的方式按页显示文本文件的内容</font>。</p>\n<p>more指令中内置了若干快捷键，详见操作说明。</p>\n<h3 id=\"基本语法-12\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-12\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">more    要查看的文件\n</code></pre>\n<h3 id=\"操作说明\"><a class=\"markdownIt-Anchor\" href=\"#操作说明\"></a> 操作说明</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空白键（space）</td>\n<td>代表向下翻页</td>\n</tr>\n<tr>\n<td>Enter</td>\n<td>代表向下翻[一行]</td>\n</tr>\n<tr>\n<td>q</td>\n<td>代表立刻离开more，不再显示文件内容</td>\n</tr>\n<tr>\n<td>Ctrl+F</td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td>Ctrl+B</td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td>=</td>\n<td>输出当前的行号</td>\n</tr>\n<tr>\n<td>：f</td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"less指令\"><a class=\"markdownIt-Anchor\" href=\"#less指令\"></a> less指令</h2>\n<h3 id=\"基本介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-5\"></a> 基本介绍</h3>\n<p>less指令用来<font color='red'>分屏查看文件的内容</font>，它的功能与more指令类似。但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，<font color='red'>并不是将整个文件加载之后才显示</font>，而是根据现实需要加载内容，<font color='red'>对于显示大型文件具有较高的效率。</font></p>\n<h3 id=\"基本语法-13\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-13\"></a> 基本语法</h3>\n<p>less要查看的文件</p>\n<h3 id=\"操作说明-2\"><a class=\"markdownIt-Anchor\" href=\"#操作说明-2\"></a> 操作说明</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空白键</td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td>[pagedown]</td>\n<td>向下翻的一页</td>\n</tr>\n<tr>\n<td>[pageup]</td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td>/字串</td>\n<td>向下搜寻[字串]的功能：n：向下查找    N：向上查找</td>\n</tr>\n<tr>\n<td>？字串</td>\n<td>向上搜寻[字串]的功能：n：向上查找    N：向下查找</td>\n</tr>\n<tr>\n<td>q</td>\n<td>离开less这个程序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"应用实例-11\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-11\"></a> 应用实例</h3>\n<p>案例：采用less查看一个大文件文件/opt/金庸-射雕英雄传txt精校本.txt</p>\n<h2 id=\"指令重定向和指令追加\"><a class=\"markdownIt-Anchor\" href=\"#指令重定向和指令追加\"></a> &gt;指令重定向和&gt;&gt;指令追加</h2>\n<h3 id=\"基本介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-6\"></a> 基本介绍</h3>\n<p>&gt;输出<font color='red'>重定向</font>  和&gt;&gt;<font color='red'>追加</font>（追加到文件末尾）</p>\n<p>输出重定向：会将原来的文件内容覆盖</p>\n<p>追加：不会覆盖原来的文件的内容而是追加到文件的尾部</p>\n<h3 id=\"基本语法-14\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-14\"></a> 基本语法</h3>\n<blockquote>\n<p>1）ls  -l &gt;  文件   （功能描述：列表内容写入到文件a.txt中（覆盖写））</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210527170609.png\" alt=\"image-20210527170606573\" /></p>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>ls -al &gt;&gt;  文件   （功能描述：列表内容追加入到文件a.txt末尾）</li>\n</ol>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210527171114.png\" alt=\"image-20210527171112884\" /></p>\n<p>说明：ls  -l  &gt; a.txt，将ls -l显示的内容覆盖写入到a.txt文件中，如果该文件不存在则创建该文件，反之，则覆盖</p>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>cat   文件1&gt; 文件2   （功能描述：将文件1内容覆盖到文件2）</li>\n</ol>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528104008.png\" alt=\"image-20210528104007264\" /></p>\n</blockquote>\n<blockquote>\n<p>4)echo  “内容”  &gt;&gt; 文件</p>\n</blockquote>\n<h3 id=\"应用实例-12\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-12\"></a> 应用实例</h3>\n<p>案例一：将/home目录下的文件列表写入到/home/info.txt中</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528104444.png\" alt=\"image-20210528104442325\" /></p>\n<p>案例二：将当前日历信息追加到/home/mycal文件中[提示cal]</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528104737.png\" alt=\"image-20210528104736235\" /></p>\n<h2 id=\"echo指令\"><a class=\"markdownIt-Anchor\" href=\"#echo指令\"></a> echo指令</h2>\n<h3 id=\"基本内容\"><a class=\"markdownIt-Anchor\" href=\"#基本内容\"></a> 基本内容</h3>\n<p>echo输出内容到控制台</p>\n<h3 id=\"基本语法-15\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-15\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">echo</span>  [选项]  [输出内容]\t\n</code></pre>\n<h3 id=\"应用实例-13\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-13\"></a> 应用实例</h3>\n<p>案例：使用echo指令输出环境变量 ，输出当前的环境的路径。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528111840.png\" alt=\"image-20210528111838308\" /></p>\n<p>案例：使用echo指令输出hello，world！</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528111931.png\" alt=\"image-20210528111930781\" /></p>\n<h2 id=\"head指令\"><a class=\"markdownIt-Anchor\" href=\"#head指令\"></a> head指令</h2>\n<h3 id=\"基本说明\"><a class=\"markdownIt-Anchor\" href=\"#基本说明\"></a> 基本说明</h3>\n<p>head用于显示文件的开头部分，默认情况下head显示文件的前10行内容</p>\n<h3 id=\"基本语法-16\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-16\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\"> head 文件   (功能描述：查看文件的头10行内容)\n</code></pre>\n<pre class=\"highlight\"><code class=\"bash\">head  -n 5 文件\t(功能描述：查看文件的头5行内容，5可以是任意数)\t\n</code></pre>\n<h3 id=\"应用实例-14\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-14\"></a> 应用实例</h3>\n<p>案例：查看\t/etc/profile的前面5行代码</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528123338.png\" alt=\"image-20210528123336898\" /></p>\n<h2 id=\"tail指令\"><a class=\"markdownIt-Anchor\" href=\"#tail指令\"></a> tail指令</h2>\n<h3 id=\"基本介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-7\"></a> 基本介绍</h3>\n<p>tail用于输出文件中末尾的内容，默认情况下tail显示文件的后10行内容。</p>\n<h3 id=\"基本语法-17\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-17\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">tail  文件   \t（功能描述：查看文件后10行内容）\ntail -n 5 文件\t（功能描述：查看文件的后5行内容，5可以是任意数）\ntail  -f   文件    (功能描述：实时追踪该文档的所有更新)（工作中经常使用）\n\nCtrl+c退出追踪\n</code></pre>\n<h3 id=\"使用示例\"><a class=\"markdownIt-Anchor\" href=\"#使用示例\"></a> 使用示例</h3>\n<p>案例一：查看/etc/profile最后5行的代码</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528124113.png\" alt=\"image-20210528124112154\" /></p>\n<p>案例二：实时监控mydate.txt，看看到文件有变化时，是否会看到，实时的追加日期</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528124520.png\" alt=\"image-20210528124518287\" /></p>\n<h2 id=\"ln指令了解\"><a class=\"markdownIt-Anchor\" href=\"#ln指令了解\"></a> ln指令（了解）</h2>\n<h3 id=\"基本介绍-8\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-8\"></a> 基本介绍</h3>\n<p>软链接也叫符号链接，类似于<font color='red'>windows里面的快捷方式</font>，主要是存放了链接其他文件的路径</p>\n<h3 id=\"基本语法-18\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-18\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">ln -s [源文件或目录] [软链接名]  （功能描述：给源文件创建一个软连接）\n</code></pre>\n<h3 id=\"应用实例-15\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-15\"></a> 应用实例</h3>\n<p>案例1：在/home目录下创建一个软链接linkToRoot，连接到/root目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528164522.png\" alt=\"image-20210528164520885\" /></p>\n<p>案例2：删除软链接linkToRoot</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528164927.png\" alt=\"image-20210528164926717\" /></p>\n<h3 id=\"细节说明\"><a class=\"markdownIt-Anchor\" href=\"#细节说明\"></a> 细节说明</h3>\n<p>当我们使用<font color='red'>pwd指令查看</font>目录时，仍然看到的是软链接所在目录。</p>\n<h2 id=\"history指令\"><a class=\"markdownIt-Anchor\" href=\"#history指令\"></a> history指令</h2>\n<h3 id=\"基本介绍-9\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-9\"></a> 基本介绍</h3>\n<p>查看已经执行过的命令，也可以执行历史指令</p>\n<h3 id=\"基本语法-19\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-19\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">history</span>  (功能描述：查看已经执行过的历史命令)\nhistroy  number\t(显示最近number条指令)\n！number \t(执行第number条指令)\n</code></pre>\n<h3 id=\"应用实例-16\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-16\"></a> 应用实例</h3>\n<p>案例一：显示所有的历史命令</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528165919.png\" alt=\"image-20210528165918103\" /></p>\n<p>案例二：显示最近使用的10个命令</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528170027.png\" alt=\"image-20210528170026329\" /></p>\n<p>案例三：执行历史编号为5的指令</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528170241.png\" alt=\"image-20210528170240226\" /></p>\n<h1 id=\"时间日期类相关的指令\"><a class=\"markdownIt-Anchor\" href=\"#时间日期类相关的指令\"></a> 时间日期类相关的指令</h1>\n<h2 id=\"date指令-显示当前日期\"><a class=\"markdownIt-Anchor\" href=\"#date指令-显示当前日期\"></a> date指令-显示当前日期</h2>\n<h3 id=\"基本语法-20\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-20\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">date\t\t\t\t\t\t\t\t(功能描述：显示当前时间)\ndate +%Y\t\t\t\t\t\t\t(功能描述：显示当前年份)\ndate +%m\t\t\t\t\t\t\t(功能描述：显示当前月份)\ndate +%d\t\t\t\t\t\t\t(功能描述：显示当前是哪一天)\ndate +<span class=\"hljs-string\">\"%Y-%m-%d %H:%M:%s\"</span> \t\t\t  (功能描述：显示年月日时分秒)\n注意：这个+一定得加上\n</code></pre>\n<h3 id=\"应用实例-17\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-17\"></a> 应用实例</h3>\n<p>案例一：显示当前时间信息</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528171924.png\" alt=\"image-20210528171923814\" /></p>\n<p>案例二：显示当前时间年月日</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528172058.png\" alt=\"image-20210528172057231\" /></p>\n<p>案例三：显示档期那时间年月日时分秒</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528172410.png\" alt=\"image-20210528172409082\" /></p>\n<h2 id=\"date指令-font-colorred设置日期font\"><a class=\"markdownIt-Anchor\" href=\"#date指令-font-colorred设置日期font\"></a> date指令-<font color='red'>设置日期</font></h2>\n<h3 id=\"基本语法-21\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-21\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">date  -s  字符串时间\n</code></pre>\n<h3 id=\"应用实例-18\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-18\"></a> 应用实例</h3>\n<p>案例一：设置系统当前时间，比如设置成2021-5-28 11:22:22</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528172859.png\" alt=\"image-20210528172858196\" /></p>\n<h2 id=\"cal指令\"><a class=\"markdownIt-Anchor\" href=\"#cal指令\"></a> cal指令</h2>\n<h3 id=\"基本介绍-10\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-10\"></a> 基本介绍</h3>\n<p>查看日历指令</p>\n<h3 id=\"基本语法-22\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-22\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">cal [选项]   (功能描述：不加选项，显示本月日历)  canlender的简写\n</code></pre>\n<h3 id=\"应用实例-19\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-19\"></a> 应用实例</h3>\n<p>案例一：显示当前日历<br />\n<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528173844.png\" alt=\"image-20210528173842897\" /></p>\n<p>案例二：显示2020年日历</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528174005.png\" alt=\"image-20210528174004035\" /></p>\n<h1 id=\"搜索查找类\"><a class=\"markdownIt-Anchor\" href=\"#搜索查找类\"></a> 搜索查找类</h1>\n<h2 id=\"find指令\"><a class=\"markdownIt-Anchor\" href=\"#find指令\"></a> find指令</h2>\n<h3 id=\"基本介绍-11\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-11\"></a> 基本介绍</h3>\n<p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的<font color='red'>文件或者目录</font>显示在终端。</p>\n<h3 id=\"基本语法-23\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-23\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">find [搜索范围] [选项]\n</code></pre>\n<h3 id=\"选项说明\"><a class=\"markdownIt-Anchor\" href=\"#选项说明\"></a> 选项说明</h3>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-name&lt;查询方式&gt;</td>\n<td>按照指定的文件名查找模式查找文件</td>\n</tr>\n<tr>\n<td>-user&lt;用户名&gt;</td>\n<td>查找属于指定用户名地所有文件</td>\n</tr>\n<tr>\n<td>-size&lt;文件大小&gt;</td>\n<td>按照指定的文件大小查找文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"应用实例-20\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-20\"></a> 应用实例</h3>\n<p>案例一：按文件名：更具名称查找/home目录下的hello.txt文件</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528204923.png\" alt=\"image-20210528204921939\" /></p>\n<p>案例二：按拥有者：查找/opt目录下，用户名称为nobody的文件</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528205123.png\" alt=\"image-20210528205122566\" /></p>\n<p>案例三：查找整个linux系统下大于20M的文件（+n大于  -n小于  n等于，注意这里的<font color='red'>n表示的是数字</font>，单位可以根据实际情况来调整，k得用小写）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528205548.png\" alt=\"image-20210528205546326\" /></p>\n<p>案例四：查询小于20M的文件</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528205935.png\" alt=\"image-20210528205933051\" /></p>\n<p>案例五：查询根目录下面以txt后缀结尾的文件</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210528210725.png\" alt=\"image-20210528210722387\" /></p>\n<h2 id=\"locate指令\"><a class=\"markdownIt-Anchor\" href=\"#locate指令\"></a> locate指令</h2>\n<h3 id=\"基本介绍-12\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-12\"></a> 基本介绍</h3>\n<p>locate指令可以快速定位文件路径。locate指令利用实现建立的系统中所有文件名称以及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。</p>\n<h3 id=\"基本语法-24\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-24\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">locate  搜索文件\n</code></pre>\n<h3 id=\"特别说明\"><a class=\"markdownIt-Anchor\" href=\"#特别说明\"></a> 特别说明</h3>\n<p>由于locate指令基于数据进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p>\n<h3 id=\"应用实例-21\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-21\"></a> 应用实例</h3>\n<p>案例一：请使用locate指令快速定位hello.txt文件所在目录</p>\n<h2 id=\"grep指令和管道符号-font-colorred-font\"><a class=\"markdownIt-Anchor\" href=\"#grep指令和管道符号-font-colorred-font\"></a> grep指令和管道符号 <font color='red'> |</font></h2>\n<h3 id=\"基本介绍-13\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-13\"></a> 基本介绍</h3>\n<p>grep过滤查找，<font color='red'>管道符，&quot;|&quot;</font>，表示将前一个命令的处理结果输出传递给后面的命令处理。  （&quot;|&quot;,这后面的就是加上条件）</p>\n<h3 id=\"基本语法-25\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-25\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">grep [选项]  查找内容  源文件\n选项\t\t\t功能\n-n\t\t\t  显示匹配行以及行号。\n-i\t\t\t  忽略字母大小写\n</code></pre>\n<h3 id=\"应用实例-22\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-22\"></a> 应用实例</h3>\n<p>案例一：请在hello.txt文件中，查找&quot;yes&quot;所在行，并显示行号。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529085740.png\" alt=\"image-20210529085731997\" /></p>\n<h1 id=\"压缩和解压缩类\"><a class=\"markdownIt-Anchor\" href=\"#压缩和解压缩类\"></a> 压缩和解压缩类</h1>\n<h2 id=\"gzipgunzip-指令\"><a class=\"markdownIt-Anchor\" href=\"#gzipgunzip-指令\"></a> gzip/gunzip  指令</h2>\n<h3 id=\"基本介绍-14\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-14\"></a> 基本介绍</h3>\n<p>gzip用于压缩文件，gunzip用于解压</p>\n<h3 id=\"基本语法-26\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-26\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">gzip     文件   \t\t\t\t(功能描述：压缩文件，只能将文件压缩为*.gz文件)\ngunzip   文件.gz  \t\t\t(功能描述：解压缩文件命令)\n</code></pre>\n<h3 id=\"应用实例-23\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-23\"></a> 应用实例</h3>\n<p>案例一：gzip压缩，将/home下的hello.txt文件进行压缩</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529090606.png\" alt=\"image-20210529090605151\" /></p>\n<p>案例二：gunzip压缩，将/home下的hello.txt.gz文件进行解压缩</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529090744.png\" alt=\"image-20210529090743083\" /></p>\n<h3 id=\"细节说明-2\"><a class=\"markdownIt-Anchor\" href=\"#细节说明-2\"></a> 细节说明</h3>\n<p>当我们使用gzip对文件进行压缩后，不会保留原来的文件。</p>\n<h2 id=\"zipunzip指令\"><a class=\"markdownIt-Anchor\" href=\"#zipunzip指令\"></a> zip/unzip指令</h2>\n<h3 id=\"基本介绍-15\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-15\"></a> 基本介绍</h3>\n<p>zip用于压缩文件，unzip用于解压文件，这个在<font color='red'>项目打包发布中很有用的</font></p>\n<h3 id=\"基本语法-27\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-27\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">zip   [选项]   XXX.zip     将要压缩的内容  (功能描述：压缩文件和目录的命令)\nuzip  [选项]   XXX.zip\t(功能描述：解压文件)\t\nzip常用选项\n-r:  递归压缩，即压缩目录\nuzip的常用选项\n-d &lt;目录&gt; ：指定压缩后的文件的存放目录\n</code></pre>\n<h3 id=\"应用实例-24\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-24\"></a> 应用实例</h3>\n<p>案例一：将/home下的所有文件压缩成mypackage.zip</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529091849.png\" alt=\"image-20210529091848159\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529091917.png\" alt=\"image-20210529091915931\" /></p>\n<p>案例二：将mypackage.zip解压到/opt/tmp目录下</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210529092115.png\" alt=\"image-20210529092113961\" /></p>\n<h2 id=\"tar指令\"><a class=\"markdownIt-Anchor\" href=\"#tar指令\"></a> tar指令</h2>\n<h3 id=\"基本介绍-16\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-16\"></a> 基本介绍</h3>\n<p>tar指令是<strong>打包指令</strong>，最后打包后的文件是.tar.gz的文件。</p>\n<h3 id=\"基本语法-28\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-28\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">tar  [选项]  XXX.tar.gz   打包的内容\t(功能描述：打包目录，压缩后的文件格式.tar.gz)\n</code></pre>\n<ul>\n<li>选项说明</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>产生.tar打包文件</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细信息</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定压缩后的文件名</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>打包时同时压缩</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压.tar文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"应用实例-25\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-25\"></a> 应用实例</h3>\n<p>案例一：压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成a.tar.gz</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531170223.png\" alt=\"image-20210531170214643\" /></p>\n<p>案例二：将/home的文件夹压缩成myhome.tar.gz</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531170512.png\" alt=\"image-20210531170510021\" /></p>\n<p>案例三：将a.tar.gz解压到当前目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531171018.png\" alt=\"image-20210531171017011\" /></p>\n<p>案例四：将myhome.tar.gz解压到/opt/tmp2目录下</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531171601.png\" alt=\"image-20210531171600366\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">tar -zxvf 压缩包名字  -C 指定文件夹路径\n</code></pre>\n<h1 id=\"组管理和权限管理重难点\"><a class=\"markdownIt-Anchor\" href=\"#组管理和权限管理重难点\"></a> 组管理和权限管理（重难点）</h1>\n<h2 id=\"linux组的基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#linux组的基本介绍\"></a> Linux组的基本介绍</h2>\n<p>在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者、躲在组、其他组的概念。</p>\n<p>1）所有组</p>\n<p>2）所在组</p>\n<p>3）其他组</p>\n<p>4）改变用户所在组</p>\n<h2 id=\"文件-目录所有者\"><a class=\"markdownIt-Anchor\" href=\"#文件-目录所有者\"></a> 文件 / 目录所有者</h2>\n<h3 id=\"基本介绍-17\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-17\"></a> 基本介绍</h3>\n<p>一般文件的创建者，设创建了该文件，就自然成为了该文件的所有者。</p>\n<h3 id=\"查看文件的所有者\"><a class=\"markdownIt-Anchor\" href=\"#查看文件的所有者\"></a> 查看文件的所有者</h3>\n<pre class=\"highlight\"><code class=\"bash\">指令：    ls  -ahl\n</code></pre>\n<h3 id=\"应用实例-26\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-26\"></a> 应用实例</h3>\n<p>应用实例：  创建一个组police，再创建一个用户tom，然后使用tom来创建一个文件，看看情况如何</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531190844.png\" alt=\"image-20210531190841047\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531191140.png\" alt=\"image-20210531191138777\" /></p>\n<h3 id=\"修改文件所有者\"><a class=\"markdownIt-Anchor\" href=\"#修改文件所有者\"></a> 修改文件所有者</h3>\n<pre class=\"highlight\"><code class=\"bash\">指令 ： chown 用户名  文件名   (chown:就是change own)\n</code></pre>\n<h3 id=\"应用案例-2\"><a class=\"markdownIt-Anchor\" href=\"#应用案例-2\"></a> 应用案例</h3>\n<p>要求：使用root创建一个文件apple.txt，然后将所有者修改为tom</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531191946.png\" alt=\"image-20210531191945732\" /></p>\n<h2 id=\"组的创建\"><a class=\"markdownIt-Anchor\" href=\"#组的创建\"></a> 组的创建</h2>\n<h3 id=\"基本指令\"><a class=\"markdownIt-Anchor\" href=\"#基本指令\"></a> 基本指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">groupadd   组名\t\n</code></pre>\n<h3 id=\"应用实例-27\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-27\"></a> 应用实例</h3>\n<p>创建一个组，monster</p>\n<p>创建一个用户fox，并放入到monster组中</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210531192445.png\" alt=\"image-20210531192425168\" /></p>\n<h2 id=\"文件目录所在组\"><a class=\"markdownIt-Anchor\" href=\"#文件目录所在组\"></a> 文件/目录所在组</h2>\n<p>当某个<font color='red'>用户创建了一个文件</font>后，<font color='red'>默认</font>这个<font color='red'>文件的所在组</font>就是该<font color='orange'>用户所在的组</font>。</p>\n<h3 id=\"查看文件目录所在组\"><a class=\"markdownIt-Anchor\" href=\"#查看文件目录所在组\"></a> 查看文件/目录所在组</h3>\n<h4 id=\"基本指令-2\"><a class=\"markdownIt-Anchor\" href=\"#基本指令-2\"></a> 基本指令</h4>\n<pre class=\"highlight\"><code class=\"bash\">ls -ahl\n</code></pre>\n<h4 id=\"应用实例-28\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-28\"></a> 应用实例</h4>\n<h3 id=\"font-colorred修改文件font所在组\"><a class=\"markdownIt-Anchor\" href=\"#font-colorred修改文件font所在组\"></a> <font color='red'>修改文件</font>所在组</h3>\n<h4 id=\"基本指令-3\"><a class=\"markdownIt-Anchor\" href=\"#基本指令-3\"></a> 基本指令</h4>\n<pre class=\"highlight\"><code class=\"bash\">chgrp  组名   文件名    (chgrp   change group)\n\n\nlinux下命令“ll”是“ls -l<span class=\"hljs-string\">\"的别名。别名相当于windows里的快捷方式。\n\n所以\"</span>ll<span class=\"hljs-string\">\"和“ls -l”的功能是相同的。\n所以\"</span>ll<span class=\"hljs-string\">\"和\"</span>ls<span class=\"hljs-string\">\"的区别其实是“ls”和\"</span>ls -l<span class=\"hljs-string\">\"的区别。\n”ls“是显示当前目录下文件，”ls -l“是显示当前目录下文件详细信息。\n</span></code></pre>\n<h4 id=\"应用实例-29\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-29\"></a> 应用实例</h4>\n<p>使用root用户创建文件orange.txt，看看当前文件属于哪个组，然后将这个文件所在的组修改到police组</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605081758.png\" alt=\"image-20210605081750518\" /></p>\n<h2 id=\"其他组\"><a class=\"markdownIt-Anchor\" href=\"#其他组\"></a> 其他组</h2>\n<p>出去文件的所有者和所在组的用户外，系统的其他用户都是文件的其他在。</p>\n<h2 id=\"改变用户所在组\"><a class=\"markdownIt-Anchor\" href=\"#改变用户所在组\"></a> 改变用户所在组</h2>\n<h3 id=\"基本介绍-18\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-18\"></a> 基本介绍</h3>\n<p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限才可以改变某个用户所在的组。</p>\n<h3 id=\"改变用户所在组指令\"><a class=\"markdownIt-Anchor\" href=\"#改变用户所在组指令\"></a> 改变用户所在组指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">usermod -g   组名 用户名\nusermod -d   目录名  用户名  改变该用户登陆的初始目录 \n</code></pre>\n<h3 id=\"应用实例-30\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-30\"></a> 应用实例</h3>\n<p>创建一个土匪组（bandit）将tom这个用户从原来所在的police组，修改到bandit（土匪）组。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605083001.png\" alt=\"image-20210605082959023\" /></p>\n<h2 id=\"权限的基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#权限的基本介绍\"></a> 权限的基本介绍</h2>\n<h3 id=\"linux的权限不是很细致只有font-colorredrwxfont三种\"><a class=\"markdownIt-Anchor\" href=\"#linux的权限不是很细致只有font-colorredrwxfont三种\"></a> Linux的权限不是很细致，只有<font color='red'>RWX</font>三种</h3>\n<p><font color='red'>r(Read，读取)</font>：对文件而言，具有读取文件内容的权限；对目录来说，具有<font color='red'><strong>浏览</strong>目录</font>的权限。<br />\n<font color='red'>w(Write,写入)</font>：对文件而言，具有<font color='red'>新增,修改,删除文件内容</font>的权限；对目录来说，具有<font color='red'>新建，删除，修改，移动目录</font>内文件的权限。<br />\n<font color='red'>x(eXecute，执行)：</font>对文件而言，具有执行文件的权限；对目录了来说该<font color='red'>用户具有<strong>进入</strong>目录的权限。</font><br />\n1、目录的只读访问不允许使用cd进入目录，必须要有执行的权限才能进入。<br />\n2、只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限。<br />\n3、一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外<br />\n4、目录的w位不设置，即使你拥有目录中某文件的w权限也不能写该文件</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608204827.jpg\" alt=\"20181230195451513\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608205159.png\" alt=\"image-20210608205158166\" /></p>\n<h2 id=\"rwx权限详解\"><a class=\"markdownIt-Anchor\" href=\"#rwx权限详解\"></a> rwx权限详解</h2>\n<h3 id=\"rwx作用到font-colorred文件font\"><a class=\"markdownIt-Anchor\" href=\"#rwx作用到font-colorred文件font\"></a> rwx作用到<font color='red'>文件</font></h3>\n<pre class=\"highlight\"><code class=\"bash\">[r]代表可读(<span class=\"hljs-built_in\">read</span>):可以读取，查看\n[w]代表可写(write):可以修改，但是不代表可以删除文件，删除文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.\n</code></pre>\n<h3 id=\"rwx作用到font-colorred目录font\"><a class=\"markdownIt-Anchor\" href=\"#rwx作用到font-colorred目录font\"></a> rwx作用到<font color='red'>目录</font></h3>\n<pre class=\"highlight\"><code class=\"bash\">[r]代表可读(<span class=\"hljs-built_in\">read</span>):可以读取，ls查看目录内容\n[w]代表可写(write):可以修改，目录内创建+删除+重命名目录\n[x]代表可执行(execute):可以进入该目录\n</code></pre>\n<h3 id=\"文件及其目录权限实际案例\"><a class=\"markdownIt-Anchor\" href=\"#文件及其目录权限实际案例\"></a> 文件及其目录权限实际案例</h3>\n<p><strong>ls -l中显示的内容如下</strong>：</p>\n<p>-rwx<font color='red'>rw-</font>r-- 1 root root  1213  Feb  2  09 : 39  abc</p>\n<p>10个字符确定不同用户能对文件干什么</p>\n<p>第一个字符代表文件的类型：文件（-），目录（d），链接（l）</p>\n<p>其余字符每3个一组（rwx）读（r）写（w）执行（x）</p>\n<p>第一组rwx：文件拥有者同一组的用户权限是<font color='red'>读、写和执行</font></p>\n<p>第二组<font color='red'>rw-</font>： 与文件拥有者同一组的用户的权限是<font color='red'>读、写但是不能执行</font></p>\n<p>第三组r–：不与文件拥有者同组的其他用户的权限是<font color='red'>读不能写和执行</font></p>\n<p>**可用数字表示为：**r=4，w=2，x=1因此rwx=4+2+1=7  （用数字表示权限）</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>文件：硬链接数或目录：子目录数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>root</td>\n<td>用户</td>\n</tr>\n<tr>\n<td>root</td>\n<td>组</td>\n</tr>\n<tr>\n<td>1213</td>\n<td>文件大小（字节），如果是文件夹，显示4096字节</td>\n</tr>\n<tr>\n<td>Feb 2 09 : 39</td>\n<td>最后修改时间</td>\n</tr>\n<tr>\n<td>abc</td>\n<td>文件名</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修改权限font-colorred-chmodfontchange-modify的意思\"><a class=\"markdownIt-Anchor\" href=\"#修改权限font-colorred-chmodfontchange-modify的意思\"></a> 修改权限<font color='red'> -chmod</font>（change  modify的意思）</h2>\n<h3 id=\"基本说明-2\"><a class=\"markdownIt-Anchor\" href=\"#基本说明-2\"></a> 基本说明</h3>\n<p>通过chmod指令，可以修改文件或者目录的权限。</p>\n<h3 id=\"第一种方式-变更权限\"><a class=\"markdownIt-Anchor\" href=\"#第一种方式-变更权限\"></a> 第一种方式：+、-、=  变更权限</h3>\n<pre class=\"highlight\"><code class=\"bash\">u：所有者   g：所有组   o:其他人   a：所有人（u、g、o的总和）\nchmod  u=rwx , g=rx , o=x文件目录名\nchmod  o+w  文件目录名\nchmod  a-x  文件目录名\n</code></pre>\n<h3 id=\"案例演示\"><a class=\"markdownIt-Anchor\" href=\"#案例演示\"></a> 案例演示</h3>\n<p>1）给abc文件的所有者读写执行权限，给所在组执行权限，给其他组的用户读执行权限。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605140748.png\" alt=\"image-20210605140747345\" /></p>\n<p>2）给abc文件的所有者出去执行的权限，增加组的用户写权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605140958.png\" alt=\"image-20210605140956725\" /></p>\n<p>3）给abc文件的所有用户添加读的权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605141130.png\" alt=\"image-20210605141129116\" /></p>\n<h3 id=\"第二种方式通过数字变更权限\"><a class=\"markdownIt-Anchor\" href=\"#第二种方式通过数字变更权限\"></a> 第二种方式：通过数字变更权限</h3>\n<p>r=4  w=2  x=1         rwx=4+2+1=7</p>\n<pre class=\"highlight\"><code class=\"bash\">chmod   u=rwx，g=rx，o=x   文件目录名\n相当于   chmod  751  文件名称\t\t\n</code></pre>\n<ul>\n<li><strong>案例演示</strong></li>\n</ul>\n<p>要求：将/home/abc.txt文件的权限修改为，<font color='red'>rwx</font> <font color='orange'>r-x</font>r-x，使用给数字的方式实现（这里面是每三个符号一组）</p>\n<p>rwx  =  4+2+1=7</p>\n<p>r-x=4+1=5</p>\n<p>r-x=4+1=5</p>\n<p>指令chmod 755 /home/abc.txt</p>\n<h2 id=\"修改文件所有者-chown\"><a class=\"markdownIt-Anchor\" href=\"#修改文件所有者-chown\"></a> 修改文件所有者-chown</h2>\n<h3 id=\"基本介绍-19\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-19\"></a> 基本介绍</h3>\n<p>chown newowner file  改变文件的所有者</p>\n<p>chown  newowner：newgroup  file   改变用户的所有者和所有组</p>\n<p>带上<font color='red'>-R</font>参数如果是目录  则使其下所有子文件或目标<font color='red'>递归</font>生效</p>\n<h3 id=\"案例演示-2\"><a class=\"markdownIt-Anchor\" href=\"#案例演示-2\"></a> 案例演示</h3>\n<p>1）请将/home/abc.txt文件的所有者修改为tom</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210605173227.png\" alt=\"image-20210605173226639\" /></p>\n<p>2）请将/home/kkk目录下所有的文件和目录的所有者都修改为zwj</p>\n<p>首先我们应该使用root用户来操作。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608082540.png\" alt=\"image-20210608082532219\" /></p>\n<h2 id=\"修改文件所在组-chgrp\"><a class=\"markdownIt-Anchor\" href=\"#修改文件所在组-chgrp\"></a> 修改文件所在组-chgrp</h2>\n<h3 id=\"基本介绍-20\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-20\"></a> 基本介绍</h3>\n<pre class=\"highlight\"><code class=\"bash\">chgrp [选项]  newgroup（改变文件的所有组） file  \n选项：-R表示递归修改其下所有子文件或者目录\n</code></pre>\n<h3 id=\"案例演示-3\"><a class=\"markdownIt-Anchor\" href=\"#案例演示-3\"></a> 案例演示</h3>\n<p>1）请将/home/abc.txt文件的所有组修改成bandit（土匪组）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608083310.png\" alt=\"image-20210608083308485\" /></p>\n<p>2）请将/home/kkk目录下的所有文件和目录的所在组都修改成bandit（土匪组）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608083456.png\" alt=\"image-20210608083455029\" /></p>\n<h2 id=\"最佳实践-警察和土匪游戏\"><a class=\"markdownIt-Anchor\" href=\"#最佳实践-警察和土匪游戏\"></a> 最佳实践-警察和土匪游戏</h2>\n<p>police  ，  bandit</p>\n<p>jack，jerry警察</p>\n<p>xh ， xq：土匪</p>\n<p>1）创建组</p>\n<pre class=\"highlight\"><code class=\"bash\">groupadd police\ngroupadd bandit\n</code></pre>\n<p>2）创建用户</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608104429.png\" alt=\"image-20210608104428477\" /></p>\n<p>将密码都指定为<font color='red'>123</font></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608104619.png\" alt=\"image-20210608104618827\" /></p>\n<p>3）jack创建一个文件，自己可以读写，本组人可以读，其他组人没有任何权限</p>\n<pre class=\"highlight\"><code class=\"bash\">chmod 640 jack01.txt\n也可以用 chmod o= jack01.txt\t \n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608105322.png\" alt=\"image-20210608105321299\" /></p>\n<p>4）jack修改该文件，让其他组人可以读。本组人可以读写</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608113126.png\" alt=\"image-20210608113125027\" /></p>\n<p>5）xq投靠警察，看看是否可以读写</p>\n<p>先用root修改xq的组：</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608155137.png\" alt=\"image-20210608155135961\" /></p>\n<p>再使用jack给他的家目录/home/jack所在组一个rx权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608160224.png\" alt=\"image-20210608160222949\" /></p>\n<p><img src=\"C:/Users/AppData/Roaming/Typora/typora-user-images/image-20210608155408201.png\" alt=\"image-20210608155408201\" /></p>\n<h2 id=\"文件联系权限管理font-colorred课后练习1font\"><a class=\"markdownIt-Anchor\" href=\"#文件联系权限管理font-colorred课后练习1font\"></a> 文件联系权限管理[<font color='red'>课后练习1</font>]</h2>\n<p>建立两个组（神仙，妖怪）</p>\n<p>建立四个用户（唐僧，悟空，八戒，沙僧）</p>\n<p>把悟空，八戒放在妖怪组，唐僧沙僧放进神仙组</p>\n<p>用悟空建立一个文件（monkey.java该文件要输出 i am monkey）</p>\n<p>给八戒一个rw的权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608165548.png\" alt=\"image-20210608165547626\" /></p>\n<p>唐僧沙僧对该文件没有权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608165642.png\" alt=\"image-20210608165641017\" /></p>\n<p>把沙僧放入妖怪组</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210608165902.png\" alt=\"image-20210608165901057\" /></p>\n<p>让沙僧修改该文件monkey，加入一句话（“我是沙僧，我是妖怪！”）;</p>\n<h2 id=\"文件联系权限管理font-colorred课后练习2font\"><a class=\"markdownIt-Anchor\" href=\"#文件联系权限管理font-colorred课后练习2font\"></a> 文件联系权限管理[<font color='red'>课后练习2</font>]</h2>\n<p>1）用root登录，建立用户mycentos，自己设定密码</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609083755.png\" alt=\"image-20210609083753792\" /></p>\n<p>2）用mycentos登录，在主目录下建立目录test/t11/t1</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609084052.png\" alt=\"image-20210609084051839\" /></p>\n<p>3）在t1中建立一个文本文件aa，用vi编辑器内容为ls -al</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609084200.png\" alt=\"image-20210609084159138\" /></p>\n<p>4）改变aa的权限为可执行文件[可以将当前日期追加到一个文件]，运行该文件./aa</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609084346.png\" alt=\"image-20210609084344890\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609084744.png\" alt=\"image-20210609084743768\" /></p>\n<p>5）删除新建立的目录test/t11/t1</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609084907.png\" alt=\"image-20210609084906028\" /></p>\n<p>6）删除用户mycentos以及其主目录中的内容</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609085331.png\" alt=\"image-20210609085329973\" /></p>\n<p>7）将Linux设置到图形界面</p>\n<p>8）重新启动Linux或关机</p>\n<pre class=\"highlight\"><code class=\"bash\">reboot 重启\nhalt 关机\n</code></pre>\n<h1 id=\"定时任务调度\"><a class=\"markdownIt-Anchor\" href=\"#定时任务调度\"></a> 定时任务调度</h1>\n<h2 id=\"crond任务调度\"><a class=\"markdownIt-Anchor\" href=\"#crond任务调度\"></a> crond任务调度</h2>\n<p>crond进行定时任务的设置</p>\n<h3 id=\"原理示意图\"><a class=\"markdownIt-Anchor\" href=\"#原理示意图\"></a> 原理示意图</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609105612.png\" alt=\"image-20210609105611466\" /></p>\n<h3 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h3>\n<p>任务调度是指在系统的某个时间执行的特定的命令或者程序。</p>\n<p>任务调度分类：1、系统工作：游戏重要的工作必须是周而复始的执行。比如病毒扫描等</p>\n<p>2、个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p>\n<h3 id=\"基本语法-29\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-29\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">crontab  [常用 选项]\n</code></pre>\n<h3 id=\"常用选项-2\"><a class=\"markdownIt-Anchor\" href=\"#常用选项-2\"></a> 常用选项</h3>\n<table>\n<thead>\n<tr>\n<th>-e</th>\n<th>编辑crontab定时任务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>查询crontab任务</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>删除当前用户所有的crontab任务</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"任务要求\"><a class=\"markdownIt-Anchor\" href=\"#任务要求\"></a> 任务要求</h3>\n<p>设置任务跳读文件：/etc/crontab</p>\n<p>设置个人任务调度。执行crontab -e 命令</p>\n<p>接着输入任务到调度文件</p>\n<p>如：*/1 ****ls -l  / etc /&gt;/ tmp/to.txt</p>\n<p>意思说每小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt命令</p>\n<h3 id=\"步骤如下\"><a class=\"markdownIt-Anchor\" href=\"#步骤如下\"></a> 步骤如下</h3>\n<pre class=\"highlight\"><code class=\"bash\">1) cron -e\n2) */1 * * * * ls -l /etc&gt;&gt; /tmp/to.txt\n3) 当保存后就退出程序\n4) 在每一分钟都会调用  ls -l /etc&gt;&gt; /tmp/to.txt\n</code></pre>\n<h3 id=\"细节参数说明\"><a class=\"markdownIt-Anchor\" href=\"#细节参数说明\"></a> 细节参数说明</h3>\n<ul>\n<li><strong>5个占位符的说明</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>含义</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一个“*”</td>\n<td>一小时中的第几分钟</td>\n<td>0-59</td>\n</tr>\n<tr>\n<td>第二个“*”</td>\n<td>一天中的第几小时</td>\n<td>0-23</td>\n</tr>\n<tr>\n<td>第三个“*”</td>\n<td>一月中的第几天</td>\n<td>1-31</td>\n</tr>\n<tr>\n<td>第四个“*”</td>\n<td>一年中的第几月</td>\n<td>1-12</td>\n</tr>\n<tr>\n<td>第五个“*”</td>\n<td>一周中的星期几</td>\n<td>0-7（0和7都代表星期日）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>特殊符号的说明</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特殊符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>代表任何时间。比如第一个“*”就代表一个小时中每分钟都执行一次的意思。</td>\n</tr>\n<tr>\n<td>，</td>\n<td>代表不连续的时间。比如“0 8 ，12 ，16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td>\n</tr>\n<tr>\n<td>-</td>\n<td>代表连续的时间范围。比如“0 5 * * 1-6<font color='red'>命令</font> ” ，代表在周一到周六的凌晨5点0分执行命令</td>\n</tr>\n<tr>\n<td>*/n</td>\n<td>代表没隔多久执行一次。比如“*/10 * * * * <font color='red'>命令</font>” ，代表每隔10分钟就执行一遍命令</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>特定时间执行任务案例</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>45 22 * * * 命令</td>\n<td style=\"text-align:left\">在22点45分执行命令</td>\n</tr>\n<tr>\n<td>0 17 * * 1  命令</td>\n<td style=\"text-align:left\">在每周1的17点0分执行命令</td>\n</tr>\n<tr>\n<td>0 5 1 ，15 * * 命令</td>\n<td style=\"text-align:left\">在每月1号和15号的凌晨5点0分执行命令</td>\n</tr>\n<tr>\n<td>40 4 * * 1-5 命令</td>\n<td style=\"text-align:left\">每周一到周五的凌晨4点40分执行命令</td>\n</tr>\n<tr>\n<td>*/10 4 * * * 命令</td>\n<td style=\"text-align:left\">每天的凌晨4点，每隔十分钟执行一次命令</td>\n</tr>\n<tr>\n<td>00 1 ， 15 * 1命令</td>\n<td style=\"text-align:left\">每月1号和15号，每周1点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们的定义都是天。非常容易让管理员混乱</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"crond任务调度应用实例\"><a class=\"markdownIt-Anchor\" href=\"#crond任务调度应用实例\"></a> crond任务调度应用实例</h2>\n<h3 id=\"案例-2\"><a class=\"markdownIt-Anchor\" href=\"#案例-2\"></a> 案例</h3>\n<p><strong>案例1</strong>：每隔一分钟，就将当前的日期信息，追加到 /tmp/mydate文件中</p>\n<p>1)先编写一个文件 /home/mytask1.sh</p>\n<pre class=\"highlight\"><code class=\"bash\">指令\nvim /home/mytask1.sh\ndate &gt;&gt; /tmp/mydate\n</code></pre>\n<p>2）给mytask1.sh一个可执行权限</p>\n<pre class=\"highlight\"><code class=\"bash\">chmod 744 /home/mytask1.sh\n</code></pre>\n<p>3）crontab -e</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210609195311.png\" alt=\"image-20210609195310486\" /></p>\n<p>4）*/1 * * * *  /home/mytask1.sh</p>\n<p>5）成功</p>\n<p><strong>案例2</strong>：每隔一分钟，将当前<font color='red'><strong>日期和日历</strong></font>都追加到 /home/mycal文件中</p>\n<p>1)先编写一个文件 /home/mytask2.sh</p>\n<pre class=\"highlight\"><code class=\"bash\">指令\nvim /home/mytask2.sh\ndate &gt;&gt; /tmp/mcycal\n</code></pre>\n<p>2）给mytask1.sh一个可执行权限</p>\n<pre class=\"highlight\"><code class=\"bash\">chmod 744 /home/mytask2.sh\n</code></pre>\n<p>3）crontab -e</p>\n<p>4）*/1 * * * *  /home/mytask2.sh</p>\n<p>5）成功</p>\n<p><strong>案例3</strong>：每天凌晨2:00将mysql数据库testdb。备份到文件中。</p>\n<h3 id=\"crond相关的指令\"><a class=\"markdownIt-Anchor\" href=\"#crond相关的指令\"></a> crond相关的指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">crontab -r :终止任务调度\ncrontab -l :列出当前有哪些任务调度\nservice crond restart [重启任务调度]\n</code></pre>\n<h1 id=\"linux磁盘分区-挂载\"><a class=\"markdownIt-Anchor\" href=\"#linux磁盘分区-挂载\"></a> Linux磁盘分区、挂载</h1>\n<h2 id=\"分区基础知识\"><a class=\"markdownIt-Anchor\" href=\"#分区基础知识\"></a> 分区基础知识</h2>\n<h3 id=\"分区的方式font-colorred了解font\"><a class=\"markdownIt-Anchor\" href=\"#分区的方式font-colorred了解font\"></a> 分区的方式（<font color='red'>了解</font>）</h3>\n<p>1）mbr分区：</p>\n<p>1.最多支持四个主分区</p>\n<p>2.系统只能安装在主分区</p>\n<p>3.扩展分区只要占一个主分区</p>\n<p>4.MBR最大支持2TB，但拥有最好的兼容性</p>\n<p>2）gtp分区：</p>\n<p>1.支持多个主分区(但操作系统可能限制，比如Windows下最多128个分区)</p>\n<p>2.最大支持18EB的大容量（EB=1024PB，PB=1024TB）</p>\n<p>3.windows7  64位以后支持gtp</p>\n<h3 id=\"windows下的磁盘分区\"><a class=\"markdownIt-Anchor\" href=\"#windows下的磁盘分区\"></a> Windows下的磁盘分区</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210615123843.png\" alt=\"image-20210615123834985\" /></p>\n<h2 id=\"linux分区\"><a class=\"markdownIt-Anchor\" href=\"#linux分区\"></a> Linux分区</h2>\n<h3 id=\"原理介绍\"><a class=\"markdownIt-Anchor\" href=\"#原理介绍\"></a> 原理介绍</h3>\n<p>1）Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每一个分区都是用来组成文件系统的一部分。</p>\n<p>2）Linux采用一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套文件和目录，且将一个分区和一个目录联系起来。这是要载入一个分区将它的存储空间在一个目录下获得。</p>\n<p>3）示意图</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210615124801.png\" alt=\"image-20210615124800040\" /></p>\n<h3 id=\"硬盘说明\"><a class=\"markdownIt-Anchor\" href=\"#硬盘说明\"></a> 硬盘说明</h3>\n<p>1）Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p>\n<p>2）对于<font color='red'>IDE</font>硬盘，驱动器标识符为“hdx~”，其中 “hd”表明分区所在设备的类型，这是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1到4表示，他们是主分区或扩展分区，hbd2表示为第二个IDE硬盘上过的第二个主分区或扩展分区。</p>\n<p>3）对于SCSI硬盘则表示为“sdx”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</p>\n<h3 id=\"使用-font-colorred-lsblk-指令font查看当前font-colororange系统的分区情况font\"><a class=\"markdownIt-Anchor\" href=\"#使用-font-colorred-lsblk-指令font查看当前font-colororange系统的分区情况font\"></a> 使用 <font color='red'> lsblk  指令</font>查看当前<font color='orange'>系统的分区情况</font></h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210615134935.png\" alt=\"image-20210615134934383\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616132706.png\" alt=\"image-20210616132658380\" /></p>\n<h2 id=\"挂载的经典案例\"><a class=\"markdownIt-Anchor\" href=\"#挂载的经典案例\"></a> 挂载的经典案例</h2>\n<p>需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616133041.png\" alt=\"image-20210616133040682\" /></p>\n<h3 id=\"如何增加一块硬盘\"><a class=\"markdownIt-Anchor\" href=\"#如何增加一块硬盘\"></a> 如何增加一块硬盘</h3>\n<p>1）虚拟机添加硬盘</p>\n<p>2）分区</p>\n<pre class=\"highlight\"><code class=\"bash\">fdisk /dev/sdb\n</code></pre>\n<p>3）格式化</p>\n<pre class=\"highlight\"><code class=\"bash\">mkfs -t ext4 /dev/sdb1 mkfs是格式化的意思\n这里表示的是把dev下面的sdb1格式化成ext4类型的文件类型\n</code></pre>\n<p>4）挂载</p>\n<pre class=\"highlight\"><code class=\"bash\">先创建 /home/newdisk\n再进行挂载  mount  /dev/sdb1  /home/newdisk \n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616134841.png\" alt=\"image-20210616134840082\" /></p>\n<p>5）设置可以自动挂载（永久挂载，当你重启机系统后，仍然可以挂载到 /home/newdisk上面去）。</p>\n<pre class=\"highlight\"><code class=\"bash\">vim /etc/fstab  进入之后加上\n/dev/sdb1                /home/newdisk                  ext4     defaults        0 0\n\n</code></pre>\n<h2 id=\"具体的操作步骤\"><a class=\"markdownIt-Anchor\" href=\"#具体的操作步骤\"></a> 具体的操作步骤</h2>\n<h3 id=\"虚拟机增加硬盘步骤1font-colorred增加硬盘font\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机增加硬盘步骤1font-colorred增加硬盘font\"></a> 虚拟机增加硬盘步骤1<font color='red'>（增加硬盘）</font></h3>\n<p>在<font color='red'>【虚拟机】</font>菜单中，选择<font color='red'>【设置】</font>，然后设备列表里面添加硬盘，然后一路<font color='red'>【下一步】</font>，中间只有选择磁盘大小的地方需要修改，直至完成。然后重启系统（才能识别）！</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616172357.png\" alt=\"image-20210616172349248\" /></p>\n<h3 id=\"虚拟机增加硬盘步骤2font-colorred对磁盘进行分区-font\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机增加硬盘步骤2font-colorred对磁盘进行分区-font\"></a> 虚拟机增加硬盘步骤2<font color='red'>（对磁盘进行分区 ）</font></h3>\n<p>分区命令</p>\n<pre class=\"highlight\"><code class=\"bash\">fdisk  /dev/sdb\n</code></pre>\n<p>开始对/sdb分区</p>\n<ul>\n<li>m\t显示命令列表</li>\n<li>n      显示磁盘分区   同 fdisk   -1</li>\n<li>d      删除分区</li>\n<li>w     写入并退出</li>\n</ul>\n<p>说明：开始分区后输入n，新增分区，然后选择p，分区类型为主分区。两次回车默认全部空间，最后输入w并退出，若不保存推出输入q。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616173747.png\" alt=\"image-20210616173745730\" /></p>\n<h3 id=\"虚拟机增加硬盘步骤3font-colorred格式化磁盘font\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机增加硬盘步骤3font-colorred格式化磁盘font\"></a> 虚拟机增加硬盘步骤3<font color='red'>（格式化磁盘）</font></h3>\n<p>格式化磁盘</p>\n<p>分区命令：mkfs -t   ext4   /dev/sdb1</p>\n<p>其中ext4是分区类型</p>\n<h3 id=\"虚拟机增加硬盘步骤4font-colorred挂载font\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机增加硬盘步骤4font-colorred挂载font\"></a> 虚拟机增加硬盘步骤4\t<font color='red'>（挂载）</font></h3>\n<p><font color='red'><strong>挂载</strong></font>：将一个分区于一个目录联系起来</p>\n<pre class=\"highlight\"><code class=\"bash\">mount  设备名称    挂载目录\n   例如：mount   /dev/sdb1    /newdisk\numount   设备名称  或者   挂载目录   （相当于卸载）\n   例如：umount /dev/sdb1    或者   umount   /newdisk\n</code></pre>\n<h3 id=\"虚拟机增加硬盘步骤5font-colorred实现永久挂载font\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机增加硬盘步骤5font-colorred实现永久挂载font\"></a> 虚拟机增加硬盘步骤5<font color='red'>（实现永久挂载）</font></h3>\n<p><font color='red'>永久挂载</font>：通过<font color='orange'>修改/etc/fstab实现挂载</font></p>\n<p>添加完成后   执行 <font color='red'> mount    -a  </font>立即生效</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210616175226.png\" alt=\"image-20210616175225394\" /></p>\n<h2 id=\"磁盘情况查询\"><a class=\"markdownIt-Anchor\" href=\"#磁盘情况查询\"></a> 磁盘情况查询</h2>\n<h3 id=\"查询系统整体磁盘使用情况\"><a class=\"markdownIt-Anchor\" href=\"#查询系统整体磁盘使用情况\"></a> 查询系统整体磁盘使用情况</h3>\n<ul>\n<li>\n<p>基本语法</p>\n<pre class=\"highlight\"><code class=\"bash\">查看磁盘占用情况   df  -lh\n</code></pre>\n</li>\n<li>\n<p>应用实例</p>\n</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618124410.png\" alt=\"image-20210618124402629\" /></p>\n<h3 id=\"查询指定目录磁盘占用情况\"><a class=\"markdownIt-Anchor\" href=\"#查询指定目录磁盘占用情况\"></a> 查询指定目录磁盘占用情况</h3>\n<ul>\n<li>\n<p>基本语法</p>\n<pre class=\"highlight\"><code class=\"bash\">du  -h  /目录\n查询指定目录的磁盘占用情况，默认为当前目录\n-s  之目录大小的汇总\n-h  带计量单位\n-a  含文件\n--max-depth=1  子目录深度\n-c  列出明细的同时，增加汇总值\n</code></pre>\n<ul>\n<li>应用实例</li>\n</ul>\n</li>\n</ul>\n<p>查询  /opt 目录的磁盘占用情况，深度为1</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618125722.png\" alt=\"image-20210618125721731\" /></p>\n<p>查看当前目录下文件夹的是使用率</p>\n<pre class=\"highlight\"><code class=\"bash\">du -h --max-depth=1\n</code></pre>\n<p><img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211224154439972.png\" alt=\"image-20211224154439972\" /></p>\n<h2 id=\"磁盘情况-工作实用指令\"><a class=\"markdownIt-Anchor\" href=\"#磁盘情况-工作实用指令\"></a> 磁盘情况-工作实用指令</h2>\n<p>1）统计\t /home  文件夹目录下的个数</p>\n<pre class=\"highlight\"><code class=\"bash\">ls -l /home | grep <span class=\"hljs-string\">\"^-\"</span> | wc -l\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618134222.png\" alt=\"image-20210618134221489\" /></p>\n<p>2）统计/home文件夹下目录的个数</p>\n<pre class=\"highlight\"><code class=\"bash\">ls -l /home | grep <span class=\"hljs-string\">\"^d\"</span> | wc -l\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618134329.png\" alt=\"image-20210618134328531\" /></p>\n<p>3）统计\t /home   文件夹下文件的个数，包括子文件夹里面的</p>\n<pre class=\"highlight\"><code class=\"bash\">ls -lR /home | grep <span class=\"hljs-string\">\"^-\"</span> | wc -l    加上了R就将/home下面的文件的个数，包括子文件夹里面的都递归统计\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618190911.png\" alt=\"image-20210618190910795\" /></p>\n<p>4）统计文件夹下目录的个数，包括子文件夹里面的</p>\n<pre class=\"highlight\"><code class=\"bash\">ls -lR /home | grep <span class=\"hljs-string\">\"^d\"</span> | wc -l    加上了R就将/home下面的文件的个数，包括子文件夹里面的都递归统计\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618191522.png\" alt=\"image-20210618191521215\" /></p>\n<p>5）以树状显示目录结构</p>\n<pre class=\"highlight\"><code class=\"bash\">tree 指令的安装\nyum install tree\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618192100.png\" alt=\"image-20210618192059735\" /></p>\n<p>​\t\t\t\t\t\t<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707201650.png\" alt=\"image-20210618192214345\" /></p>\n<h1 id=\"实操篇之网络配置\"><a class=\"markdownIt-Anchor\" href=\"#实操篇之网络配置\"></a> 实操篇之网络配置</h1>\n<h2 id=\"linux网络配置的原理图含虚拟机\"><a class=\"markdownIt-Anchor\" href=\"#linux网络配置的原理图含虚拟机\"></a> Linux网络配置的原理图（含虚拟机）</h2>\n<p>目前我们采用的是NAT模式。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622155744.png\" alt=\"image-20210622155736574\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618213424.png\" alt=\"image-20210618213423266\" /></p>\n<h2 id=\"查看网络ip和网关\"><a class=\"markdownIt-Anchor\" href=\"#查看网络ip和网关\"></a> 查看网络IP和网关</h2>\n<h3 id=\"查看虚拟网络编辑器\"><a class=\"markdownIt-Anchor\" href=\"#查看虚拟网络编辑器\"></a> 查看虚拟网络编辑器</h3>\n<p>VMware  编辑   -----&gt;   虚拟网络配置</p>\n<h3 id=\"修改ip地址修改虚拟网卡的ip-也就是vmnet8\"><a class=\"markdownIt-Anchor\" href=\"#修改ip地址修改虚拟网卡的ip-也就是vmnet8\"></a> 修改IP地址（修改虚拟网卡的IP   也就是vmnet8）</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210618214242.png\" alt=\"image-20210618214240461\" /></p>\n<h3 id=\"查看网络ip和网关-2\"><a class=\"markdownIt-Anchor\" href=\"#查看网络ip和网关-2\"></a> 查看网络IP和网关</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619081720.png\" alt=\"image-20210619081710105\" /></p>\n<h3 id=\"查看windows环境中的vmnet8网络配置ipconfig指令\"><a class=\"markdownIt-Anchor\" href=\"#查看windows环境中的vmnet8网络配置ipconfig指令\"></a> 查看Windows环境中的VMnet8网络配置（ipconfig指令）</h3>\n<p>1）使用ipconfig查看</p>\n<p>2）界面查看</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619082121.png\" alt=\"image-20210619082120849\" /></p>\n<h2 id=\"ping测试主机之间网络的连通性\"><a class=\"markdownIt-Anchor\" href=\"#ping测试主机之间网络的连通性\"></a> ping测试主机之间网络的连通性</h2>\n<h3 id=\"基本语法-30\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-30\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">ping    目的主机\t（功能描述：测试当前服务器是否可以连接目的主机）\n</code></pre>\n<h3 id=\"应用实例-31\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-31\"></a> 应用实例</h3>\n<p>测试当前服务器是否可以访问百度</p>\n<pre class=\"highlight\"><code class=\"bash\">ping \twww.baidu.com\n</code></pre>\n<h2 id=\"linux网络环境配置\"><a class=\"markdownIt-Anchor\" href=\"#linux网络环境配置\"></a> Linux网络环境配置</h2>\n<h3 id=\"第一种方式自动获取\"><a class=\"markdownIt-Anchor\" href=\"#第一种方式自动获取\"></a> 第一种方式（自动获取）</h3>\n<p><font color='red'>说明</font>：登陆后，通过界面来设置自动获取IP</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619085552.png\" alt=\"image-20210619085547568\" /></p>\n<p><font color='red'>特点</font>：Linux启动后会自动获取IP，缺点是每次启动后自动获取的IP地址可能不一样。这个不适用于做服务器，因为我们服务器的IP需要是固定的。</p>\n<h3 id=\"第二种方式指定固定的ip\"><a class=\"markdownIt-Anchor\" href=\"#第二种方式指定固定的ip\"></a> 第二种方式（指定固定的IP）</h3>\n<ul>\n<li>\n<p>说明192.168.122.1</p>\n<p>直接修改文件来指定IP，并且可以连接到外网（<font color='red'>推荐</font>），<strong>编辑</strong>   vi  /etc/sysconfig/network-scripts/ifcfg-ens33（centos7），（ vi /etc/sysconfig/network-scripts/ifcfg-eth0     这个为centos6）</p>\n</li>\n</ul>\n<p>要求：将IP地址设置成静态的，IP地址为192.168.31.128</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619101600.png\" alt=\"image-20210619101559143\" /></p>\n<p>修改后，一定要重启服务</p>\n<p>1）service   network   restart</p>\n<p>2）reboot   重启机器</p>\n<h1 id=\"实操篇之进程管理\"><a class=\"markdownIt-Anchor\" href=\"#实操篇之进程管理\"></a> 实操篇之进程管理</h1>\n<h2 id=\"基本介绍-21\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-21\"></a> 基本介绍</h2>\n<p>1）在Linux中，每个执行的**程序（代码）**都成为一个<font color='red'>进程</font>。每个进程都分配一个id号。</p>\n<p>2）每个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p>\n<p>3）每个进程都可能以两种方式存在。<font color='red'>前台和后台</font>，所谓前台进程就是用户目前屏幕上可以进行的操作。后台进程实际在操作，由于屏幕上无法看到进程，通常使用后台方式执行。</p>\n<p>4）一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。知道关机才结束。</p>\n<h2 id=\"显示执行的进程\"><a class=\"markdownIt-Anchor\" href=\"#显示执行的进程\"></a> 显示执行的进程</h2>\n<h3 id=\"说明查看进程使用的指令是ps-一般来说使用的参数是-aus\"><a class=\"markdownIt-Anchor\" href=\"#说明查看进程使用的指令是ps-一般来说使用的参数是-aus\"></a> 说明：查看进程使用的指令是ps ，一般来说使用的参数是   -aus</h3>\n<p>ps显示信息选项：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PID</td>\n<td>进程识别号</td>\n</tr>\n<tr>\n<td>TTY</td>\n<td>终端机号</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>此进程所消耗CUP时间</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>正在执行的命令或进程名</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"highlight\"><code class=\"bash\">ps -a \t:显示当前终端的所有进程信息\nps -u\t：以用户的格式显示进程信息\nps -x\t：显示后台进程运行的参数\n</code></pre>\n<pre class=\"highlight\"><code class=\"bash\">ps -aux | more\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619175858.png\" alt=\"image-20210619175857359\" /></p>\n<h3 id=\"ps详解\"><a class=\"markdownIt-Anchor\" href=\"#ps详解\"></a> ps详解</h3>\n<p>1）指令：ps -aux  |  grep   xxx  ，比如看看有没有sshd服务</p>\n<p>2）指令说明</p>\n<ul>\n<li>System  V  展示风格</li>\n<li>USER  :用户名称</li>\n<li>PID：进程号</li>\n<li>%CPU：进程占用CPU的百分比</li>\n<li>%MEM：进程占用的物理内存的百分比</li>\n<li>VSZ:进程占用虚拟内存的大小（单位:KB）</li>\n<li>RSS：进程占用的物理内存的大小（单位：KB）</li>\n<li>TT：终端名称，缩写</li>\n<li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或被停止等待</li>\n<li>STARTED：进程的启动时间</li>\n<li>TIME：CPU时间，即进程使用CPU的总时间。</li>\n<li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li>\n</ul>\n<h3 id=\"应用实例-32\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-32\"></a> 应用实例</h3>\n<p>要求：以全格式显示当前所有的进程，查看进程的父进程。</p>\n<ul>\n<li>ps\t-ef 是以全格式显示当前的所有的进程</li>\n<li>-e 显示所有进程。-f全格式。</li>\n<li>ps  -ef | grep  xxx</li>\n<li>是BSD风格</li>\n<li>UID：用户ID</li>\n<li>PID：进程ID</li>\n<li>PPID：父进程ID</li>\n<li>C:CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程I/O密集型运算，执行优先级会提高</li>\n</ul>\n<p>思考题，如果我们希望查看sshd进程的父进程号是多少，应该怎么样查询？</p>\n<pre class=\"highlight\"><code class=\"bash\">ps -ef | grep sshd\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210619190657.png\" alt=\"image-20210619190657050\" /></p>\n<h2 id=\"终止进程kill和killall\"><a class=\"markdownIt-Anchor\" href=\"#终止进程kill和killall\"></a> 终止进程kill和killall</h2>\n<h3 id=\"介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#介绍-5\"></a> 介绍</h3>\n<p>若是某个进程执行一般需要停止时，或是已消了很大的系统资源时，可以考虑停止该进程。使用kill命令来完成此项任务。</p>\n<h3 id=\"基本语法-31\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-31\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">kill</span>   [选项]   进程号  （功能描述：通过进程号来杀死进程）\nkillall  进程名称  （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）\n</code></pre>\n<h3 id=\"常用选项-3\"><a class=\"markdownIt-Anchor\" href=\"#常用选项-3\"></a> 常用选项</h3>\n<pre class=\"highlight\"><code class=\"bash\">-9 表示强迫进程立即停止\n</code></pre>\n<h3 id=\"最佳实践\"><a class=\"markdownIt-Anchor\" href=\"#最佳实践\"></a> 最佳实践：</h3>\n<p>案例一：踢掉某个非法登录的用户</p>\n<pre class=\"highlight\"><code class=\"bash\">ps -aux | grep sshd\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620093220.png\" alt=\"image-20210620093212557\" /></p>\n<p>案例二：终止远程登陆服务sshd，在适当时候再次重启sshd服务</p>\n<pre class=\"highlight\"><code class=\"bash\">ps -aux | grep sshd\n<span class=\"hljs-built_in\">kill</span> 1467\nps -aux | grep sshd\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620114835.png\" alt=\"image-20210620114833970\" /></p>\n<p>案例三：种植多个gedit编辑器  【killall ，通过进程名称来终止进程】</p>\n<pre class=\"highlight\"><code class=\"bash\">gedit 执行两次\nkillall  gedit\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620115213.png\" alt=\"image-20210620115211999\" /></p>\n<p>案例四：强制杀死一个终端</p>\n<pre class=\"highlight\"><code class=\"bash\">ps -aux | grep bash\n<span class=\"hljs-built_in\">kill</span> -9 [终端端口号]\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620115916.png\" alt=\"image-20210620115915404\" /></p>\n<h2 id=\"查看进程树pstree\"><a class=\"markdownIt-Anchor\" href=\"#查看进程树pstree\"></a> 查看进程树pstree</h2>\n<h3 id=\"基本语法-32\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-32\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">pstree [选项]   ，可以更加直观的来观看进程\n</code></pre>\n<h3 id=\"常用选项-4\"><a class=\"markdownIt-Anchor\" href=\"#常用选项-4\"></a> 常用选项</h3>\n<pre class=\"highlight\"><code class=\"bash\">-p : 显示进程的PID\n-u : 显示进程的所属用户\n</code></pre>\n<h3 id=\"应用实例-33\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-33\"></a> 应用实例</h3>\n<p>案例一：请你以树状形式显示进程的pid</p>\n<pre class=\"highlight\"><code class=\"bash\">pstree -p | more\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620120705.png\" alt=\"image-20210620120703674\" /></p>\n<p>案例二：请你以树状形式显示用户的id</p>\n<pre class=\"highlight\"><code class=\"bash\">pstree -u | more \n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620120800.png\" alt=\"image-20210620120759535\" /></p>\n<h2 id=\"服务service管理\"><a class=\"markdownIt-Anchor\" href=\"#服务service管理\"></a> 服务（service）管理</h2>\n<h3 id=\"介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#介绍-6\"></a> 介绍</h3>\n<p>服务（service）本质就是进程，但是运行在后台的，同城都会监听某个端口，等待其他程序的请求，比如（mysql，sshd，防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点。</p>\n<p><font color='red'>【原理图】</font></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620121057.png\" alt=\"image-20210620121056540\" /></p>\n<h2 id=\"service-centos6-systemctlcentos70-管理命令\"><a class=\"markdownIt-Anchor\" href=\"#service-centos6-systemctlcentos70-管理命令\"></a> service （CentOS6 ）systemctl（CentOS7.0  ） 管理命令</h2>\n<p><font color='red'> CentOS7.0      systemctl   [start | stop | restart | reload | status |<br />\nmask  ]    服务名    这里的mask 是表示禁用的意思,reload表示的是重载 </font></p>\n<p>service服务指令在/etc/init.d/</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622160143.png\" alt=\"image-20210622160142001\" /></p>\n<p>systemctl指令管理的服务是在<font color='red'>/usr/lib/systemd/system</font>查看</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623081048.png\" alt=\"image-20210623081039798\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">service  服务名  [start | stop | restart | reload | status |mask ]\n在CentOS7.0后  不再使用service ，而是systemctl\nsystemctl   [start | stop | restart | reload | status | mask ]    服务名 这个很重要\n\n</code></pre>\n<h3 id=\"chconfig指令\"><a class=\"markdownIt-Anchor\" href=\"#chconfig指令\"></a> chconfig指令</h3>\n<h4 id=\"介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#介绍-7\"></a> 介绍</h4>\n<p>1、通过chconfig命令可以给服务的各个运行级别设置<font color='red'>自   启动 / 关闭 </font></p>\n<p>2、chconfig指令管理的服务在/etc/init.d查看</p>\n<p>3、注意：CentOS7后，很多服务<font color='red'>使用systemctl</font>管理</p>\n<h4 id=\"chconfig基本语法\"><a class=\"markdownIt-Anchor\" href=\"#chconfig基本语法\"></a> chconfig基本语法</h4>\n<ul>\n<li>查看服务  chconfig   --list  [ |  grep xxx  ]</li>\n<li>chconfig  服务名  --list</li>\n</ul>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622222047.png\" alt=\"image-20210622222047028\" /></p>\n<ul>\n<li>ckconfig  --level 5 服务名  on/off</li>\n</ul>\n<p>案例演示：对network  服务进行各种操作，把network在运行级别3关闭自启动</p>\n<pre class=\"highlight\"><code class=\"bash\">chkconfig --level 3 network off\nchkconfig --level 3 network on\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622222416.png\" alt=\"image-20210622222415266\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622222511.png\" alt=\"image-20210622222510465\" /></p>\n<p><font color='red'><strong>使用细节</strong></font></p>\n<p>chconfig重新设置服务后自启动或关闭，需要重启机器reboot生效</p>\n<h3 id=\"font-colorredsystemctl指令font的常见使用\"><a class=\"markdownIt-Anchor\" href=\"#font-colorredsystemctl指令font的常见使用\"></a> <font color='red'>systemctl指令</font>的常见使用</h3>\n<p>systemctl基本介绍：<font color='red'>在Centos 中 systemctl  是设置系统服务的命令</font>，即 service  ,   它融合之前service和chkconfig的功能于一体。</p>\n<p>可以使用它永久性或只在当前会话中启用/禁用服务。</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl 设置服务的自启动状态\nsystemctl\t\t\t\t\t\t\t输出激活的单元，即列出所有正在运行的服务\nsystemctl\tlist-units\t\t \t\t 输出激活的单元\nsystemctl\t--failed\t\t \t\t输出运行失败的单元\nsystemctl\tlist-unit-files\t [[|grep  服务名] \t\t（查看服务开机启动状态，grep可以进行过滤）\nsystemctl enbale  服务名\t（设置服务开机启动）\nsystemctl disabale  服务名   （关闭服务开机启动）\nsystemctl is-enbaled   服务名   （查询某个服务是否是自启动的）\n</code></pre>\n<p>启动一个服务</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl start sshd.service 也可以省略(.service)\n</code></pre>\n<p>在开机启动或者关闭服务:</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl enbale sshd.service\nsystemctl <span class=\"hljs-built_in\">disable</span> sshd.service\n</code></pre>\n<p>查看是否开机启动</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl is-enbaled sshd.service\n</code></pre>\n<p>查看已启动的服务列表:</p>\n<pre class=\"highlight\"><code class=\"bash\"> systemctl list-unit-files | grep enabled\n</code></pre>\n<p>查看启动失败的服务列表：</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl --failed\n</code></pre>\n<p>查看防火墙服务</p>\n<pre class=\"highlight\"><code class=\"bash\"> ls -l /usr/lib/systemd/system | grep firewalld\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623081741.png\" alt=\"image-20210623081740177\" /></p>\n<p>查看防火墙的自启动状态</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl list-unit-files | grep firewalld\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623081922.png\" alt=\"image-20210623081920967\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl is-enabled firewalld\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623082012.png\" alt=\"image-20210623082011662\" /></p>\n<p>查看网络状态</p>\n<pre class=\"highlight\"><code class=\"bash\">netstat  -anp |more\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623082621.png\" alt=\"image-20210623082620812\" /></p>\n<h3 id=\"使用案例\"><a class=\"markdownIt-Anchor\" href=\"#使用案例\"></a> 使用案例</h3>\n<p>1）查看当前防火墙的状况，关闭防火墙和重启防火墙    <font color='red'>（ CentOS7.0中）</font></p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl status firewalld     firewalld  表示的是防火墙的意思\nsystemctl stop firewalld   关闭防火墙\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620123455.png\" alt=\"image-20210620123454237\" /></p>\n<h3 id=\"细节讨论\"><a class=\"markdownIt-Anchor\" href=\"#细节讨论\"></a> 细节讨论：</h3>\n<p>1）关闭或者其用防火墙后，立即生效。 [telnet  测试某个端口即可]</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620141036.png\" alt=\"image-20210620141035729\" /></p>\n<p>2）这种方式这是临时生效，当重启系统后，还是回归以后对服务的设置</p>\n<p>3）如果希望设置，某个服务自动启动或关闭永久生效，使用chekconfig指令。</p>\n<h3 id=\"查看服务名\"><a class=\"markdownIt-Anchor\" href=\"#查看服务名\"></a> 查看服务名</h3>\n<p>方式一：使用setup  --&gt;  系统服务  就可以看到</p>\n<pre class=\"highlight\"><code class=\"bash\">setup\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620141824.png\" alt=\"image-20210620141823089\" /></p>\n<p>方式二： /etc/init.d/服务名称</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210620142324.png\" alt=\"image-20210620142323462\" /></p>\n<h3 id=\"服务的运行级别runlevel\"><a class=\"markdownIt-Anchor\" href=\"#服务的运行级别runlevel\"></a> 服务的运行级别（runlevel）：</h3>\n<p>Linux系统有七种运行级别（runlevel）：<font color='red'>常用的是级别3和5</font></p>\n<p>运行级别0：系统停机状态，系统默认的运行级别不能设置为0，否则不能正常启动</p>\n<p>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</p>\n<p>运行级别2：多用户状态（有NFS），不支持网络</p>\n<p><font color='red'>运行级别3</font>：完全的多用户状态（有NFS）<font color='red'>无界面</font>，登陆后进入控制台命令行模式</p>\n<p>运行级别4：系统未使用，保留</p>\n<p><font color='red'>运行级别5</font>：X11控制台，登录后进入图形GUI模式</p>\n<p>运行级别6：系统正常关闭并重启，默认运行级别不能设置为6，否则不能正常启动</p>\n<ul>\n<li>开机的流程</li>\n</ul>\n<p>开机   -----》 BIOS  -------》   /boot -------》systemd进程1----------》运行级别------------》运行级别对应的服务</p>\n<p>1、查看默认的运行级别</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl get-default\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622192424.png\" alt=\"image-20210622192404552\" /></p>\n<p>2、设置运行级别为3号级别</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl <span class=\"hljs-built_in\">set</span>-default multi-user.target\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622192618.png\" alt=\"image-20210622192616836\" /></p>\n<p>3、设置成图形化界面</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl <span class=\"hljs-built_in\">set</span>-default graphical.target\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210622192959.png\" alt=\"image-20210622192958284\" /></p>\n<p>示意图</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623085346.png\" alt=\"image-20210623085342071\" /></p>\n<h3 id=\"打开或者关闭指定端口\"><a class=\"markdownIt-Anchor\" href=\"#打开或者关闭指定端口\"></a> 打开或者关闭指定端口</h3>\n<p>在真正的生产环境中，往往需要防火墙打开，如果把防火墙打开，那么外部请求数据包就不能跟服务器监听通讯。这时，需要打开指定端口。比如80、22、8080等。</p>\n<h3 id=\"firewall指令\"><a class=\"markdownIt-Anchor\" href=\"#firewall指令\"></a> firewall指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">打开端口：\nfirewall-cmd --permanet\t --add-port=端口号/协议\nfirewall-cmd --zone=public --add-port=端口号/tcp --permanent\n关闭端口：firewall-cmd --permanet --remove-port=端口号/协议\n\n需要重新载入，才能生效：firewall-cmd  --reload\n\n查询端口是否开放：firewall-cmd  --query-port=端口/协议\n\n查看已经开启的端口号\nfirewall-cmd --list-ports\nfirewall-cmd --zone=public --add-port=8088/tcp\n</code></pre>\n<h3 id=\"应用案例-3\"><a class=\"markdownIt-Anchor\" href=\"#应用案例-3\"></a> 应用案例</h3>\n<p>1、启用防火墙，测试111端口是否能telnet ，不行</p>\n<p>2、开放111端口</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623105115.png\" alt=\"image-20210623105103990\" /></p>\n<p>3、再次关闭111端口</p>\n<pre class=\"highlight\"><code class=\"bash\">关闭端口：firewall-cmd --permanet --remove-port =端口号/协议\n需要重新载入，才能生效：firewall-cmd  --reload\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623110756.png\" alt=\"image-20210623110755819\" /></p>\n<h2 id=\"动态监控进程\"><a class=\"markdownIt-Anchor\" href=\"#动态监控进程\"></a> 动态监控进程</h2>\n<h3 id=\"介绍-8\"><a class=\"markdownIt-Anchor\" href=\"#介绍-8\"></a> 介绍</h3>\n<p>top与ps命令很相似。他们都是用来显示正在执行的进程。Top与ps的最大不同之处，在于top执行一段时间后可以更新正在运行的进程。</p>\n<h3 id=\"基本语法-33\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-33\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">top  [选项]\n</code></pre>\n<h3 id=\"选项说明-2\"><a class=\"markdownIt-Anchor\" href=\"#选项说明-2\"></a> 选项说明</h3>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d 秒数</td>\n<td>指定top命令每隔几秒更新。默认是3秒</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>使top不显示任何闲置或者僵尸进程</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>通过指定监控进程ID来仅仅监控某个进程的状态</td>\n</tr>\n</tbody>\n</table>\n<p>使用top指令动态监控进程</p>\n<pre class=\"highlight\"><code class=\"bash\">下图的zombie是僵尸进程，已经死掉了，但是内存没有释放\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623112345.png\" alt=\"image-20210623112345015\" /></p>\n<h3 id=\"交互操作说明\"><a class=\"markdownIt-Anchor\" href=\"#交互操作说明\"></a> 交互操作说明</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><font color='red'>P</font></td>\n<td>以CUP使用率排序，默认就是此项</td>\n</tr>\n<tr>\n<td><font color='red'>M</font></td>\n<td>一内存使用率排序</td>\n</tr>\n<tr>\n<td>N</td>\n<td>以PID排序</td>\n</tr>\n<tr>\n<td>q</td>\n<td>退出top</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"应用实例-34\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-34\"></a> 应用实例</h3>\n<p>案例一：监视特定用户</p>\n<p>top:输入此命令，按回车键，查看执行的进程。</p>\n<p>u：然后输入&quot;u&quot;回车，再输入用户名，即可。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623191024.png\" alt=\"image-20210623191023100\" /></p>\n<p>案例二：终止此进程，比如我们要结束pzx登录</p>\n<p>top：输入此命令，按回车键，查看执行的进程。</p>\n<p>k：然后输入“k”回车，再输入要结束的进程的ID号。<font color='red'>（然后在输入9，进行强制杀死）</font></p>\n<p>案例三：指定系统装态更新的时间（每隔10秒自动更行），默认是3秒</p>\n<pre class=\"highlight\"><code class=\"bash\">top -d 10\n</code></pre>\n<h2 id=\"监控网络状态\"><a class=\"markdownIt-Anchor\" href=\"#监控网络状态\"></a> 监控网络状态</h2>\n<p>查看系统的网络状态情况netstat</p>\n<h3 id=\"基本语法-34\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-34\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\">netstst  [选项]\n选项说明\n-an   按一定顺序排列输出\n-p   显示哪一个进程在调用\n</code></pre>\n<h3 id=\"应用案例-4\"><a class=\"markdownIt-Anchor\" href=\"#应用案例-4\"></a> 应用案例</h3>\n<p>查看系统的网络状态情况netstat</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623192417.png\" alt=\"image-20210623192416838\" /></p>\n<p>查看sshd服务的服务信息</p>\n<pre class=\"highlight\"><code class=\"bash\">netstat -anp | grep sshd\n</code></pre>\n<h3 id=\"网络有问题的处理方法\"><a class=\"markdownIt-Anchor\" href=\"#网络有问题的处理方法\"></a> 网络有问题的处理方法</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624193815.png\" alt=\"image-20210624193814271\" /></p>\n<h3 id=\"linux和windows之间建立通信这个其实就是建立tcp通信\"><a class=\"markdownIt-Anchor\" href=\"#linux和windows之间建立通信这个其实就是建立tcp通信\"></a> linux和Windows之间建立通信（这个其实就是建立tcp通信）</h3>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623192935.png\" alt=\"image-20210623192932774\" /></p>\n<h1 id=\"rpm和yum\"><a class=\"markdownIt-Anchor\" href=\"#rpm和yum\"></a> RPM和YUM</h1>\n<h2 id=\"rpm包的管理\"><a class=\"markdownIt-Anchor\" href=\"#rpm包的管理\"></a> rpm包的管理</h2>\n<h3 id=\"介绍-9\"><a class=\"markdownIt-Anchor\" href=\"#介绍-9\"></a> 介绍</h3>\n<p>rpm用于互联网下载包的打包以安装工具，它包含在某些Linux发行版中。它生成具有.RPM拓展名的文件。RPM是RedHat Package Manager （RedHat 软件包管理工具）缩写，类似于windows中的setup.exe。\tLinux的发行版都采用（suse，redhat，centos等等）</p>\n<h3 id=\"rpm的简单查询指令\"><a class=\"markdownIt-Anchor\" href=\"#rpm的简单查询指令\"></a> rpm的简单查询指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">查询已经安装的rpm列表  \nrpm  -qa  |  grep xxx\n</code></pre>\n<p>案例演示：请查询是否安装firefox</p>\n<pre class=\"highlight\"><code class=\"bash\">    rpm -qa | grep firefox\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623205228.png\" alt=\"image-20210623205227158\" /></p>\n<h3 id=\"rpm包的其他查询指令\"><a class=\"markdownIt-Anchor\" href=\"#rpm包的其他查询指令\"></a> rpm包的其他查询指令：</h3>\n<pre class=\"highlight\"><code class=\"bash\">rpm  -qa  查询所安装的所有rpm软件包\nrpm  -qa | more\nrpm  -qa | grep X[rpm -qa | grep firefox]\nrpm  -q   软件包名：查询软件包是否安装\nrpm  -q   firefox\nrpm  -qi  软件包名：查询软件包信息\nrpm  -q  file\nrpm  -ql  软件包名：查询软件包中的文件\nrpm  -qi  firefox\n\nrpm  -qf  文件全路径名  查询文件所属的软件包\nrpm  -qf  /etc/passwd\nrpm  -qf  /root/install.log\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623205954.png\" alt=\"image-20210623205954028\" /></p>\n<p>查询firefox安装在哪里</p>\n<pre class=\"highlight\"><code class=\"bash\">rpm  -q  file firefox\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707202032.png\" alt=\"image-20210623210345146\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">rpm -qf /etc/passwd\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623210614.png\" alt=\"image-20210623210613970\" /></p>\n<h3 id=\"卸载rpm包\"><a class=\"markdownIt-Anchor\" href=\"#卸载rpm包\"></a> 卸载rpm包</h3>\n<ul>\n<li>基本语法</li>\n</ul>\n<pre class=\"highlight\"><code class=\"bash\">rpm -e  RPM的名称\n</code></pre>\n<ul>\n<li>应用案例</li>\n</ul>\n<p>1）删除firefox软件包</p>\n<pre class=\"highlight\"><code class=\"bash\">rpm -e firefox\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210623211022.png\" alt=\"image-20210623211021073\" /></p>\n<ul>\n<li>细节讨论</li>\n</ul>\n<p>1）如果其他软件包依赖于你要卸载的软件包，卸载时则会产生错误信息。</p>\n<pre class=\"highlight\"><code class=\"bash\">如：<span class=\"hljs-variable\">$rpm</span> -e foo\t\n</code></pre>\n<p>removing these packages would break dependences：foo is needed by bar-1.0-1</p>\n<p>2）如果我们就是要删除foo这个rpm包，可以增加参数–nodeps ，就可以进行强制删除了，但是一般不推荐这样做，因为依赖于这些软件包的程序可能无法运行。</p>\n<p>如：$rpm -e <font color='red'>–nodeps</font> foo  带上–nodeps就是强制删除的意思</p>\n<h3 id=\"安装rpm包\"><a class=\"markdownIt-Anchor\" href=\"#安装rpm包\"></a> 安装rpm包</h3>\n<p><strong>基本语法</strong></p>\n<pre class=\"highlight\"><code class=\"bash\">rpm -ivh RPM包的全路径名称\n</code></pre>\n<p><strong>参数说明</strong></p>\n<pre class=\"highlight\"><code class=\"bash\">i=install 安装\nv=verbose 提示\nh=<span class=\"hljs-built_in\">hash</span>    进度条\n</code></pre>\n<p><strong>应用实例</strong></p>\n<p>1）演示安装firefox浏览器</p>\n<p>步骤：</p>\n<p>1、先找到firefox的安装rpm包，你需要挂载到我们安装的centos的iso文件</p>\n<p>2、到 /mdeia/ 下去找rpm</p>\n<pre class=\"highlight\"><code class=\"bash\">cp firefox-68.10.0-1.el7.centos.x86_64.rpm /opt/\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624122937.png\" alt=\"image-20210624122936318\" /></p>\n<h2 id=\"yum\"><a class=\"markdownIt-Anchor\" href=\"#yum\"></a> yum</h2>\n<h3 id=\"介绍-10\"><a class=\"markdownIt-Anchor\" href=\"#介绍-10\"></a> 介绍</h3>\n<p>Yum是一个shell<font color='red'>前端软件包管理器。</font>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<font color='red'>自动处理依赖关系</font>，并且一次安装所有依赖的软件包。（<font color='red'>有点像maven</font>）<font color='red'>使用yum的前提是可以联网。</font></p>\n<p>示意图</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624124019.png\" alt=\"image-20210624124018202\" /></p>\n<h3 id=\"yum的基本指令\"><a class=\"markdownIt-Anchor\" href=\"#yum的基本指令\"></a> yum的基本指令</h3>\n<p>查询yum服务是否具有需要安装的软件</p>\n<pre class=\"highlight\"><code class=\"bash\">yum  list  |  grep  xxx软件列表\n</code></pre>\n<p>安装指定的yum包</p>\n<pre class=\"highlight\"><code class=\"bash\">yum install xxx   下载安装  [-y]  -y 选项的意思是询问的时候默认都是yes\n</code></pre>\n<h3 id=\"yum应用实例\"><a class=\"markdownIt-Anchor\" href=\"#yum应用实例\"></a> yum应用实例</h3>\n<p>请使用yum的方式来安装firefox</p>\n<p>1）先查看firefox  rpm 在yum服务器上有没有</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624124334.png\" alt=\"image-20210624124333702\" /></p>\n<p>2）安装</p>\n<pre class=\"highlight\"><code class=\"bash\">yum insatll firefox\n默认会安装最新版本的软件\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624125045.png\" alt=\"image-20210624125044364\" /></p>\n<h3 id=\"yum的删除指令\"><a class=\"markdownIt-Anchor\" href=\"#yum的删除指令\"></a> yum的删除指令</h3>\n<pre class=\"highlight\"><code class=\"bash\">yum remove -y 软件名\n</code></pre>\n<h1 id=\"javaee定制篇-搭建javaee环境\"><a class=\"markdownIt-Anchor\" href=\"#javaee定制篇-搭建javaee环境\"></a> JavaEE定制篇 搭建JavaEE环境</h1>\n<h2 id=\"概述-2\"><a class=\"markdownIt-Anchor\" href=\"#概述-2\"></a> 概述</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624134137.png\" alt=\"image-20210624134136606\" /></p>\n<p>如果需要在Linux下进行JavaEE开发，需要安装如下软件</p>\n<h2 id=\"安装jdk\"><a class=\"markdownIt-Anchor\" href=\"#安装jdk\"></a> 安装jdk</h2>\n<ol start=\"0\">\n<li>\n<p>先将软件通过xftp7上传到/opt</p>\n</li>\n<li>\n<p>解压缩到/opt</p>\n</li>\n</ol>\n<p>2)修改/etc/profile配置文件（<font color='red'>vim /etc/profile</font>）</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624181309.png\" alt=\"image-20210624181308670\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">JAVA_HOME=/opt/jdk1.7.0_79\nPATH=/opt/jdk1.7.0_79/bin:<span class=\"hljs-variable\">$PATH</span>\n<span class=\"hljs-built_in\">export</span> JAVA_HOME PATH\n</code></pre>\n<ol start=\"3\">\n<li>需要注销用户，环境变量才能生效</li>\n</ol>\n<p>1、如果是3运行级别，直接logout</p>\n<p>2、如果是5运行级别  （<font color='red'>可以使用 source /etc/profile 来刷新配置文件</font>）</p>\n<p>先用javac指令生成字节码文件，再用java指令运行。</p>\n<pre class=\"highlight\"><code class=\"bash\">javac Hello.java \njava Hello\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624183256.png\" alt=\"image-20210624183255605\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624183426.png\" alt=\"image-20210624183425081\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624183330.png\" alt=\"image-20210624183329066\" /></p>\n<h2 id=\"安装tomcat\"><a class=\"markdownIt-Anchor\" href=\"#安装tomcat\"></a> 安装tomcat</h2>\n<h3 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h3>\n<p>1、先通过xftp传输压缩包到Linux上，然后解压到/opt</p>\n<pre class=\"highlight\"><code class=\"bash\">tar -zxvf apache-tomcat-7.0.70.tar.gz\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624184016.png\" alt=\"image-20210624184015616\" /></p>\n<p>2、启动tomca ./startup.sh</p>\n<p>先进入到tomcat的bin目录</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624191150.png\" alt=\"image-20210624191149690\" /></p>\n<pre class=\"highlight\"><code class=\"bash\">./startup.sh  启动tomcat\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210624191418.png\" alt=\"image-20210624191416250\" /></p>\n<p>使用Linux本地的浏览器是可以访问到tomcat</p>\n<p>3)开放放端口  vim/etc/sysconfig/firewall</p>\n<p>在windows下访问http://localhost:8080/</p>\n<h2 id=\"eclipse的安装\"><a class=\"markdownIt-Anchor\" href=\"#eclipse的安装\"></a> eclipse的安装</h2>\n<h3 id=\"步骤-2\"><a class=\"markdownIt-Anchor\" href=\"#步骤-2\"></a> 步骤</h3>\n<p>1）解压到/opt</p>\n<pre class=\"highlight\"><code class=\"bash\">tar -zxvf eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz \n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210625112930.png\" alt=\"image-20210625112922649\" /></p>\n<p>2）启动eclipse，配置jre和server</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> 切换到eclipse目录下\n然后再用 ./eclipse 进行启动\n</code></pre>\n<p>3）编写Hello World程序并测试成功</p>\n<p>4）编写jsp页面并测试成功</p>\n<h2 id=\"mysql的安装和配置\"><a class=\"markdownIt-Anchor\" href=\"#mysql的安装和配置\"></a> mysql的安装和配置</h2>\n<p>1、先查看是否已经下载了mysql</p>\n<pre class=\"highlight\"><code class=\"sql\">rpm -qa | grep mysql\n</code></pre>\n<p>如果有就删掉</p>\n<pre class=\"highlight\"><code class=\"bash\">rpm -e (--nodeps强制删除) mysql-libs\n</code></pre>\n<p>2、安装mysql的环境</p>\n<pre class=\"highlight\"><code class=\"bash\">yum -y install make gcc-c++ cmake bsion-devel ncurses-devel\n</code></pre>\n<p>3、解压mysql包</p>\n<pre class=\"highlight\"><code class=\"bash\"> tar -zxvf mysql-5.6.14.tar.gz \n</code></pre>\n<p>4、切换到MySQL的目录下</p>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-built_in\">cd</span> mysql-5.6.14/ \n</code></pre>\n<h1 id=\"shell编程\"><a class=\"markdownIt-Anchor\" href=\"#shell编程\"></a> shell编程</h1>\n<h2 id=\"为什么要学shell编程\"><a class=\"markdownIt-Anchor\" href=\"#为什么要学shell编程\"></a> 为什么要学shell编程？</h2>\n<p>1）Linux运维工程师再进行对服务器集群管理时，需要编写shell程序来进行服务器的管理。</p>\n<p>2）对于JavaEE和python程序员来说，工作需要，需要些shell脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。</p>\n<p>3）对于大数据程序员来说，需要编写Shell程序来管理集群。</p>\n<h2 id=\"shell是什么\"><a class=\"markdownIt-Anchor\" href=\"#shell是什么\"></a> Shell是什么</h2>\n<p>shell是一个命令行解释器，它为用户提供一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626093328.png\" alt=\"image-20210626093320313\" /></p>\n<h2 id=\"shell编程快速入门-shell脚本的执行方式\"><a class=\"markdownIt-Anchor\" href=\"#shell编程快速入门-shell脚本的执行方式\"></a> shell编程快速入门-shell脚本的执行方式</h2>\n<h3 id=\"脚本的要求\"><a class=\"markdownIt-Anchor\" href=\"#脚本的要求\"></a> 脚本的要求</h3>\n<p>1）脚本以#!/bin/bash开头 （告诉编辑器是用bash来进行解析的）</p>\n<p>2）脚本需要有可执行权限</p>\n<h3 id=\"编写第一个shell脚本\"><a class=\"markdownIt-Anchor\" href=\"#编写第一个shell脚本\"></a> 编写第一个shell脚本</h3>\n<p>需求说明</p>\n<p>创建一个shell脚本，输出hello world！</p>\n<p>查看案例：</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626093948.png\" alt=\"image-20210626093947711\" /></p>\n<h3 id=\"脚本的常用执行方式\"><a class=\"markdownIt-Anchor\" href=\"#脚本的常用执行方式\"></a> 脚本的常用执行方式</h3>\n<p>方式一：（输入脚本的绝对路径或者相对路径）</p>\n<p>1）首先要赋予helloworld.sh脚本的\t+x权限</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626094501.png\" alt=\"image-20210626094500814\" /></p>\n<p>方式二（sh+脚本，<font color='red'>不推荐使用</font>）</p>\n<p>说明：不用赋予脚本+x权限，直接执行即可</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626094834.png\" alt=\"image-20210626094834001\" /></p>\n<h2 id=\"shell的变量\"><a class=\"markdownIt-Anchor\" href=\"#shell的变量\"></a> shell的变量</h2>\n<h3 id=\"shell的变量的介绍\"><a class=\"markdownIt-Anchor\" href=\"#shell的变量的介绍\"></a> shell的变量的介绍</h3>\n<p>1）Linux  Shell 中的变量分为，<font color='red'>系统变量</font>和<font color='red'>用户自定义变量</font>。</p>\n<p>2）系统变量：SHOME 、 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mi>W</mi><mi>D</mi><mi mathvariant=\"normal\">、</mi></mrow><annotation encoding=\"application/x-tex\">PWD 、</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord cjk_fallback\">、</span></span></span></span>SHELL、 $USER等等</p>\n<p>比如：echo $HOME  等等</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626095649.png\" alt=\"image-20210626095648035\" /></p>\n<p>3）显示当前shell中的所有变量：set</p>\n<h3 id=\"shell变量的定义\"><a class=\"markdownIt-Anchor\" href=\"#shell变量的定义\"></a> shell变量的定义</h3>\n<p>基本语法</p>\n<p>1）定义变量：变量=值</p>\n<p>2）撤销变量：unset  变量</p>\n<p>3）声明静态变量：readonly  变量，注意：不能用unset</p>\n<p>快速入门</p>\n<p>案例1：定义变量A</p>\n<p>案例2：撤销变量A</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626100740.png\" alt=\"image-20210626100739165\" /></p>\n<p>​\t案例3：声明一个只读变量B=2 （<font color='red'>readonly   就相当于Java中的final</font>），不能unset</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210626101954.png\" alt=\"image-20210626101953724\" /></p>\n<p>案例四：可以把一个变量提升为一个全局环境变量，可供其他shell程序使用</p>\n<h3 id=\"定义变量的规则\"><a class=\"markdownIt-Anchor\" href=\"#定义变量的规则\"></a> 定义变量的规则</h3>\n<p>1）变量名称可以由字母数字和下划线组成，但是不能以数字开头。</p>\n<p>2）等号两侧不能有空格</p>\n<p>3）变量名称一般习惯大写</p>\n<h3 id=\"将命令的返回值赋值给变量重点\"><a class=\"markdownIt-Anchor\" href=\"#将命令的返回值赋值给变量重点\"></a> 将命令的返回值赋值给变量（重点）</h3>\n<pre class=\"highlight\"><code class=\"shell\">A=`ls -la`反引号，运行里面的命令，并把结果返回给变量A\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628103515.png\" alt=\"image-20210628103507936\" /></p>\n<h2 id=\"设置环境变量\"><a class=\"markdownIt-Anchor\" href=\"#设置环境变量\"></a> 设置环境变量</h2>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628103906.png\" alt=\"image-20210628103906011\" /></p>\n<h3 id=\"基本语法-35\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-35\"></a> 基本语法</h3>\n<p>1）export  变量名=变量值 \t（功能描述：将shell变量输出为环境变量）</p>\n<p>2）source\t配置文件\t\t\t（功能描述：让修改后的文件信息立即生效）</p>\n<p>3）在另一个shell程序中使用TOMCAT_HOME</p>\n<p>注意：在输出TOMCAT_HOME环境变量前，要让起生效</p>\n<p><font color='red'>这个是刷新配置文件的意思：source/etc/profile</font></p>\n<pre class=\"highlight\"><code class=\"shell\">多行注释   :&lt;&lt;! 要注释的内容  !\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628105154.png\" alt=\"image-20210628105153321\" /></p>\n<h2 id=\"位置参数变量\"><a class=\"markdownIt-Anchor\" href=\"#位置参数变量\"></a> 位置参数变量</h2>\n<h3 id=\"介绍-11\"><a class=\"markdownIt-Anchor\" href=\"#介绍-11\"></a> 介绍</h3>\n<p>当我们执行一个shell脚本时，如果希望获得命令行的参数信息。就可以使用到位置参数变量。比如：./myshell.sh 100 200 ，这个就是执行shell命令行，可以在myshell脚本中获取到参数信息  （<font color='red'>有点类似于Java方法传参数</font>）</p>\n<h3 id=\"基本语法-36\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-36\"></a> 基本语法</h3>\n<p>$n（功能描述：n为数字，$0代表命令本身，$1-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>9</mn><mi mathvariant=\"normal\">代</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">第</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">到</mi><mi mathvariant=\"normal\">第</mi><mi mathvariant=\"normal\">九</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">十</mi><mi mathvariant=\"normal\">以</mi><mi mathvariant=\"normal\">上</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">需</mi><mi mathvariant=\"normal\">要</mi><mi mathvariant=\"normal\">用</mi><mi mathvariant=\"normal\">大</mi><mi mathvariant=\"normal\">括</mi><mi mathvariant=\"normal\">号</mi><mi mathvariant=\"normal\">包</mi><mi mathvariant=\"normal\">含</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">如</mi></mrow><annotation encoding=\"application/x-tex\">9代表第一到第九个参数，十以上的参数需要用大括号包含，如</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">到</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">九</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">十</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">上</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">需</span><span class=\"mord cjk_fallback\">要</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">括</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">包</span><span class=\"mord cjk_fallback\">含</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">如</span></span></span></span>{10}）</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∗</mo><mi mathvariant=\"normal\">（</mi><mi mathvariant=\"normal\">功</mi><mi mathvariant=\"normal\">能</mi><mi mathvariant=\"normal\">描</mi><mi mathvariant=\"normal\">述</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">这</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi><mi mathvariant=\"normal\">代</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">命</mi><mi mathvariant=\"normal\">令</mi><mi mathvariant=\"normal\">行</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">有</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">，</mi><mo>&lt;</mo><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><msup><mo>=</mo><mo mathvariant=\"normal\">′</mo></msup><mi>r</mi><mi>e</mi><msup><mi>d</mi><mo mathvariant=\"normal\">′</mo></msup><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">* （功能描述：这个变量代表命令行中所有参数，&lt;font color=&#x27;red&#x27;&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∗</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord cjk_fallback\">功</span><span class=\"mord cjk_fallback\">能</span><span class=\"mord cjk_fallback\">描</span><span class=\"mord cjk_fallback\">述</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">这</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">命</span><span class=\"mord cjk_fallback\">令</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">=</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.790992em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>*把所有的参数看成一个整体</font>）</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">@</mi><mi mathvariant=\"normal\">（</mi><mi mathvariant=\"normal\">功</mi><mi mathvariant=\"normal\">能</mi><mi mathvariant=\"normal\">描</mi><mi mathvariant=\"normal\">述</mi><mi mathvariant=\"normal\">：</mi><mi mathvariant=\"normal\">这</mi><mi mathvariant=\"normal\">个</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">量</mi><mi mathvariant=\"normal\">也</mi><mi mathvariant=\"normal\">代</mi><mi mathvariant=\"normal\">表</mi><mi mathvariant=\"normal\">命</mi><mi mathvariant=\"normal\">令</mi><mi mathvariant=\"normal\">行</mi><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">所</mi><mi mathvariant=\"normal\">有</mi><mi mathvariant=\"normal\">参</mi><mi mathvariant=\"normal\">数</mi><mi mathvariant=\"normal\">，</mi><mo>&lt;</mo><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><msup><mo>=</mo><mo mathvariant=\"normal\">′</mo></msup><mi>r</mi><mi>e</mi><msup><mi>d</mi><mo mathvariant=\"normal\">′</mo></msup><mo>&gt;</mo><mi mathvariant=\"normal\">不</mi><mi mathvariant=\"normal\">过</mi></mrow><annotation encoding=\"application/x-tex\">@（功能描述：这个变量也代表命令行中的所有参数，&lt;font color=&#x27;red&#x27;&gt;不过</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">@</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord cjk_fallback\">功</span><span class=\"mord cjk_fallback\">能</span><span class=\"mord cjk_fallback\">描</span><span class=\"mord cjk_fallback\">述</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">这</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">也</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">命</span><span class=\"mord cjk_fallback\">令</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">参</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">，</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">=</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.790992em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">不</span><span class=\"mord cjk_fallback\">过</span></span></span></span>@把每个参数区分对待</font>)</p>\n<p>$#（功能描述：这个变量代表命令行中的所有参数的个数）</p>\n<h3 id=\"位置参数变量的应用实例\"><a class=\"markdownIt-Anchor\" href=\"#位置参数变量的应用实例\"></a> 位置参数变量的应用实例</h3>\n<p>案例：<a href=\"http://xn--shellpositionPara-ps50a2ww64c910i463elyj.sh\">编写一个shell脚本positionPara.sh</a>，在脚本中获得命令行中各个参数信息</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628172432.png\" alt=\"image-20210628172425041\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628172520.png\" alt=\"image-20210628172519512\" /></p>\n<h2 id=\"预定义变量\"><a class=\"markdownIt-Anchor\" href=\"#预定义变量\"></a> 预定义变量</h2>\n<h3 id=\"基本介绍-22\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-22\"></a> 基本介绍</h3>\n<p>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用。</p>\n<h3 id=\"基本语法-37\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-37\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\">$\t\t\t\t（功能描述：当前进程的进程号（pid））</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\">!\t\t\t\t（功能描述：后台运行的最后一个进程的进程号（pid））</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\">?\t\t\t\t（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</span>\n\n</code></pre>\n<h3 id=\"应用实例-35\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-35\"></a> 应用实例</h3>\n<p>在一个shell脚本中简单使用一下预定义变量。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210628214100.png\" alt=\"image-20210628214059047\" /></p>\n<h2 id=\"运算符\"><a class=\"markdownIt-Anchor\" href=\"#运算符\"></a> 运算符</h2>\n<h3 id=\"基本介绍-23\"><a class=\"markdownIt-Anchor\" href=\"#基本介绍-23\"></a> 基本介绍</h3>\n<p>学习如何在shell中进行运算操作</p>\n<h3 id=\"基本语法-38\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-38\"></a> 基本语法</h3>\n<p>1）“<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">运</mi><mi mathvariant=\"normal\">算</mi><mi mathvariant=\"normal\">式</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">”</mi><mi mathvariant=\"normal\">或</mi><mi mathvariant=\"normal\">“</mi></mrow><annotation encoding=\"application/x-tex\">((运算式))”  或 “</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">运</span><span class=\"mord cjk_fallback\">算</span><span class=\"mord cjk_fallback\">式</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mord\">”</span><span class=\"mord cjk_fallback\">或</span><span class=\"mord\">“</span></span></span></span>[运算式]”</p>\n<p>2）expr m  +  n</p>\n<p>注意expr运算符间要有空格</p>\n<p>3）expr  m  -n</p>\n<p>4）expr  \\* , / , % 乘，除，取余   （expr ： expression）</p>\n<ul>\n<li>应用实例</li>\n<li><font color='red'>注意在写shell脚本的时候变量和等号之间不要有空格</font></li>\n</ul>\n<p>案例一：计算（2+3）X4的值</p>\n<ol>\n<li>$((运算式))<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705161642.png\" alt=\"image-20210705161634409\" /></li>\n<li>$[运算式]<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705161853.png\" alt=\"image-20210705161851739\" /></li>\n<li>expr<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705163238.png\" alt=\"image-20210705163236697\" /></li>\n</ol>\n<p>案例二：请求算出命令行两个参数之和<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705164141.png\" alt=\"image-20210705164140704\" /></p>\n<h2 id=\"条件判断\"><a class=\"markdownIt-Anchor\" href=\"#条件判断\"></a> 条件判断</h2>\n<h3 id=\"基本语法-39\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-39\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\">[ condition ] (注意condition前后要有空格)\n<span class=\"hljs-meta\">#</span><span class=\"bash\">非空返回<span class=\"hljs-literal\">true</span>,可使用$?验证(0为<span class=\"hljs-literal\">true</span>,&gt;1为<span class=\"hljs-literal\">false</span>)</span>\n</code></pre>\n<h3 id=\"应用实例-36\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-36\"></a> 应用实例</h3>\n<pre class=\"highlight\"><code class=\"shell\">[ atguigu ]\t\t\t返回true\n[]  \t\t\t\t返回false\n[ condition ] &amp;&amp; echo OK  || echo notok  条件满足,执行后面的语句\n</code></pre>\n<h3 id=\"判断语句\"><a class=\"markdownIt-Anchor\" href=\"#判断语句\"></a> 判断语句</h3>\n<ul>\n<li>常用的判断条件</li>\n</ul>\n<p>1）  两个整数的比较</p>\n<pre class=\"highlight\"><code class=\"shell\">=字符串的比较\n-lt小于  lt=less than\n-le小于等于  \n-eq等于   eq=equal than\n-gt大于   gt=great than\n-ge大于等于 ge=great equal\n-ne不等于  ne=not equal\n</code></pre>\n<h3 id=\"按照文件所有权进行判断\"><a class=\"markdownIt-Anchor\" href=\"#按照文件所有权进行判断\"></a> 按照文件所有权进行判断</h3>\n<pre class=\"highlight\"><code class=\"bash\">-r  有读的权限\n-w  有些的权限\n-x  有执行的权限\n</code></pre>\n<h3 id=\"按照文件类型进行判断\"><a class=\"markdownIt-Anchor\" href=\"#按照文件类型进行判断\"></a> 按照文件类型进行判断</h3>\n<pre class=\"highlight\"><code class=\"bash\">-f  文件存在并且是个常规文件\n-e  文件存在\n-d  文件存在并且是个目录\n</code></pre>\n<h3 id=\"应用实例-37\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-37\"></a> 应用实例</h3>\n<p>案例一：“ok”是否等于“ok”</p>\n<p>判断语句：<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705181745.png\" alt=\"image-20210705181744621\" /></p>\n<p>案例二：判断23是否大于等于22</p>\n<pre class=\"highlight\"><code class=\"shell\">这里的结束 fi ，就是把 if 反着写，后面的要学的 case   结束的关键字就是 esac\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705182352.png\" alt=\"image-20210705182351705\" /></p>\n<p>案例三：判断/root/shell/aaa.txt是否存在</p>\n<p>判断语句：</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705182924.png\" alt=\"image-20210705182923634\" /></p>\n<h1 id=\"shell-流程控制\"><a class=\"markdownIt-Anchor\" href=\"#shell-流程控制\"></a> shell 流程控制</h1>\n<h2 id=\"if判断\"><a class=\"markdownIt-Anchor\" href=\"#if判断\"></a> if判断</h2>\n<h3 id=\"基本语法-40\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-40\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"bash\"><span class=\"hljs-keyword\">if</span> [ 条件判断式 ];\n\t<span class=\"hljs-keyword\">then</span>\n\t程序\n\t<span class=\"hljs-keyword\">elif</span> [ 条件判断式 ]\n\t<span class=\"hljs-keyword\">then</span>\n\t程序 \n<span class=\"hljs-keyword\">fi</span>\t\n或者\n<span class=\"hljs-keyword\">if</span> [ 条件判断式 ]\t\t\n\t<span class=\"hljs-keyword\">then</span>\n\t程序\n\t<span class=\"hljs-keyword\">elif</span> [ 条件判断式 ]\n\t<span class=\"hljs-keyword\">then</span>\n\t程序 \n<span class=\"hljs-keyword\">fi</span>\t\n</code></pre>\n<p>注意事项：（1）[  条件判断式  ] ，中括号和条件判断式之间必须有空格</p>\n<p>（2）推荐使用第二种方式</p>\n<h3 id=\"应用案例-5\"><a class=\"markdownIt-Anchor\" href=\"#应用案例-5\"></a> 应用案例</h3>\n<p>#案例：请编写一个shell程序，如果输入的参数大于等于60，则输出”及格了“ ，如果小于60，则输出“不及格”  <img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705202738.png\" alt=\"image-20210705202737022\" /></p>\n<h2 id=\"case语句\"><a class=\"markdownIt-Anchor\" href=\"#case语句\"></a> case语句</h2>\n<h3 id=\"基本语法-41\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-41\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\">case $变量名  in   \n\"值1\"）\n如果变量名等于值1，则执行程序1\n;;\n\"值2\"）\n如果变量等于值2,则执行程序2\n;;\n...省略其他分支...\n*)\n如果变量的值都不是以上的值，则执行此程序\n;;\nesac\n</code></pre>\n<h3 id=\"应用案例-6\"><a class=\"markdownIt-Anchor\" href=\"#应用案例-6\"></a> 应用案例</h3>\n<p>案例1：当命令行参数是1时，输出“周一”，是2时，输出“周二”，其他情况输出“other”</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705214123.png\" alt=\"image-20210705214122831\" /></p>\n<h2 id=\"for循环\"><a class=\"markdownIt-Anchor\" href=\"#for循环\"></a> for循环</h2>\n<h3 id=\"基本语法这个相当于增强for循环foreach\"><a class=\"markdownIt-Anchor\" href=\"#基本语法这个相当于增强for循环foreach\"></a> 基本语法（这个相当于增强for循环，foreach）</h3>\n<pre class=\"highlight\"><code class=\"shell\">for  变量  in 值1  值2 值3 ...\ndo\n程序\ndone\n</code></pre>\n<h3 id=\"应用实例-38\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-38\"></a> 应用实例</h3>\n<p>案例1：打印命令行输入的参数【会使用到$*  $@】</p>\n<p><font color='red'>这里的$i表示的是引用上面的i的意思</font></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210705220258.png\" alt=\"image-20210705220256804\" /></p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210706164642.png\" alt=\"image-20210706164634006\" /></p>\n<h3 id=\"基本语法-42\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-42\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\">for ((初始值;循环控制条件;变量变化))\ndo\n程序\ndone\n</code></pre>\n<h3 id=\"应用实例-39\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-39\"></a> 应用实例</h3>\n<p>案例1：从一加到一百的值输出显示[这里可以看出$* 和 $@的区别]</p>\n<pre class=\"highlight\"><code class=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">求1到100的值</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">定义一个结果变量</span>\nsum=0\nfor ((i=1;i &lt;= 100 ;i++ ))\n\ndo\nsum=$[ $sum+i ]\ndone\necho \"sum=$sum\"\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210706165737.png\" alt=\"image-20210706165734779\" /></p>\n<h2 id=\"while循环\"><a class=\"markdownIt-Anchor\" href=\"#while循环\"></a> while循环</h2>\n<h3 id=\"基本语法-43\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-43\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\">while  [条件判断式]\ndo\n程序\ndone\n</code></pre>\n<h3 id=\"应用实例-40\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-40\"></a> 应用实例</h3>\n<p>案例一：从命令行输出一个数n，统计从1+…+n的值是多少？</p>\n<h2 id=\"读取控制台的输入\"><a class=\"markdownIt-Anchor\" href=\"#读取控制台的输入\"></a> 读取控制台的输入</h2>\n<h3 id=\"基本语法-44\"><a class=\"markdownIt-Anchor\" href=\"#基本语法-44\"></a> 基本语法</h3>\n<pre class=\"highlight\"><code class=\"shell\">read (选项)  (参数)\n选项：\n-p ：指定读取时的提示符号\n-t ：指定读取时等待的时间(秒),如果没有在指定的时间内输入，就不再等待了\n参数\n变量：指定读取值的变量名\n</code></pre>\n<h3 id=\"应用实例-41\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-41\"></a> 应用实例</h3>\n<p>案例一：从控制台读取一个num值。</p>\n<p>​\t<img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210706172934.png\" alt=\"image-20210706172933098\" /></p>\n<p>案例二：读取控制台输入一个num值，在10秒内输入。</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210706172957.png\" alt=\"image-20210706172956207\" /></p>\n<h2 id=\"函数\"><a class=\"markdownIt-Anchor\" href=\"#函数\"></a> 函数</h2>\n<h3 id=\"函数介绍\"><a class=\"markdownIt-Anchor\" href=\"#函数介绍\"></a> 函数介绍</h3>\n<p>shell编程和其它语言一样，有系统函数，也可以有自定义函数。在系统函数中，就介绍这两个。</p>\n<h3 id=\"系统函数\"><a class=\"markdownIt-Anchor\" href=\"#系统函数\"></a> 系统函数</h3>\n<ul>\n<li>bashname基本语法</li>\n</ul>\n<p>功能：返回完整路径下最后 / 部分，常用于获取文件名</p>\n<pre class=\"highlight\"><code class=\"shell\">basename [pathname]  [suffix]\nbasename [string]  [suffix]  功能描述：basename命令会删掉所有的前缀包括最后一个('/')\n字符,然后将字符显示出来\n选项\nsuffix 为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉\n</code></pre>\n<h3 id=\"应用实例-42\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-42\"></a> 应用实例</h3>\n<p>案例一：请返回\t/home/aaa/test.txt的”test.txt“部分</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707101506.png\" alt=\"image-20210707101457436\" /></p>\n<h3 id=\"dirname基本语法\"><a class=\"markdownIt-Anchor\" href=\"#dirname基本语法\"></a> dirname基本语法</h3>\n<p>功能：返回完整路径最后 / 的前面的部分，常用于返回路径部分</p>\n<p>dirname文件绝对路径(功能描述：从给定的包含绝对路径的文件中去除文件名（非目录部分），然后返回剩下的路径（目录部分）)</p>\n<h3 id=\"应用实例-43\"><a class=\"markdownIt-Anchor\" href=\"#应用实例-43\"></a> 应用实例</h3>\n<p>案例一：请返回/home/aaa/test.txt的/home/aaa</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707102534.png\" alt=\"image-20210707102533380\" /></p>\n<h3 id=\"自定义函数\"><a class=\"markdownIt-Anchor\" href=\"#自定义函数\"></a> 自定义函数</h3>\n<ul>\n<li><strong>基本语法</strong></li>\n</ul>\n<pre class=\"highlight\"><code class=\"shell\">[ function ] funname [()]\n&#123;\n\tAction;\n\t[return int;]\n\n&#125;\n调用直接写函数名： funname\n注意[]这个是可选的，里面的内容可写可不写\n</code></pre>\n<ul>\n<li><strong>应用实例</strong></li>\n</ul>\n<p>案例1：计算输出两个参数的和，getSum</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707104023.png\" alt=\"image-20210707104022527\" /></p>\n<h2 id=\"shell编程的综合案例\"><a class=\"markdownIt-Anchor\" href=\"#shell编程的综合案例\"></a> shell编程的综合案例</h2>\n<h3 id=\"需求分析\"><a class=\"markdownIt-Anchor\" href=\"#需求分析\"></a> 需求分析</h3>\n<ol>\n<li>每天凌晨2:10备份数据库atguiguDB到/data/backup/db</li>\n<li>备份开始和备份结束能够给出相应的提示信息</li>\n<li>备份后的文件要求以备份时间为文件名，并打成.tar.gz的形式，比如： 2018-03-12_230201.tar.gz</li>\n<li>在备份的同时，检查是否有10天前的备份的数据库文件，如果有就将其删除</li>\n</ol>\n<p>编写一个shell脚本。</p>\n<p>思路分析：</p>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707154849.png\" alt=\"image-20210707154848109\" /></p>\n<p>代码实现：</p>\n<pre class=\"highlight\"><code class=\"shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">完成数据库的定时备份</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">定义备份的路径</span>\nBACKUP=/data/backup/db\n<span class=\"hljs-meta\">#</span><span class=\"bash\">当前的时间作为文件名</span>\nDATETIME=$(date +%Y_%m_%d_%H%M%S)\n<span class=\"hljs-meta\">#</span><span class=\"bash\">可以输出变量调试</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$DATETIME</span></span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">完成数据库的定时备份</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">定义备份的路径</span>\nBACKUP=/data/backup/db\n<span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">完成数据库的定时备份</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">定义备份的路径</span>\nBACKUP=/data/backup/db\n<span class=\"hljs-meta\">#</span><span class=\"bash\">当前的时间作为文件名</span>\nDATETIME=$(date +%Y_%m_%d_%H%M%S)\n<span class=\"hljs-meta\">#</span><span class=\"bash\">可以输出变量调试</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$DATETIME</span></span>\necho \"======开始备份======\"\necho \"======备份的路径是$BACKUP/$DATETIME.tar.gz ======\"\n<span class=\"hljs-meta\">\n#</span><span class=\"bash\">主机</span>\nHOST=localhost\n<span class=\"hljs-meta\">#</span><span class=\"bash\">用户名</span>\nDB_USER=root\n<span class=\"hljs-meta\">#</span><span class=\"bash\">密码</span>\nDB_PWD=root\n<span class=\"hljs-meta\">#</span><span class=\"bash\">备份数据库名</span>\nDATABASE=atguiguDB\n<span class=\"hljs-meta\">#</span><span class=\"bash\">创建备份的路径</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">如果备份的文件夹存在就使用，否则就创建</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">mkdir -p ：递归创建目录，即使上级目录不存在，会按目录层级自动创建目录</span>\n [ ! -d \"$BACKUP/$DATETIM\"   ] &amp;&amp; mkdir -p \"$BACKUP/$DATETIME\"\n<span class=\"hljs-meta\">#</span><span class=\"bash\">执行mysql的备份数据库的指令</span>\nmysqldump   -u$&#123;DB_USER&#125; -P$&#123;DB_PWD&#125;   --host=$HOST   $DATABASE | gzip  &gt;  $BACKUP/$DATETIME.sql.gz\n<span class=\"hljs-meta\">#</span><span class=\"bash\">打包备份文件</span>\ncd $BACKUP\ntar -zcvf $DATETIME.tar.gz  $DATETIME\n<span class=\"hljs-meta\">#</span><span class=\"bash\">删除临时目录</span>\nrm -rf $BACKUP/$DATETIME\n<span class=\"hljs-meta\">#</span><span class=\"bash\">删除十天前的备份文件</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">下面那条指令的意思：find是查找指令，-m表示按照时间查找+10表示十天前的 </span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\">-name 表示按照名称查找以.tar.gz结尾的文件   </span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">exec</span>代表着执行 执行后面的  rm -rf &#123;&#125; \\; 就是删除找到的那些文件，这个是一个固定的写法</span>\nfind $BCAKUP  -m  +10  -name  \"*.tar.gz\" -exec  rm -rf &#123;&#125; \\;\necho \"======备份文件成功======\"\n</code></pre>\n<p><img src=\"https://qlwy.oss-cn-shenzhen.aliyuncs.com/img/20210707194758.png\" alt=\"image-20210707194750770\" /></p>\n<p><font color='red'>2020/7/7Linux学习完结撒花</font></p>\n<p>77事变84周年，吾辈当自强</p>\n<h1 id=\"linux中的一些补充知识\"><a class=\"markdownIt-Anchor\" href=\"#linux中的一些补充知识\"></a> Linux中的一些补充知识</h1>\n<h2 id=\"软链接和硬连接\"><a class=\"markdownIt-Anchor\" href=\"#软链接和硬连接\"></a> 软链接和硬连接</h2>\n<p>一个硬连接仅仅是一个文件名。（一个文件可以有好几个文件名，只有将最后一个文件名从磁盘上删除，才能把这个文件删掉。文件名的个数是由ls(1)来确定的。所有的文件名都处于同一个状态，也就没有什么“源名字”之说。通常文件系统里的一个文件的所有名字包含着一样的数据信息，不过这样也不是必需的。）一个软连接（或符号连接）是完全不同的：它是一个包含了路径信息的小小的指定文件。因此，软连接可以指向不同文件系统里的文件（比如由NFS装载的不同机器文件系统上的文件），甚至可以指向一个不一定确实存在的文件。在软连接文件被访问（系统调用open(2)或stat(2)）的时候，操作系统用该文件所包含的路径替换该文件的访问介入点，从而实现对所指文件的访问。（用命令rm(1)和unlink(2)可以删除连接，但  不是删除该文件所指向的文件。系统指定调用lstat(2)和read‐link(2)                    来读取连接文件与其所指文件的状态。到底是对软连接文件操作，还是对被指向文件操作，由于不同操作系统件存在不同的系统调用，而存在着差异。）</p>\n<h2 id=\"在linux中启动程序\"><a class=\"markdownIt-Anchor\" href=\"#在linux中启动程序\"></a> 在Linux中启动程序</h2>\n<ol>\n<li>进入到bin文件夹中使用./脚本文件</li>\n</ol>\n<pre class=\"highlight\"><code class=\"bash\">./zkServer.sh start\n</code></pre>\n<ol start=\"2\">\n<li>使用bin文件夹外面使用bin/zkServer.sh</li>\n</ol>\n<pre class=\"highlight\"><code class=\"bash\">bin/zkServer.sh \n</code></pre>\n<ol start=\"3\">\n<li>直接配置环境变量</li>\n</ol>\n<h1 id=\"linux中的一些坑\"><a class=\"markdownIt-Anchor\" href=\"#linux中的一些坑\"></a> Linux中的一些坑</h1>\n<p>如果网络出现问题，可以使用</p>\n<pre class=\"highlight\"><code class=\"bash\">systemctl start NetworkM\n</code></pre>\n<pre class=\"highlight\"><code class=\"xml\"><span class=\"hljs-comment\">&lt;!--more--&gt;</span>\n</code></pre>\n","categories":["linux"],"tags":["linux"]},{"title":"mysql事务隔离级别","url":"/2022/01/18/mysql/","content":"<h1 id=\"事务隔离级别图文详解\"><a class=\"markdownIt-Anchor\" href=\"#事务隔离级别图文详解\"></a> 事务隔离级别(图文详解)</h1>\n<h2 id=\"什么是事务\"><a class=\"markdownIt-Anchor\" href=\"#什么是事务\"></a> 什么是事务?</h2>\n<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"常用的事务控制语法\"><a class=\"markdownIt-Anchor\" href=\"#常用的事务控制语法\"></a> 常用的事务控制语法</h3>\n<pre class=\"highlight\"><code class=\"mysq\">- 事务开始\nbegin;\n- 事务提交，提交后就会写入物理磁盘中去\ncommit;\n- 事务回滚，事务提交后，无法回滚\nrollback;\n\n</code></pre>\n<h2 id=\"事务的四大特性acid\"><a class=\"markdownIt-Anchor\" href=\"#事务的四大特性acid\"></a> 事务的四大特性（ACID）</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173945.png\" alt=\"image-20211231191231001\" /></p>\n<ol>\n<li><strong><font color='red'>原子性（atomicity）</font>：</strong> **事务是最小的执行单位，不允许分割。**事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong><font color='red'>一致性（consistency）</font>：</strong> <strong>执行事务前后，数据保持一致</strong>，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong><font color='red'>隔离性（isolation）</font>：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，<strong>各并发事务之间数据库是独立的；</strong></li>\n<li><strong><font color='red'>持久性（durability）</font>：</strong> <strong>一个事务被提交之后。它对数据库中数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<span id=\"more\"></span> \n<h2 id=\"关闭mysql的事务自动提交\"><a class=\"markdownIt-Anchor\" href=\"#关闭mysql的事务自动提交\"></a> 关闭mysql的事务自动提交</h2>\n<pre class=\"highlight\"><code class=\"mysql\">SET autocommit = 0|1|ON|OFF;\n</code></pre>\n<p>对取值的说明：</p>\n<p>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。<br />\n值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</p>\n<h2 id=\"数据库的隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#数据库的隔离级别\"></a> 数据库的隔离级别</h2>\n<h3 id=\"事务隔离级别的定义\"><a class=\"markdownIt-Anchor\" href=\"#事务隔离级别的定义\"></a> 事务隔离级别的定义</h3>\n<p>事务指定一个隔离级别，该隔离级别**定义一个事务必须与由其他事务进行的资源或数据更改相隔离的程度。**隔离级别从允许的并发副作用（例如，脏读或幻读的角度进行描述。</p>\n<pre class=\"highlight\"><code class=\"mysql\">- 查看隔离级别,8.0版本之前的，用SELECT @@tx_isolation\nselect @@transaction_isolation;\n\n- 修改隔离级别\nset session transaction isolation level  READ UNCOMMITTED;\n\n</code></pre>\n<h3 id=\"隔离级别的分类\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别的分类\"></a> 隔离级别的分类</h3>\n<p>**读未提交(READ-UNCOMMITTED)：**A事务操作后没有执行commit提交命令，但是B事务也能察觉到A操作的数据变化，此时B重新查询，则能查询出A操作后的最新数据，但是当A事务rollback回滚后，A操作的数据其实没有变化，这时候B处的数据就变成了脏数据(容易导致脏读情形产生)</p>\n<p>设置隔离级别为读未提交</p>\n<pre class=\"highlight\"><code class=\"mysql\">- 设置隔离级别\nset session transaction isolation level    read uncommitted;\n - 查看隔离级别\nselect  @@transaction_isolation;\n \n</code></pre>\n<p><strong>读已提交(不可重复读 read committed)oracle默认的隔离级别</strong>:读已提交，表示只有执行了commit命令后，才能得知数据的变化，A修改了数据，没有提交，B不会察觉到数据的变化。这样虽然会避免脏读，但是会出现，当A读取某一条数据时候，B正在对该数据进行操作(修改)，但是B操作并没有结束，因此此时数据并没有发生变化，但是A在B事务提交前已经执行完了，那就会出现数据不一致现象，这种问题叫做不可重复读。</p>\n<p>设置隔离级别为读已提交</p>\n<pre class=\"highlight\"><code class=\"mysql\"> - 设置隔离级别\nset session transaction isolation level    read committed;\n  - 查看隔离级别\nselect  @@transaction_isolation;\n\n\n</code></pre>\n<p><strong>可重复读(repeatable read mysql 的默认隔离级别)</strong></p>\n<p>可重复读与不可重复读很容易搞混淆，**可重复读侧重于有没有进行行增加减少，也就是新增和删除，而不可重复读侧重于修改操作，不影响行数。**可重复读是采用锁行形式，因为是锁行，所以无法保证对行数的操作限制隔离，只能保证当前锁住的行隔离影响。</p>\n<p><strong>串行化</strong></p>\n<p>最可靠的事务隔离级别。“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。因为串行化是锁表，因此虽然隔离级别最高，但是消耗资源最大</p>\n<p>mysql数据库默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ ）</strong></p>\n<pre class=\"highlight\"><code class=\"bash\">mysql&gt; select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| REPEATABLE-READ         |\n+-------------------------+\n1 row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">set</span> (0.00 sec)\n</code></pre>\n<p>修改数据库的事务隔离级别为<strong>不可重复读 READ-UNCOMMITTED</strong></p>\n<pre class=\"highlight\"><code class=\"bash\">mysql&gt; select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| READ-UNCOMMITTED        |\n+-------------------------+\n</code></pre>\n<p>这下面是MySQL8的事务隔离级别，MySQL5的话可重读读，还是会出现幻读</p>\n<table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交（read-uncommitted）</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td>否</td>\n<td>否</td>\n<td><strong>否</strong></td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"并发事务带来的问题\"><a class=\"markdownIt-Anchor\" href=\"#并发事务带来的问题\"></a> 并发事务带来的问题</h2>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ul>\n<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，然后后一个事务进行回滚，将数据变成之前的值，那么前一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<font color='red'><strong>（读取未提交数据）</strong></font></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">时间顺序</th>\n<th>转账事务</th>\n<th>取款事务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td></td>\n<td>开始事务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td>开始事务</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td></td>\n<td>查询账户余额为2000元</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td></td>\n<td>取款1000元，余额被更改为1000元</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td>查询账户余额为1000元（产生脏读）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td></td>\n<td>取款操作发生未知错误，事务回滚，余额变更为2000元</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td>转入2000元，余额被更改为3000元（脏读的1000+2000）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td>提交事务</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备注</td>\n<td>按照正确逻辑，此时账户余额应该为4000元</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>注意：这里要修改mysql的事务隔离级别为<strong>不可重复读（ READ-UNCOMMITTED ）</strong></p>\n<p>account表中的原始状态</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173951.png\" alt=\"image-20211231200932520\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173954.png\" alt=\"image-20211231201320508\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173957.png\" alt=\"image-20211231201342895\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173959.png\" alt=\"image-20211231201534124\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174001.png\" alt=\"image-20211231201641543\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174002.png\" alt=\"image-20220101115134146\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174005.png\" alt=\"image-20220101115237036\" /></p>\n<ul>\n<li>\n<p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>\n</li>\n<li>\n<p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<strong><font color='red'>（前后多次读取，数据内容不一致）</font></strong></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174008.png\" alt=\"image-20220101144933767\" /></p>\n<img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174009.png\" alt=\"image-20220101150808461\" />\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118174011.png\" alt=\"image-20220101150929999\" /></p>\n<ul>\n<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现<strong>多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。<strong><font color='red'>（前后多次读取，数据总量不一致）</font></strong></li>\n</ul>\n","categories":["mysql"],"tags":["mysql"]},{"title":"juc简单学习","url":"/2022/01/16/juc/","content":"<h1 id=\"juc并发编程\"><a class=\"markdownIt-Anchor\" href=\"#juc并发编程\"></a> juc并发编程</h1>\n<h2 id=\"juc简介\"><a class=\"markdownIt-Anchor\" href=\"#juc简介\"></a> juc简介</h2>\n<p>java.util .concurrent，Java并发包</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172801.png\" alt=\"image-20220103094918335\" /></p>\n<h2 id=\"笔试题目\"><a class=\"markdownIt-Anchor\" href=\"#笔试题目\"></a> 笔试题目</h2>\n<ol>\n<li>手写单例模式</li>\n<li>手写冒泡排序</li>\n<li>生产者消费者变种题目</li>\n</ol>\n<span id=\"more\"></span> \n<h2 id=\"进程线程回顾\"><a class=\"markdownIt-Anchor\" href=\"#进程线程回顾\"></a> 进程/线程回顾</h2>\n<h3 id=\"进程线程是什么\"><a class=\"markdownIt-Anchor\" href=\"#进程线程是什么\"></a> 进程/线程是什么？</h3>\n<p>**进程：**进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。（<strong>简单来说，进程就是后台运行的一个程序</strong>）</p>\n<p><strong>线程：</strong>  <strong>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程</strong>，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把<strong>线程作为独立运行和独立调度的基本单位</strong>，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>\n<h3 id=\"进程线程例子\"><a class=\"markdownIt-Anchor\" href=\"#进程线程例子\"></a> 进程/线程例子？</h3>\n<p>使用QQ，查看进程一定有一个QQ.exe的<strong>进程</strong>，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>\n<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>\n<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个<strong>线程</strong>：容灾备份，语法检查</p>\n<h3 id=\"什么是并发什么是并行\"><a class=\"markdownIt-Anchor\" href=\"#什么是并发什么是并行\"></a> 什么是并发？什么是并行？</h3>\n<p><strong>并发：<strong>同一时刻多个线程在访问</strong>同一个资源</strong>，多个线程对一个点<br />\n例子：小米9今天上午10点，限量抢购<br />\n春运抢票<br />\n电商秒杀…<br />\n**并行： ** <strong>多项工作一起执行</strong>，之后再汇总<br />\n例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172814.png\" alt=\"image-20220103110849404\" /></p>\n<h2 id=\"threadstart\"><a class=\"markdownIt-Anchor\" href=\"#threadstart\"></a> thread.start</h2>\n<p>thread.start表示线程进入<strong>就绪状态</strong>（不是立刻进行调用），是在调用run方法是在cup和操作系统对这个<strong>线程进行调度</strong>的时候。</p>\n<h2 id=\"thread的状态\"><a class=\"markdownIt-Anchor\" href=\"#thread的状态\"></a> Thread的状态</h2>\n<p>waite()和sleep()的比较，wait放开去睡，放开了手里的锁。</p>\n<p>sleep()捏紧了手去睡，醒了还有手里的锁。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172819.png\" alt=\"image-20220103164224117\" /></p>\n<pre class=\"highlight\"><code class=\"\">/**\n * Thread state for a thread which has not yet started.\n */\nNEW,\n</code></pre>\n<pre class=\"highlight\"><code class=\"\">/**\n * Thread state for a runnable thread.  A thread in the runnable\n * state is executing in the Java virtual machine but it may\n * be waiting for other resources from the operating system\n * such as processor.\n */\nRUNNABLE,\n</code></pre>\n<pre class=\"highlight\"><code class=\"\">/**\n * Thread state for a thread blocked waiting for a monitor lock.\n * A thread in the blocked state is waiting for a monitor lock\n * to enter a synchronized block/method or\n * reenter a synchronized block/method after calling\n * &#123;@link Object#wait() Object.wait&#125;.\n */\nBLOCKED,\n</code></pre>\n<h3 id=\"waiting和timed_waiting的区别\"><a class=\"markdownIt-Anchor\" href=\"#waiting和timed_waiting的区别\"></a> WAITING和TIMED_WAITING的区别</h3>\n<p>WAITING这个是一直等，死死的等，俗称不见不散</p>\n<pre class=\"highlight\"><code class=\"java\">等待线程的线程状态。\n\n由于调用了一个\n\n以下方法：\n\n<span class=\"hljs-comment\">/**\n * Thread state for a waiting thread.\n * A thread is in the waiting state due to calling one of the\n * following methods:\n * &lt;ul&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;\n * &lt;/ul&gt;\n *\n * &lt;p&gt;A thread in the waiting state is waiting for another thread to\n * perform a particular action.\n *\n * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;\n * on an object is waiting for another thread to call\n * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on\n * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;\n * is waiting for a specified thread to terminate.\n */</span>\nWAITING,\n</code></pre>\n<p>TIMED_WAITING是定时等待，俗称过时不候</p>\n<pre class=\"highlight\"><code class=\"java\">具有指定等待时间的等待线程的线程状态。\n\n由于调用其中一个线程，线程处于定时等待状态\n\n具有指定正等待时间的以下方法：\n\n<span class=\"hljs-comment\">/**\n * Thread state for a waiting thread with a specified waiting time.\n * A thread is in the timed waiting state due to calling one of\n * the following methods with a specified positive waiting time:\n * &lt;ul&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;\n *   &lt;li&gt;&#123;<span class=\"hljs-doctag\">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;\n * &lt;/ul&gt;\n */</span>\nTIMED_WAITING,\n</code></pre>\n<h2 id=\"经典卖票问题\"><a class=\"markdownIt-Anchor\" href=\"#经典卖票问题\"></a> 经典卖票问题</h2>\n<p>一般多线程问题可以简化为：线程\t\t操作（资源类暴露的方法）\t\t资源类</p>\n<h3 id=\"版本1使用匿名内部类\"><a class=\"markdownIt-Anchor\" href=\"#版本1使用匿名内部类\"></a> 版本1使用匿名内部类</h3>\n<p><strong>资源类</strong>：这里也可以使用同步方法或者同步代码块（但是粒度太大）</p>\n<p>这里使用的Lock的实现类ReentrantLock()可重入锁，相比synchronized同步锁来说更加灵活，</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * 资源类：票\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Ticket1</span> </span>&#123;\n\n    <span class=\"hljs-comment\">// 设定初始值为30张</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">30</span>;\n\n    <span class=\"hljs-comment\">// ReentrantLock可重入锁</span>\n    <span class=\"hljs-keyword\">private</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n\n    <span class=\"hljs-comment\">/**\n     * 操作,这里使用synchronized就相当于把这个saleTicket全部都锁住了，粒度太大\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">saleTicket</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n\n        <span class=\"hljs-comment\">// 上锁</span>\n        lock.lock();\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 先判断number是否大于0</span>\n            <span class=\"hljs-keyword\">if</span> (number &gt; <span class=\"hljs-number\">0</span>) &#123;\n                System.out.println(<span class=\"hljs-string\">\"ThreadName = \"</span> + Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t卖出第：\"</span> + (number--) + <span class=\"hljs-string\">\"\\t还剩下\"</span> + number);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                System.out.println(<span class=\"hljs-string\">\"票已经卖完\"</span>);\n            &#125;\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 释放锁</span>\n            lock.unlock();\n        &#125;\n\n\n    &#125;\n\n\n&#125;\n</code></pre>\n<p><strong>抢票类</strong></p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/03    10:10\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n * 题目：三个售票员     卖出      30张票\n *多线程编程的企业套路+模板\n *\n * 1.在高内聚低耦合的前提下：线程         操作（资源类对外暴露的调用方法）          资源类\n *\n *抢票类\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SaleTicket</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;  <span class=\"hljs-comment\">// main程序一切入口</span>\n\n\n\n\n        <span class=\"hljs-comment\">// 创建两个线程t1，t2</span>\n<span class=\"hljs-comment\">//        Thread t1 = new Thread();</span>\n<span class=\"hljs-comment\">//        Thread t2 = new Thread();</span>\n\n        <span class=\"hljs-comment\">//Thread(Runnable target, String name)</span>\n<span class=\"hljs-comment\">//        // 启动线程</span>\n<span class=\"hljs-comment\">//        t1.start();</span>\n<span class=\"hljs-comment\">//        t2.start();</span>\n\n\n        <span class=\"hljs-comment\">// 下面三个线程(A、B、C)操作同一个资源类</span>\n        Ticket1 ticket = <span class=\"hljs-keyword\">new</span> Ticket1();\n        <span class=\"hljs-comment\">// 匿名内部类</span>\n\n        <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">40</span>; i++) &#123;\n                    ticket.saleTicket();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"A\"</span>);\n\n\n        <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">40</span>; i++) &#123;\n                    ticket.saleTicket();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"B\"</span>).start();\n\n\n        <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= <span class=\"hljs-number\">40</span>; i++) &#123;\n                    ticket.saleTicket();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"C\"</span>).start();\n\n\n    &#125;\n\n\n&#125;\n</code></pre>\n<h3 id=\"版本二使用lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"#版本二使用lambda表达式\"></a> 版本二使用lambda表达式</h3>\n<p>Lambda Express 使用的场景：当一个接口中只有一个抽象方法，其他的默认方法有几个无所谓。</p>\n<p>Lambda Express表达式的小口诀： <strong>拷贝小括号（小括号是接口中的方法），写死右箭头，落地大括号。</strong></p>\n<p>@FunctionalInterface注解声明式函数式接口，其实可以不用加，在底层默认给加上了</p>\n<p>Foo接口</p>\n<pre class=\"highlight\"><code class=\"\">/**\n * 有且只有一个抽象方法的接口称为“函数式接口”\n */\n@FunctionalInterface\ninterface Foo &#123;\n//    public void sayHello();\n\n    int add(int a, int b);\n\n\n    default int div(int a, int b) &#123;\n        return a / b;\n    &#125;\n\n    /**\n     * 静态方法实现\n     * @param a\n     * @param b\n     * @return\n     */\n    static int mv(int a, int b) &#123;\n\n        return a * b;\n    &#125;\n\n\n&#125;\n</code></pre>\n<p>使用Foo接口中的Lambda表达式</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LambdaExpressDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n\n    <span class=\"hljs-comment\">/*        Foo foo = new Foo() &#123;\n            @Override\n            public void sayHello() &#123;\n                System.out.println(\"*******************hello java 2022\");\n            &#125;\n        &#125;;*/</span>\n\n<span class=\"hljs-comment\">/*\n        Foo foo = () -&gt; &#123;\n            System.out.println(\"*******************hello java lambda\");\n\n        &#125;;\n\n\n        foo.sayHello();\n*/</span>\n\n        <span class=\"hljs-comment\">// 可以把方法的参数类型省略</span>\n        Foo foo = (a, b) -&gt; &#123;\n\n            System.out.println(<span class=\"hljs-string\">\"a+b = \"</span> + a + b);\n\n            <span class=\"hljs-keyword\">return</span> a + b;\n        &#125;;\n\n        foo.add(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">45</span>);\n\n        System.out.println(foo.div(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>));\n\n        System.out.println(Foo.mv(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>));\n\n\n    &#125;\n\n\n&#125;\n\n</code></pre>\n<h2 id=\"线程交互问题笔试题目之交替打印0和1\"><a class=\"markdownIt-Anchor\" href=\"#线程交互问题笔试题目之交替打印0和1\"></a> 线程交互问题：笔试题目之交替打印0和1</h2>\n<p>这个就是<strong>生产者和消费者模型。</strong></p>\n<p>笔试题目：<br />\n题目:现在两个线程，可以操作初始值为零的一个变量,<br />\n实现一个线程对该变量加，一个线程对该变量减i，<br />\n实现交替，来10轮，变量初始值为零。</p>\n<h3 id=\"两个线程交替打印10版\"><a class=\"markdownIt-Anchor\" href=\"#两个线程交替打印10版\"></a> 两个线程交替打印1.0版</h3>\n<p>这里有一个坑，但是两个线程的时候不会出现，当线程多的时候就会出现。这里的判断条件不能用if，只能用while。</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/03    18:29\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * 笔试题目：\n * 题目:现在两个线程，可以操作初始值为零的一个变量,\n * 实现一个线程对该变量加，一个线程对该变量减i，\n * 实现交替，来10轮，变量初始值为零。\n *\n *\n * // 1.高内聚低耦合的前提下，线程       操作      资源类\n *    2.   判断/干活/通知\n *\n * 生产者消费者复习\n *\n *\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadWaitNotifyDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        AirCondition airCondition = <span class=\"hljs-keyword\">new</span> AirCondition();\n\n\n        <span class=\"hljs-comment\">/**\n         * 生产蛋糕，做加法\n         */</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition.increment();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"A\"</span>).start();\n\n\n        <span class=\"hljs-comment\">/**\n         * 消费蛋糕，做减法\n         */</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition.decrement();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"B\"</span>).start();\n\n\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">/**\n * 资源类\n *  1.0版\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">0</span>;\n\n\n    <span class=\"hljs-comment\">/**\n     * 对number进行加1\n     * 这里有三步，\n     * 1、判断number的值是否为0\n     * 2、做加法\n     * 3、通知消费者来吃蛋糕\n     *\n     * 生产者线程\n     *\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n\n        <span class=\"hljs-comment\">// 1.判断</span>\n        <span class=\"hljs-keyword\">if</span> (number != <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">this</span>.wait();\n        &#125;\n\n        <span class=\"hljs-comment\">// 2.干活</span>\n        number++;\n\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\"</span> + number);\n\n        <span class=\"hljs-comment\">// 3.通知(唤醒等待的线程)</span>\n        <span class=\"hljs-keyword\">this</span>.notifyAll();\n\n\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 对number进行减1\n     * synchronized加上同步锁\n     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待\n     * 消费者线程\n     *\n     *\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decrement</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n\n        <span class=\"hljs-comment\">// 1.判断，等于0，没有蛋糕，就得先等</span>\n        <span class=\"hljs-keyword\">if</span> (number == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">this</span>.wait();\n        &#125;\n\n        <span class=\"hljs-comment\">// 2.干活</span>\n        number--;\n\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\"</span> + number);\n\n        <span class=\"hljs-comment\">// 3.通知(唤醒等待的线程)</span>\n        <span class=\"hljs-keyword\">this</span>.notifyAll();\n\n\n    &#125;\n\n&#125;\n</code></pre>\n<h3 id=\"两个线程交替打印20版变成四个线程\"><a class=\"markdownIt-Anchor\" href=\"#两个线程交替打印20版变成四个线程\"></a> 两个线程交替打印2.0版（变成四个线程）</h3>\n<p>这里升级为四个线程进行操作，一个加一个减，一个加一个减</p>\n<p>/*        if (number != 0) {</p>\n<pre class=\"highlight\"><code class=\"java\">        <span class=\"hljs-comment\">//  A可能没有执行下面的wait的时候，线程调度的时候就停止了，</span>\n        <span class=\"hljs-comment\">//  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)</span>\n        <span class=\"hljs-comment\">// 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了</span>\n        <span class=\"hljs-keyword\">this</span>.wait();\n    &#125;*/\n</code></pre>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadWaitNotifyDemo2</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        AirCondition1 ac1 = <span class=\"hljs-keyword\">new</span> AirCondition1();\n\n        <span class=\"hljs-comment\">// 消费者线程A</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    Thread.sleep(<span class=\"hljs-number\">200</span>);\n                    ac1.increment();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"A\"</span>).start();\n\n\n        <span class=\"hljs-comment\">// 消费者线程B</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    Thread.sleep(<span class=\"hljs-number\">400</span>);\n                    ac1.decrement();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"B\"</span>).start();\n\n\n        <span class=\"hljs-comment\">// 消费者线程C</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    Thread.sleep(<span class=\"hljs-number\">500</span>);\n                    ac1.increment();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"C\"</span>).start();\n\n\n        <span class=\"hljs-comment\">// 消费者线程D</span>\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    ac1.decrement();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"D\"</span>).start();\n\n\n    &#125;\n\n\n&#125;\n\n\n<span class=\"hljs-comment\">/**\n * 资源类\n * 2.0版\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition1</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">0</span>;\n\n\n    <span class=\"hljs-comment\">/**\n     * 对number进行加1\n     * 这里有三步，\n     * 1、判断number的值是否为0\n     * 2、做加法\n     * 3、通知消费者来吃蛋糕\n     *\n     * 生产者线程\n     *\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n\n        <span class=\"hljs-comment\">/**\n         * sleep不会释放线程的所有权(锁)而wait会，所以下面配合synchronized使用\n         *\n         * 这个式调用无参的wait\n         * 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。\n         * 换句话说，这个方法的行为就好像简单地执行呼叫wait(0) 。\n         *\n         *\n         * wait()\n         * 当前的线程必须拥有该对象的显示器。 线程释放此监视器的所有权(锁)，并等待直到发生以下两种情况之一：\n         *\n         * 另一个线程通知等待该对象的监视器的线程通过调用notify方法或notifyAll方法来唤醒。\n         * 由timeout毫秒加nanos纳秒参数指定的超时时间已过。\n         *\n         *\n         *\n         * 像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用：\n         *\n         *   synchronized (obj) &#123;\n         *          while (&lt;condition does not hold&gt;)\n         *              obj.wait(timeout, nanos);\n         *          ... // Perform action appropriate to condition\n         *      &#125;\n         *\n         *\n         */</span>\n        <span class=\"hljs-comment\">// 1.判断</span>\n\n\n        <span class=\"hljs-comment\">// 注意这里不能用if进行判断，如果使用if的话会出现虚假唤醒，因为if只判断一次（这个是最主要原因）</span>\n<span class=\"hljs-comment\">/*        if (number != 0) &#123;\n\n            //  A可能没有执行下面的wait的时候，线程调度的时候就停止了，\n            //  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)\n            // 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了\n            this.wait();\n        &#125;*/</span>\n\n\n        <span class=\"hljs-comment\">// 1.判断</span>\n        <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-comment\">// 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了</span>\n            <span class=\"hljs-keyword\">this</span>.wait();\n        &#125;\n\n\n        <span class=\"hljs-comment\">// 2.干活</span>\n        number++;\n\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"生产了数据:\"</span> + number);\n\n        <span class=\"hljs-comment\">// 3.通知(唤醒等待的线程)</span>\n        <span class=\"hljs-keyword\">this</span>.notifyAll();\n\n\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 对number进行减1\n     * synchronized加上同步锁\n     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待\n     * 消费者线程\n     *\n     *\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decrement</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n\n        <span class=\"hljs-comment\">// 1.判断，等于0，没有蛋糕，就得先等</span>\n        <span class=\"hljs-keyword\">while</span> (number == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">this</span>.wait();\n        &#125;\n\n\n        <span class=\"hljs-comment\">// 2.干活</span>\n        number--;\n\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"消费了数据:\"</span> + number);\n\n        <span class=\"hljs-comment\">// 3.通知(唤醒等待的线程)</span>\n        <span class=\"hljs-keyword\">this</span>.notifyAll();\n\n\n    &#125;\n\n&#125;\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172832.png\" alt=\"image-20220104161856205\" /></p>\n<h3 id=\"改编题目\"><a class=\"markdownIt-Anchor\" href=\"#改编题目\"></a> 改编题目</h3>\n<p>题目内容</p>\n<pre class=\"highlight\"><code class=\"\">多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下:\nAA打印5次，BB打10次，CC打印15次接着  (这里又线程之间的通信,这里是精确通知)\nAA打印5次，BB打印10次，CC打印15次\n</code></pre>\n<p>由于这里是三个线程进行打印而且还有顺序，通过使用标志位加Condition接口中的signal();实现精准通知。当A线程进入执行完打印操作之后，将标志位进行改变，就精准通知B线程。同理B完成之后通知C，C然后再通知A实现A-&gt;B-&gt;C（其实都是number标志位起了作用）</p>\n<p><strong>资源类的代码如下</strong></p>\n<ul>\n<li>第一种使用Lock锁</li>\n</ul>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * 资源类\n * 作业：将三个方法合并成一个方法\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShareResource</span> </span>&#123;\n    <span class=\"hljs-comment\">// 1:A  2:B   3:C   标志位1对于A,2对应B,3对应C</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">// 设定标志位的初始值为1</span>\n    <span class=\"hljs-comment\">// lock就相当于锁，而下面的condition就相当于钥匙，一把锁配三把钥匙</span>\n    <span class=\"hljs-keyword\">private</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n    <span class=\"hljs-keyword\">private</span> Condition condition1 = lock.newCondition();\n    <span class=\"hljs-keyword\">private</span> Condition condition2 = lock.newCondition();\n    <span class=\"hljs-keyword\">private</span> Condition condition3 = lock.newCondition();\n\n    <span class=\"hljs-comment\">/**\n     * 打印五次\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print5</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        lock.lock();\n        <span class=\"hljs-keyword\">try</span> &#123;\n\n            <span class=\"hljs-comment\">// 1.判断</span>\n            <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">1</span>) &#123;\n                <span class=\"hljs-comment\">// 进行等待</span>\n                condition1.await();\n            &#125;\n\n            <span class=\"hljs-comment\">// 2.干活</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\":\\t\"</span> + i);\n            &#125;\n\n            <span class=\"hljs-comment\">// 3.通知</span>\n            <span class=\"hljs-comment\">// 将标志位进行更改</span>\n            number = <span class=\"hljs-number\">2</span>;\n\n            <span class=\"hljs-comment\">// 这里精准唤醒2线程</span>\n            <span class=\"hljs-comment\">// 唤醒condition2锁了的线程（唤醒2线程）</span>\n            condition2.signal();\n\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 打印十次\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print10</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        lock.lock();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n\n            <span class=\"hljs-comment\">// 1.判断</span>\n            <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">2</span>) &#123;\n                <span class=\"hljs-comment\">// 进行等待</span>\n                condition2.await();\n            &#125;\n\n            <span class=\"hljs-comment\">// 2.干活</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">10</span>; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\":\\t\"</span> + i);\n            &#125;\n\n            <span class=\"hljs-comment\">// 3.通知</span>\n            <span class=\"hljs-comment\">// 将标志位进行更改</span>\n            number = <span class=\"hljs-number\">3</span>;\n            <span class=\"hljs-comment\">// 唤醒等待的线程 （唤醒3线程）</span>\n            condition3.signal();\n\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 打印十五次\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print15</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        lock.lock();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n\n            <span class=\"hljs-comment\">// 1.判断</span>\n            <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">3</span>) &#123;\n                <span class=\"hljs-comment\">// 进行等待</span>\n                condition3.await();\n            &#125;\n\n            <span class=\"hljs-comment\">// 2.干活</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">15</span>; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\":\\t\"</span> + i);\n            &#125;\n\n            <span class=\"hljs-comment\">// 3.通知</span>\n            <span class=\"hljs-comment\">// 将标志位进行更改</span>\n            number = <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-comment\">// 唤醒等待的线程（唤醒1线程）</span>\n            condition1.signal();\n\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>第二种使用同步方法</li>\n</ul>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/07    9:15\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * 也可以用synchronized同步方法和wait和notifyAll，其实就是number标志位起了作用\n *\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition3</span></span>&#123;\n\n    <span class=\"hljs-comment\">// 1代表A ，   2代表B    3代表C</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">1</span>;\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print5s</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        <span class=\"hljs-comment\">// 判断</span>\n        <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">1</span>) &#123;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                wait();\n            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + i);\n        &#125;\n        number = <span class=\"hljs-number\">2</span>;\n        notifyAll();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print10s</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        <span class=\"hljs-comment\">// 判断</span>\n        <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">2</span>) &#123;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                wait();\n            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">10</span>; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + i);\n        &#125;\n        number = <span class=\"hljs-number\">3</span>;\n        notifyAll();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print15s</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        <span class=\"hljs-comment\">// 判断</span>\n        <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">3</span>) &#123;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                wait();\n            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">15</span>; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + i);\n        &#125;\n        number = <span class=\"hljs-number\">1</span>;\n        notifyAll();\n    &#125;\n\n\n&#125;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadWaitNotifyDemo1</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        AirCondition3 airCondition2 = <span class=\"hljs-keyword\">new</span> AirCondition3();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;\n                airCondition2.print5s();\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"线程A\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">10</span>; i++) &#123;\n                airCondition2.print10s();\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"线程B\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">15</span>; i++) &#123;\n                airCondition2.print15s();\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"线程C\"</span>).start();\n    &#125;\n\n\n&#125;\n\n\n</code></pre>\n<h2 id=\"使用lock替换synchronized\"><a class=\"markdownIt-Anchor\" href=\"#使用lock替换synchronized\"></a> 使用lock替换<strong>synchronized</strong></h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172836.png\" alt=\"image-20220104163122288\" /></p>\n<p>将synchronized同步方法换成Lock锁，Lock更加灵活，**synchronized使用的是Object类中wait和notify/notifyAll。**而在Lock中<code>Lock</code>实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。  它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象<code>Condition</code>。</p>\n<p><code>Condition</code>因素出<code>Object</code>监视器方法（ <a href=\"../../../../java/lang/Object.html#wait--\"><code>wait</code></a> ， <a href=\"../../../../java/lang/Object.html#notify--\"><code>notify</code></a>和<a href=\"../../../../java/lang/Object.html#notifyAll--\"><code>notifyAll</code></a>  ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果<code>Lock</code>实现。 <code>Lock</code>替换<code>synchronized</code>方法和语句的使用，  <code>Condition</code>取代了对象监视器方法的使用。 <code>Condition</code>使用的是<code>await()</code> 和<code>signal()</code> /<code>signalAll()</code>对应Object类的<strong>wait和notify/notifyAll。</strong></p>\n<p><strong>资源类和操作类的代码。</strong></p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/04    16:49\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n * 将锁换成Lock\n * 1.高内聚低耦合的前提下，线程       操作      资源类\n * 2.   判断/干活/通知\n * 3.   多线程交互的过程中，必须要防止多线程的虚假唤醒，也即(判断使用while，不能用if)\n * (在方法的判断中不许用if，只能用while)\n * 4.   注意标志位的修改和定位\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadWaitNotifyDemo2</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        AirCondition2 airCondition2 = <span class=\"hljs-keyword\">new</span> AirCondition2();\n        <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;<span class=\"hljs-number\">10</span> ; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition2.increase();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,<span class=\"hljs-string\">\"线程A\"</span>).start();\n\n            <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;<span class=\"hljs-number\">10</span> ; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition2.decrease();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,<span class=\"hljs-string\">\"线程B\"</span>).start();\n            <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;<span class=\"hljs-number\">10</span> ; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition2.increase();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,<span class=\"hljs-string\">\"线程C\"</span>).start();\n            <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;<span class=\"hljs-number\">10</span> ; i++) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    airCondition2.decrease();\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,<span class=\"hljs-string\">\"线程D\"</span>).start();\n    &#125;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition2</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n\n    <span class=\"hljs-keyword\">private</span> Condition condition = lock.newCondition();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">0</span>;\n\n\n    <span class=\"hljs-comment\">// 生产者对number的值进行加1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">increase</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n        <span class=\"hljs-comment\">// 对资源进行上锁</span>\n        lock.lock();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 1.判断</span>\n            <span class=\"hljs-keyword\">while</span> (number != <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-comment\">//    this.wait();</span>\n                condition.await();\n            &#125;\n\n            <span class=\"hljs-comment\">// 2.干活</span>\n            ++number;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"生产了\"</span> +<span class=\"hljs-string\">\"\\t\"</span>+ number);\n            <span class=\"hljs-comment\">// 通知</span>\n<span class=\"hljs-comment\">//            this.notify();</span>\n            condition.signalAll();\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 对资源进行释放锁</span>\n            lock.unlock();\n        &#125;\n\n\n    &#125;\n\n\n    <span class=\"hljs-comment\">// 生产者对number的值进行减1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decrease</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n        <span class=\"hljs-comment\">// 对资源进行上锁</span>\n        lock.lock();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 1.判断</span>\n            <span class=\"hljs-keyword\">while</span> (number == <span class=\"hljs-number\">0</span>) &#123;\n                <span class=\"hljs-comment\">//    this.wait();</span>\n                condition.await();\n            &#125;\n\n            <span class=\"hljs-comment\">// 2.干活</span>\n            number--;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"消费了\"</span> +<span class=\"hljs-string\">\"\\t\"</span>+ number);\n            <span class=\"hljs-comment\">// 通知</span>\n<span class=\"hljs-comment\">//            this.notify();</span>\n            condition.signalAll();\n\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 对资源进行释放锁</span>\n            lock.unlock();\n        &#125;\n\n&#125;\n    &#125;\n</code></pre>\n<h2 id=\"多线程8锁\"><a class=\"markdownIt-Anchor\" href=\"#多线程8锁\"></a> 多线程8锁</h2>\n<pre class=\"highlight\"><code class=\"text\">题目：多线程8锁\n    其实下面就是看synchronized锁的是什么对象\n    普通同步方法锁的就是this这个当前对象，而不是锁住这个单独的synchronized方法，也就是说同一时间段，只能有一个线程进入当前类，访问一个synchronized方法\n    静态同步方法锁的就是类.Class这个对象也就是类对象，同时去复习一下static关键字\n    普通方法没有加synchronized就不会上锁\n    对于同步方法块，锁是Synchonized括号里配置的对象\n</code></pre>\n<pre class=\"highlight\"><code class=\"\">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，\n其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法\n锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法\n \n加个普通方法后发现和同步锁无关\n换成两个对象后，不是同一把锁了，情况立刻变化。\n \n \nsynchronized实现同步的基础：Java中的每一个对象都可以作为锁。\n具体表现为以下3种形式。\n对于普通同步方法，锁是当前实例对象。\n对于静态同步方法，锁是当前类的Class对象。\n对于同步方法块，锁是Synchonized括号里配置的对象\n \n当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。\n \n也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，\n可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，\n所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。\n \n所有的静态同步方法用的也是同一把锁——类对象本身，\n这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。\n但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，\n而不管是同一个实例对象的静态同步方法之间，\n还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！\n \n \n \n\n</code></pre>\n<ul>\n<li>1、标准访问，先打印短信还是邮件</li>\n</ul>\n<p><code>邮件</code></p>\n<ul>\n<li>2、 停4秒在短信方法内，先打印短信还是邮件</li>\n</ul>\n<p><code>邮件</code></p>\n<ul>\n<li>3 、普通的hello方法，是先打短信还是hello</li>\n</ul>\n<p><code>hello</code></p>\n<ul>\n<li>4 、现在有两部手机，先打印短信还是邮件</li>\n</ul>\n<p><code>短信</code></p>\n<ul>\n<li>5 、两个静态同步方法，1部手机，先打印短信还是邮件</li>\n</ul>\n<p><code>邮件</code></p>\n<ul>\n<li>6 、两个静态同步方法，2部手机，先打印短信还是邮件</li>\n</ul>\n<p><code>邮件</code></p>\n<ul>\n<li>7 、1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件</li>\n</ul>\n<p><code>短信</code></p>\n<ul>\n<li>8 、1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</li>\n</ul>\n<p><code>短信</code></p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Lock8</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n\n        Phone phone = <span class=\"hljs-keyword\">new</span> Phone();\n        Phone phone2 = <span class=\"hljs-keyword\">new</span> Phone();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            phone.sendEmail();\n        &#125;, <span class=\"hljs-string\">\"线程A\"</span>).start();\n\n        <span class=\"hljs-comment\">// 由于这里线程睡了0.2秒钟，线程A就已经完成启动和调度了</span>\n        Thread.sleep(<span class=\"hljs-number\">200</span>);\n\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n<span class=\"hljs-comment\">//                phone.sendMsg();</span>\n\n\n            phone2.sendMsg();\n<span class=\"hljs-comment\">//            phone.hello();</span>\n        &#125;, <span class=\"hljs-string\">\"线程B\"</span>).start();\n\n\n    &#125;\n\n\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Phone</span> </span>&#123;\n\n\n    <span class=\"hljs-comment\">/**\n     * 发送邮件的方法\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sendEmail</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 线程睡四秒钟</span>\n            TimeUnit.SECONDS.sleep(<span class=\"hljs-number\">4</span>);\n        &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"---------------sendEmail\"</span>);\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 发送短信方法\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sendMsg</span><span class=\"hljs-params\">()</span> </span>&#123;\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"---------------sendMsg\"</span>);\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 普通方法，没有加锁，就不用争抢锁资源\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span> </span>&#123;\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"-------------------------hello\"</span>);\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"交替打印100以内的奇数和偶数\"><a class=\"markdownIt-Anchor\" href=\"#交替打印100以内的奇数和偶数\"></a> 交替打印100以内的奇数和偶数</h2>\n<p>这里有一个大坑，你要先将另一把锁唤醒之后，然后将自己进入等待状态。不然的话，会出现死锁，连哥哥线程都在等待对方唤醒。</p>\n<h3 id=\"死锁\"><a class=\"markdownIt-Anchor\" href=\"#死锁\"></a> 死锁</h3>\n<p>**是指多个进程在运行过程中因争夺资源而造成的一种僵局，**当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程T1，按照先锁R1再获得锁R2的的顺序获得锁，而在此同时又有另外一个线程T2，按照先锁T2再锁T1的顺序获得锁。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172842.png\" alt=\"image-20220106100435845\" /></p>\n<h3 id=\"第一种使用lock锁\"><a class=\"markdownIt-Anchor\" href=\"#第一种使用lock锁\"></a> 第一种使用Lock锁</h3>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test2</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        ShareSource1 ss = <span class=\"hljs-keyword\">new</span> ShareSource1();\n        <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;ss.print();&#125;,<span class=\"hljs-string\">\"线程A\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(()-&gt;&#123;ss.print();&#125;,<span class=\"hljs-string\">\"线程B\"</span>).start();\n\n\n    &#125;\n\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShareSource1</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n    <span class=\"hljs-keyword\">private</span> Condition condition = lock.newCondition();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        <span class=\"hljs-comment\">// 判断</span>\n        lock.lock();\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-keyword\">while</span> (number &lt;= <span class=\"hljs-number\">100</span>) &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + number);\n                number++;\n                <span class=\"hljs-comment\">//    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.</span>\n                <span class=\"hljs-comment\">// 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁</span>\n<span class=\"hljs-comment\">//                this.wait();</span>\n<span class=\"hljs-comment\">//                this.notify();</span>\n                <span class=\"hljs-comment\">// 为了避免死锁，得先将进行唤醒，然后再去等待</span>\n\n                condition.signal();\n                condition.await();\n\n            &#125;\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h3 id=\"第二种使用synchronized静态代码块\"><a class=\"markdownIt-Anchor\" href=\"#第二种使用synchronized静态代码块\"></a> 第二种使用synchronized静态代码块</h3>\n<p>​</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test3</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        ShareSource2 ss2 = <span class=\"hljs-keyword\">new</span> ShareSource2();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                ss2.print();\n            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"线程A\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                ss2.print();\n            &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;, <span class=\"hljs-string\">\"线程B\"</span>).start();\n    &#125;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShareSource2</span> </span>&#123;\n\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n\n        <span class=\"hljs-comment\">// 判断</span>\n\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n       <span class=\"hljs-keyword\">while</span> (number &lt;= <span class=\"hljs-number\">100</span>) &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + number);\n                number++;\n\n\n                <span class=\"hljs-comment\">//    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.</span>\n                <span class=\"hljs-comment\">// 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁</span>\n<span class=\"hljs-comment\">//                this.wait();</span>\n<span class=\"hljs-comment\">//                this.notify();</span>\n                <span class=\"hljs-comment\">// 为了避免死锁，得先将进行唤醒，然后再去等待</span>\n                <span class=\"hljs-keyword\">this</span>.notify();\n                <span class=\"hljs-keyword\">this</span>.wait();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"集合中的一些比较\"><a class=\"markdownIt-Anchor\" href=\"#集合中的一些比较\"></a> 集合中的一些比较</h1>\n<h2 id=\"请举例说明集合类是不安全的\"><a class=\"markdownIt-Anchor\" href=\"#请举例说明集合类是不安全的\"></a> 请举例说明集合类是不安全的</h2>\n<h3 id=\"arraylist线程不安全\"><a class=\"markdownIt-Anchor\" href=\"#arraylist线程不安全\"></a> ArrayList线程不安全</h3>\n<p>ArrayList、HashMap、HashSet都是线程不安全的</p>\n<pre class=\"highlight\"><code class=\"java\">List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();   <span class=\"hljs-comment\">// Collections.synchronizedList(new ArrayList&lt;String&gt;());</span>\n\n\n<span class=\"hljs-comment\">// 出现异常java.util.ConcurrentModificationException</span>\n<span class=\"hljs-comment\">// 多线程条件下，既要读又要写</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">30</span>; i++) &#123;\n\n    <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n        list.add(UUID.randomUUID().toString().substring(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>));\n        System.out.println(Thread.currentThread().getName() + list);\n    &#125;, String.valueOf(i)).start();\n\n&#125;\n</code></pre>\n<ol>\n<li>\n<p><strong>故障现象</strong></p>\n<p>java.util.ConcurrentModificationException并发修改异常</p>\n</li>\n<li>\n<p><strong>导致原因</strong><br />\n多线程条件下，既要读又要写</p>\n</li>\n<li>\n<p><strong>解决方案</strong></p>\n<p>3.1 用Vector,它的底层在add方法加了同步锁<br />\n3.2 Collections.synchronizedList(new ArrayList<String>());<br />\n3.3 new CopyOnWriteArrayList&lt;&gt;();</p>\n</li>\n<li>\n<p>将代码块抽取成方法的快捷键<strong>Ctrl+Alt+m</strong></p>\n</li>\n</ol>\n<p>ArrayList的add方法</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(E e)</span> </span>&#123;\n    ensureCapacityInternal(size + <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// Increments modCount!!</span>\n    elementData[size++] = e;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n&#125;\n\n</code></pre>\n<h3 id=\"在多线程条件下不使用arraylist\"><a class=\"markdownIt-Anchor\" href=\"#在多线程条件下不使用arraylist\"></a> 在多线程条件下不使用ArrayList</h3>\n<pre class=\"highlight\"><code class=\"java\">   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n<span class=\"hljs-comment\">/*        // 将数组转List\n        List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");\n        // 方法的引用\n        list.forEach(System.out ::println);*/</span>\n\n        <span class=\"hljs-comment\">// 生成当前的时间戳</span>\n        <span class=\"hljs-comment\">//    System.currentTimeMillis();</span>\n\n        <span class=\"hljs-comment\">// 第一种方法：（线程不安全） new ArrayList&lt;&gt;();</span>\n        <span class=\"hljs-comment\">// 第二种方法（不推荐）   new Vector&lt;&gt;();</span>\n        <span class=\"hljs-comment\">// 第三种：使用Collections.synchronizedList将线程不安全的的List转换成线程安全的</span>\n        <span class=\"hljs-comment\">// 第四种：使用  new CopyOnWriteArrayList&lt;&gt;();</span>\n\n\n        <span class=\"hljs-comment\">// HashMap线程不安全使用ConcurrentHashMap</span>\n\n        List&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();   <span class=\"hljs-comment\">// Collections.synchronizedList(new ArrayList&lt;String&gt;());</span>\n\n\n        <span class=\"hljs-comment\">// 出现异常java.util.ConcurrentModificationException</span>\n        <span class=\"hljs-comment\">// 多线程条件下，既要读又要写</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">30</span>; i++) &#123;\n\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                list.add(UUID.randomUUID().toString().substring(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>));\n                System.out.println(Thread.currentThread().getName() + list);\n            &#125;, String.valueOf(i)).start();\n\n        &#125;\n\n\n\n    &#125;\n</code></pre>\n<h3 id=\"javautilconcurrent\"><a class=\"markdownIt-Anchor\" href=\"#javautilconcurrent\"></a> java.util.concurrent</h3>\n<p>多线程条件下，一般使用这个报下面的类，后面的三个都是java.util.concurrent并发包下面的。</p>\n<ul>\n<li>ArrayList   ------&gt;    CopyOnWriteArrayList</li>\n<li>HashSet    ------&gt;    CopyOnWriteArraySet</li>\n<li>HashMap   ------&gt;    ConcurrentHashMap</li>\n</ul>\n<h3 id=\"回忆集合的基础知识\"><a class=\"markdownIt-Anchor\" href=\"#回忆集合的基础知识\"></a> 回忆集合的基础知识</h3>\n<p>HashSet的底层数据结构是HashMap，存的是map的key，它的value是一个写死的Object的常量</p>\n<p>HashSet的add方法是调用的HashMap的put方法</p>\n<p>HashMap的底层1.8是<strong>Node数组+链表+红黑树，1.7是哈希表</strong></p>\n<p>jdk1.8</p>\n<p>构造求一个空的HashMap，默认的初始容量是（16），默认的负载因子是（0.75）</p>\n<p>HashMap和HashSet都是无序的</p>\n<p>无序性：无序性不等于随机性。指的是存储的数据在底层数组中并非按照数组索引的顺序进行添加的，而使根据数值的哈希值决定的。</p>\n<p>ArrayList扩容是扩容为原来的1.5倍</p>\n<p>HashMap扩容是扩大到原来的两倍，在使用的时候可以将他的初始容量设大，这样就可以避免它反复扩容了。</p>\n<h3 id=\"copyonwritearraylist\"><a class=\"markdownIt-Anchor\" href=\"#copyonwritearraylist\"></a> CopyOnWriteArrayList</h3>\n<ul>\n<li><strong>java.util.concurrent.CopyOnWriteArrayList<E></strong></li>\n</ul>\n<p><font color='orange'><strong>写时复制技术原理</strong></font></p>\n<p>**CopyOnWrite容器即写时复制的容器。**往一个容器添加元素的时候，不直接往当前容器Object[]添加，<br />\n而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。<br />\n添加元素后，再将原容器的引用指向新的容器setArray(newElements)。<br />\n这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br />\n所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>\n<hr />\n<p>CopyOnWriteArrayList的原理：简单的来说当A线程去写的时候，先复制一份1.1版的，然后自己用这个1.1版的去写，如果其他的线程要读的时候就去读1.0版本的，当A写完之后再发布1.1版的。<strong>（其实也就是读写分离思想）</strong></p>\n<p>CopyOnWriteArrayList是线程安全的，下面是它的add方法的源码，它会先将传入的集合进行复制一份，然后将新的</p>\n<pre class=\"highlight\"><code class=\"java\">   <span class=\"hljs-comment\">/** The array, accessed only via getArray/setArray. */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">transient</span> <span class=\"hljs-keyword\">volatile</span> Object[] array;\n\n    <span class=\"hljs-comment\">/**\n     * Gets the array.  Non-private so as to also be accessible\n     * from CopyOnWriteArraySet class.\n     */</span>\n    <span class=\"hljs-keyword\">final</span> Object[] getArray() &#123;\n        <span class=\"hljs-keyword\">return</span> array;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * Sets the array.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setArray</span><span class=\"hljs-params\">(Object[] a)</span> </span>&#123;\n        array = a;\n    &#125;\n   \n\n<span class=\"hljs-comment\">/**\n     * Appends the specified element to the end of this list.\n     *\n     * <span class=\"hljs-doctag\">@param</span> e element to be appended to this list\n     * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-doctag\">@code</span> true&#125; (as specified by &#123;<span class=\"hljs-doctag\">@link</span> Collection#add&#125;)\n     */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(E e)</span> </span>&#123;\n    <span class=\"hljs-keyword\">final</span> ReentrantLock lock = <span class=\"hljs-keyword\">this</span>.lock;\n    lock.lock();\n    <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-comment\">// 这里就是复制一份新的，然后用Object数组进行接收</span>\n        Object[] elements = getArray();\n        <span class=\"hljs-comment\">// 获得原来的集合的长度</span>\n        <span class=\"hljs-keyword\">int</span> len = elements.length;\n        <span class=\"hljs-comment\">// 对elements数组进行扩容长度加一得到新的newElements</span>\n        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-comment\">// 将要添加的e，添加到数组的最后</span>\n        newElements[len] = e;\n        <span class=\"hljs-comment\">// 再将newElements重新设置回CopyOnWriteArrayList对象中，就是相当于1.1版本的替换1.0版本的 </span>\n        setArray(newElements);\n        <span class=\"hljs-comment\">// 添加完成</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n        <span class=\"hljs-comment\">// 释放锁</span>\n        lock.unlock();\n    &#125;\n&#125;\n</code></pre>\n<p>HashMap的put方法，put里面其实装的是一个个的Node结点</p>\n<pre class=\"highlight\"><code class=\"java\">    <span class=\"hljs-comment\">/**\n     * Associates the specified value with the specified key in this map.\n     * If the map previously contained a mapping for the key, the old\n     * value is replaced.\n     *\n     * <span class=\"hljs-doctag\">@param</span> key key with which the specified value is to be associated\n     * <span class=\"hljs-doctag\">@param</span> value value to be associated with the specified key\n     * <span class=\"hljs-doctag\">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or\n     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.\n     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map\n     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(K key, V value)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> putVal(hash(key), key, value, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>);\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * Implements Map.put and related methods.\n     *\n     * <span class=\"hljs-doctag\">@param</span> hash hash for key\n     * <span class=\"hljs-doctag\">@param</span> key the key\n     * <span class=\"hljs-doctag\">@param</span> value the value to put\n     * <span class=\"hljs-doctag\">@param</span> onlyIfAbsent if true, don't change existing value\n     * <span class=\"hljs-doctag\">@param</span> evict if false, the table is in creation mode.\n     * <span class=\"hljs-doctag\">@return</span> previous value, or null if none\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">final</span> V <span class=\"hljs-title\">putVal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hash, K key, V value, <span class=\"hljs-keyword\">boolean</span> onlyIfAbsent,\n                   <span class=\"hljs-keyword\">boolean</span> evict)</span> </span>&#123;\n        <span class=\"hljs-comment\">// HashMap的put装的是一个个的Node结点</span>\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"hljs-keyword\">int</span> n, i;\n        <span class=\"hljs-keyword\">if</span> ((tab = table) == <span class=\"hljs-keyword\">null</span> || (n = tab.length) == <span class=\"hljs-number\">0</span>)\n            n = (tab = resize()).length;\n        <span class=\"hljs-keyword\">if</span> ((p = tab[i = (n - <span class=\"hljs-number\">1</span>) &amp; hash]) == <span class=\"hljs-keyword\">null</span>)\n            tab[i] = newNode(hash, key, value, <span class=\"hljs-keyword\">null</span>);\n        <span class=\"hljs-keyword\">else</span> &#123;\n            Node&lt;K,V&gt; e; K k;\n            <span class=\"hljs-keyword\">if</span> (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != <span class=\"hljs-keyword\">null</span> &amp;&amp; key.equals(k))))\n                e = p;\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p <span class=\"hljs-keyword\">instanceof</span> TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"hljs-keyword\">this</span>, tab, hash, key, value);\n            <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> binCount = <span class=\"hljs-number\">0</span>; ; ++binCount) &#123;\n                    <span class=\"hljs-keyword\">if</span> ((e = p.next) == <span class=\"hljs-keyword\">null</span>) &#123;\n                        p.next = newNode(hash, key, value, <span class=\"hljs-keyword\">null</span>);\n                        <span class=\"hljs-keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// -1 for 1st</span>\n                            treeifyBin(tab, hash);\n                        <span class=\"hljs-keyword\">break</span>;\n                    &#125;\n                    <span class=\"hljs-keyword\">if</span> (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != <span class=\"hljs-keyword\">null</span> &amp;&amp; key.equals(k))))\n                        <span class=\"hljs-keyword\">break</span>;\n                    p = e;\n                &#125;\n            &#125;\n            <span class=\"hljs-keyword\">if</span> (e != <span class=\"hljs-keyword\">null</span>) &#123; <span class=\"hljs-comment\">// existing mapping for key</span>\n                V oldValue = e.value;\n                <span class=\"hljs-keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"hljs-keyword\">null</span>)\n                    e.value = value;\n                afterNodeAccess(e);\n                <span class=\"hljs-keyword\">return</span> oldValue;\n            &#125;\n        &#125;\n        ++modCount;\n        <span class=\"hljs-keyword\">if</span> (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    &#125;\n</code></pre>\n<h1 id=\"callable接口\"><a class=\"markdownIt-Anchor\" href=\"#callable接口\"></a> Callable接口</h1>\n<h2 id=\"复习获得多线程的方式\"><a class=\"markdownIt-Anchor\" href=\"#复习获得多线程的方式\"></a> 复习获得多线程的方式</h2>\n<p>面试题：获得多线程的方法几种？</p>\n<ul>\n<li>继承Thread类</li>\n</ul>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/06    19:39\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * 实现多线程的方式二继承Thread类，重写run方法\n *\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadDemo1</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        MyThread1 t1 = <span class=\"hljs-keyword\">new</span> MyThread1();\n\n        <span class=\"hljs-keyword\">new</span> Thread(t1,<span class=\"hljs-string\">\"线程1\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(t1,<span class=\"hljs-string\">\"线程2\"</span>).start();\n\n<span class=\"hljs-comment\">/*\n        t1.setName(\"线程A\");\n        t1.start();\n        MyThread1 t2 = new MyThread1();\n        t2.setName(\"线程B\");\n        t2.start();*/</span>\n\n    &#125;\n\n\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyThread1</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Thread</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> ticket = <span class=\"hljs-number\">100</span>;\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) &#123;\n                <span class=\"hljs-keyword\">if</span> (ticket &gt; <span class=\"hljs-number\">0</span>) &#123;\n                    System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t\\t\"</span> + ticket);\n                    ticket--;\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    <span class=\"hljs-keyword\">break</span>;\n                &#125;\n\n            &#125;\n\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>实现Runnable接口</li>\n</ul>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/06    19:35\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * 实现多线程的方式一\n * 实现Runnable接口\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyThread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">100</span>;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) &#123;\n                <span class=\"hljs-keyword\">if</span> (number&gt;<span class=\"hljs-number\">0</span>)&#123;\n                    System.out.println(Thread.currentThread().getName() +<span class=\"hljs-string\">\"\\t\\t\"</span>+ number);\n                    number--;\n                &#125;<span class=\"hljs-keyword\">else</span>&#123;\n                    <span class=\"hljs-keyword\">break</span>;\n                &#125;\n\n            &#125;\n        &#125;\n\n\n    &#125;\n&#125;\n\n\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadDemo</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        MyThread myThread = <span class=\"hljs-keyword\">new</span> MyThread();\n        <span class=\"hljs-keyword\">new</span> Thread(myThread,<span class=\"hljs-string\">\"线程A\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(myThread,<span class=\"hljs-string\">\"线程B\"</span>).start();\n\n    &#125;\n\n\n&#125;\n</code></pre>\n<h2 id=\"callable的简单使用\"><a class=\"markdownIt-Anchor\" href=\"#callable的简单使用\"></a> Callable的简单使用</h2>\n<ul>\n<li>实现Callable接口</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172853.png\" alt=\"image-20220108212709371\" /></p>\n<p><strong>实现多线程的方式三之实现Callable接口</strong>，之前两种太简单了就不写了</p>\n<p><strong>get方法</strong>一般请放在最后一行,因为如果实现的Callable类中有阻塞的话，它会等它执行完才会执行下面的</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/06    20:11\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n * 选中那个接口，然后使用Ctrl+Alt+U查看这个类或者接口的类图\n * get方法一般请放在最后一行,因为如果实现的Callable类中有阻塞的话\n * 它会等它执行完才会执行下面的\n *在·\n */</span>\n\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.Callable;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.FutureTask;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeUnit;\n\n<span class=\"hljs-comment\">/**\n * 多线程实现方法三实现Callable接口\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyThread2</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Callable</span>&lt;<span class=\"hljs-title\">Integer</span>&gt; </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Integer <span class=\"hljs-title\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        System.out.println(Thread.currentThread().getName()+<span class=\"hljs-string\">\"\\t\\t  hello world\"</span>);\n        TimeUnit.SECONDS.sleep(<span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1024</span>;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CallableDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n\n        <span class=\"hljs-comment\">// Interface RunnableFuture&lt;V&gt; 是Runnable的子接口 。FutureTask实现了RunnableFuture接口、</span>\n        <span class=\"hljs-comment\">// FutureTask的一个构造方法   FutureTask(Callable&lt;V&gt; callable)</span>\n        <span class=\"hljs-comment\">// Thread(Runnable target, String name) ， 在Thread的构造器中只要传入Runnable或者Runnable的子接口或者实现类即可</span>\n        <span class=\"hljs-comment\">// 这里主要是多态的的思想</span>\n        FutureTask&lt;Integer&gt; futureTask = <span class=\"hljs-keyword\">new</span> FutureTask&lt;&gt;(<span class=\"hljs-keyword\">new</span> MyThread2());\n        <span class=\"hljs-comment\">/**\n         * 打印结果\n         * hello world\n         * 1024\n         * main计算完成、\n         * 这里只会打印一次hello world，因为它有缓存\n         */</span>\n        <span class=\"hljs-keyword\">new</span> Thread(futureTask,<span class=\"hljs-string\">\"线程a\"</span>).start();\n        <span class=\"hljs-keyword\">new</span> Thread(futureTask,<span class=\"hljs-string\">\"线程b\"</span>).start();\n        System.out.println(futureTask.get());\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"计算完成\"</span>);\n        \n    &#125;\n\n&#125;\n</code></pre>\n<p>面试题:callable接口与runnable接口的区别？</p>\n<p>答：（1）是否有返回值<br />\n（2）是否抛异常<br />\n（3）落地方法不一样，一个是run，一个是call</p>\n<h2 id=\"futuretask\"><a class=\"markdownIt-Anchor\" href=\"#futuretask\"></a> FutureTask</h2>\n<p>未来的任务，用它就干一件事，异步调用<br />\nmain方法就像一个冰糖葫芦，一个个方法由main串起来。<br />\n但解决不了一个问题：正常调用挂起堵塞问题</p>\n<p><img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220108213632391.png\" alt=\"image-20220108213632391\" /></p>\n<h3 id=\"例子\"><a class=\"markdownIt-Anchor\" href=\"#例子\"></a> 例子：</h3>\n<p>（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，<br />\n水买回来了放桌上，我需要的时候再去get。<br />\n（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，<br />\nFutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果<br />\n（3）高考：会做的先做，不会的放在后面做</p>\n<h3 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h3>\n<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br />\n当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>\n<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>\n<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，<br />\n就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，<br />\n然后会返回结果或者抛出异常。</p>\n<p><strong>只计算一次</strong><br />\n<strong>get方法放到最后</strong></p>\n<p>FutureTask类图 <img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220107131432435.png\" alt=\"image-20220107131432435\" /></p>\n<h1 id=\"juc强大的辅助类讲解\"><a class=\"markdownIt-Anchor\" href=\"#juc强大的辅助类讲解\"></a> JUC强大的辅助类讲解</h1>\n<h2 id=\"countdownlatch-减少计数\"><a class=\"markdownIt-Anchor\" href=\"#countdownlatch-减少计数\"></a> CountDownLatch 减少计数</h2>\n<h3 id=\"原理-2\"><a class=\"markdownIt-Anchor\" href=\"#原理-2\"></a> 原理</h3>\n<ul>\n<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>\n<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>\n<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>\n</ul>\n<h3 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h3>\n<p>生活中的实例就是晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门，减少计数</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/07    15:19\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * CountDownLatch\n * 这个类似生活中的例子：晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门\n * 减少计数\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CountDownLatchDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n        <span class=\"hljs-comment\">// 构造一个以给定计数 CountDownLatch CountDownLatch。 java.util.concurrent</span>\n        CountDownLatch countDownLatch = <span class=\"hljs-keyword\">new</span> CountDownLatch(<span class=\"hljs-number\">6</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">6</span>; i++) &#123;\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"离开教室\"</span>);\n                <span class=\"hljs-comment\">//countDown() 减少锁存器的计数，如果计数达到零，释放所有等待的线程。</span>\n                countDownLatch.countDown();\n            &#125;, String.valueOf(i)).start();\n        &#125;\n        <span class=\"hljs-comment\">// 导致当前线程等到锁存器计数到零，除非线程是 interrupted,</span>\n        <span class=\"hljs-comment\">// 其实也就是说当里面的count减少到0就不用等待了，唤醒线程</span>\n        countDownLatch.await();\n        System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t班长关闭教室\"</span>);\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">closeDoor</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">6</span>; i++) &#123;\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"离开教室\"</span>);\n            &#125;, String.valueOf(i)).start();\n\n        &#125;\n    System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t班长关闭教室\"</span>);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"cyclicbarrier-循环栅栏\"><a class=\"markdownIt-Anchor\" href=\"#cyclicbarrier-循环栅栏\"></a> CyclicBarrier  循环栅栏</h2>\n<h3 id=\"原理-3\"><a class=\"markdownIt-Anchor\" href=\"#原理-3\"></a> 原理</h3>\n<p><strong>CyclicBarrier</strong> 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞， 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p>\n<p>这个可以举一个简单的例子就<strong>是，集齐七颗龙珠召唤神龙，还有就是开会，必须要等到人到齐了才能开会。</strong></p>\n<h3 id=\"代码-2\"><a class=\"markdownIt-Anchor\" href=\"#代码-2\"></a> 代码</h3>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/07    15:55\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * java.util.concurrent  CyclicBarrier\n * 其实这个有点像生活中的例子：开会，还有七龙珠，集齐七颗龙珠召唤神龙\n * 开会必须等待所有人都到齐了才行\n *\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CyclicBarrierDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        CyclicBarrier cb = <span class=\"hljs-keyword\">new</span> CyclicBarrier(<span class=\"hljs-number\">7</span>, () -&gt; &#123;\n            System.out.println(<span class=\"hljs-string\">\"召唤神龙\"</span>);\n        &#125;);\n\n        <span class=\"hljs-comment\">/**\n         * 等待所有parties已经在这个障碍上调用了await 。\n         * 如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：\n         * 最后一个线程到达; 要么\n         * 一些其他线程当前线程为interrupts ; 要么\n         * 一些其他线程interrupts其他等待线程之一; 要么\n         * 一些其他线程在等待屏障时超时; 要么\n         * 其他一些线程在这个屏障上调用reset() 。\n         */</span>\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">7</span>; i++) &#123;\n            <span class=\"hljs-keyword\">int</span> temp = i;\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"收集到的\\t第\"</span> + temp + <span class=\"hljs-string\">\"颗龙珠\"</span>);\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-comment\">//等待所有parties已经在这个障碍上调用了await 。</span>\n                    <span class=\"hljs-comment\">//如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：最后一个线程到了</span>\n                    <span class=\"hljs-comment\">// 也就是等到最后一个线程到了，然后就开始执行start，start之后，线程的调度顺序还得看操作系统和cup的调度</span>\n                    cb.await();\n                    <span class=\"hljs-comment\">// 执行完成之后，就调用CyclicBarrier(int parties, Runnable barrierAction) 里面的barrierAction线程</span>\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125; <span class=\"hljs-keyword\">catch</span> (BrokenBarrierException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;, <span class=\"hljs-string\">\"线程\\t\"</span> + i).start();\n\n        &#125;\n\n\n    &#125;\n\n\n&#125;\n</code></pre>\n<h2 id=\"semaphore-信号灯\"><a class=\"markdownIt-Anchor\" href=\"#semaphore-信号灯\"></a> Semaphore 信号灯</h2>\n<h3 id=\"原理-4\"><a class=\"markdownIt-Anchor\" href=\"#原理-4\"></a> 原理</h3>\n<p>在信号量上我们定义两种操作：</p>\n<p>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</p>\n<p>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</p>\n<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>\n<p><strong>这个可以用生活中的抢车位来类比</strong></p>\n<h3 id=\"代码-3\"><a class=\"markdownIt-Anchor\" href=\"#代码-3\"></a> 代码</h3>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/07    16:40\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * Semaphore这个主要是应用于抢车位\n * 这个主要用于多线程的并发控制和资源的互斥\n *\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SemaphoreDemo</span> </span>&#123;\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n\n\n\n        <span class=\"hljs-comment\">// 模拟资源类，有三个空车位</span>\n        <span class=\"hljs-comment\">// 当permits设置为1就相当于synchronized了</span>\n        Semaphore semaphore = <span class=\"hljs-keyword\">new</span> Semaphore(<span class=\"hljs-number\">3</span>);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">7</span>; i++) &#123;\n\n\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-comment\">//从此信号量获取许可证，阻止直到可用，否则线程为interrupted 。</span>\n                    <span class=\"hljs-comment\">//获得许可证，如果有可用并立即返回，则将可用许可证数量减少一个。</span>\n                    <span class=\"hljs-comment\">// 这里相当于抢占到车位</span>\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t抢到了车位\"</span>);\n                    <span class=\"hljs-comment\">// 线程睡4秒钟，模拟停车停了4秒钟</span>\n                    TimeUnit.SECONDS.sleep(<span class=\"hljs-number\">4</span>);\n                    System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t离开了车位\"</span>);\n                &#125; <span class=\"hljs-keyword\">catch</span> (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n                    <span class=\"hljs-comment\">//发放许可证，将可用许可证的数量增加一个。 如果任何线程尝试获取许可证，</span>\n                    <span class=\"hljs-comment\">// 那么选择一个被授予刚被释放的许可证。 （重新）线程调度用于线程调度。</span>\n                    <span class=\"hljs-comment\">// 这里相当于释放掉车位</span>\n                    semaphore.release();\n                &#125;\n            &#125;, <span class=\"hljs-string\">\"线程\"</span> + i).start();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"reentrantreadwritelock读写锁\"><a class=\"markdownIt-Anchor\" href=\"#reentrantreadwritelock读写锁\"></a> ReentrantReadWriteLock读写锁</h1>\n<h2 id=\"类似案例\"><a class=\"markdownIt-Anchor\" href=\"#类似案例\"></a> 类似案例</h2>\n<p>红蜘蛛、缓存、数据库的更新和查询操作。</p>\n<h2 id=\"代码-4\"><a class=\"markdownIt-Anchor\" href=\"#代码-4\"></a> 代码</h2>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/07    22:00\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行\n * 但是\n * 如果有一个线程想去写共享资源来，就不应该再有其他线程可以对该资源进行读或者写\n * 小总结：\n *          读-读能共存\n *          读-写不能共存\n *          写-写不能共存\n * 使用读写锁，保证了数据的一致性操作  读锁是共享锁\n * 其实就是写加写锁,读就加读锁       写锁是排他锁\n *\n *\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCache</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n    <span class=\"hljs-keyword\">private</span> ReadWriteLock readWriteLock = <span class=\"hljs-keyword\">new</span> ReentrantReadWriteLock();\n\n    <span class=\"hljs-comment\">/**\n     * 添加操作\n     * <span class=\"hljs-doctag\">@param</span> key\n     * <span class=\"hljs-doctag\">@param</span> value\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(String key, Object value)</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 加写锁</span>\n            readWriteLock.writeLock().lock();\n            <span class=\"hljs-comment\">// 写入开始</span>\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t------写入开始\"</span>);\n            map.put(key, value);\n            TimeUnit.SECONDS.sleep(<span class=\"hljs-number\">3</span>);\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t------写入完成\"</span>);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 释放锁</span>\n            readWriteLock.writeLock().unlock();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 读取操作\n     * <span class=\"hljs-doctag\">@param</span> key\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(String key)</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-comment\">// 加写锁</span>\n            readWriteLock.readLock().lock();\n            <span class=\"hljs-comment\">// 读取开始</span>\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t~~~~~~~~~~~~~~~~~~~~~~读取开始\"</span>);\n            map.get(key);\n            TimeUnit.SECONDS.sleep(<span class=\"hljs-number\">3</span>);\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t~~~~~~~~~~~~~~~~~~~~~~\"</span> +\n                    <span class=\"hljs-string\">\".读取完成\"</span>);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 释放锁</span>\n            readWriteLock.readLock().unlock();\n        &#125;\n    &#125;\n\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReadWriteLockDemo</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        MyCache myCache = <span class=\"hljs-keyword\">new</span> MyCache();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> temp = i;\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n\n                myCache.put(temp + <span class=\"hljs-string\">\"\\t\"</span>, temp + <span class=\"hljs-string\">\"\\t\"</span>);\n            &#125;, String.valueOf(i)).start();\n\n        &#125;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;=<span class=\"hljs-number\">5</span> ; i++) &#123;\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> temp = i;\n            <span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;\n                myCache.get(temp + <span class=\"hljs-string\">\"\\t\"</span>);\n            &#125;, String.valueOf(i)).start();\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<p>阻塞队列，空的时候不能消费，满的时候不能增加</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172859.png\" alt=\"image-20220109110721761\" /></p>\n<h1 id=\"blockingqueuedemo-阻塞队列\"><a class=\"markdownIt-Anchor\" href=\"#blockingqueuedemo-阻塞队列\"></a> BlockingQueueDemo  阻塞队列</h1>\n<h2 id=\"栈与队列\"><a class=\"markdownIt-Anchor\" href=\"#栈与队列\"></a> 栈与队列</h2>\n<p>栈：先进后出，<strong>后进先出</strong></p>\n<p>队列：先进先出</p>\n<h2 id=\"阻塞队列的简单说明\"><a class=\"markdownIt-Anchor\" href=\"#阻塞队列的简单说明\"></a> 阻塞队列的简单说明</h2>\n<p><strong>阻塞：必须要阻塞/不得不阻塞</strong><br />\n阻塞队列是一个队列，在数据结构中起的作用如下图：<img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172904.png\" alt=\"image-20220109154737709\" /></p>\n<p>当队列是空的，从队列中<strong>获取</strong>元素的操作将会被<strong>阻塞</strong><br />\n当队列是满的，从队列中<strong>添加</strong>元素的操作将会被<strong>阻塞</strong></p>\n<p>试图从<strong>空的队列中获取元素的线程将会被阻塞</strong>，<strong>直到其他线程往空的队列插入新的元素</strong></p>\n<p>试图<strong>向已满的队列中添加新元素的线程将会被阻塞</strong>，<strong>直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</strong></p>\n<h2 id=\"阻塞队列的用处\"><a class=\"markdownIt-Anchor\" href=\"#阻塞队列的用处\"></a> 阻塞队列的用处</h2>\n<p>在多线程领域：所谓阻塞，在某些情况下会<strong>挂起</strong>线程（即阻塞），一旦条件满足，被挂起的线程又会自动<strong>被唤起</strong></p>\n<p>为什么需要BlockingQueue<br />\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>\n<p>在concurrent包发布以前，在多线程环境下，**我们每个程序员都必须去自己控制这些细节，尤其还要兼顾    **效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>\n<h2 id=\"阻塞队列的类图\"><a class=\"markdownIt-Anchor\" href=\"#阻塞队列的类图\"></a> 阻塞队列的类图</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172907.png\" alt=\"image-20220109155943058\" /></p>\n<p>下面三个最常用</p>\n<ul>\n<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</li>\n<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</li>\n<li>LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172913.png\" alt=\"image-20220109084253324\" /></p>\n<h2 id=\"blockingqueue核心方法\"><a class=\"markdownIt-Anchor\" href=\"#blockingqueue核心方法\"></a> BlockingQueue核心方法</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172920.png\" alt=\"image-20220109160455125\" /></p>\n<table>\n<thead>\n<tr>\n<th>抛出异常</th>\n<th>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>特殊值</td>\n<td>插入方法，成功ture失败false<br/>移除方法，成功返回出队列的元素，队列里没有就返回null</td>\n</tr>\n<tr>\n<td>一直阻塞</td>\n<td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出<br/>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td>\n</tr>\n<tr>\n<td>超时退出</td>\n<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"阻塞队列代码\"><a class=\"markdownIt-Anchor\" href=\"#阻塞队列代码\"></a> 阻塞队列代码</h2>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/09    8:56\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n * 队列：先进先出，FIFO，就相当于食堂排队\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BlockingQueueDemo</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n        BlockingQueue&lt;String&gt; queue = <span class=\"hljs-keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"hljs-number\">3</span>);\n\n        <span class=\"hljs-comment\">/**\n         * 抛出异常\n         * add:添加方法\n         * remove：移除方法\n         * element：检查方法， element是返回队首的元素，如果队列没有元素就返回null\n         */</span>\n\n        <span class=\"hljs-comment\">// add方法是添加元素</span>\n <span class=\"hljs-comment\">/*       System.out.println(queue.add(\"a\"));\n        System.out.println(queue.add(\"a\"));\n        System.out.println(queue.add(\"c\"));\n        // 队列满了\n//        queue.add(\"d\");  // Exception in thread \"main\" java.lang.IllegalStateException: Queue full\n        System.out.println(\"========================================================================================\");\n        // element是返回队首的元素\n        System.out.println(queue.element());\n        // remove是移除元素\n        System.out.println(queue.remove());\n        System.out.println(queue.remove());\n        System.out.println(queue.remove());\n        // 队列为空了\n//        System.out.println(queue.remove()); // Exception in thread \"main\" java.util.NoSuchElementException\n\n        System.out.println(\"========================================================================================\");\n*/</span>\n        <span class=\"hljs-comment\">/**\n         * 特殊值\n         * offer：插入成功返回true\n         * poll：移除操作(移除队首的操作)，成功返回出队列的元素，队列里面没有就返回null\n         * peek：检索但不删除由此queue表示的队列的头部（换句话说，该deque的第一个元素），\n         * 如果此deque为空，则返回 null 。\n         */</span>\n<span class=\"hljs-comment\">/*\n        System.out.println(queue.offer(\"aa\"));\n        System.out.println(queue.offer(\"bb\"));\n        System.out.println(queue.offer(\"cc\"));\n//        System.out.println(queue.offer(\"cc\")); // false\n\n        System.out.println(queue.peek());\n        System.out.println(queue.peek());\n        System.out.println(queue.peek());\n\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n//        System.out.println(queue.poll()); // null\n        System.out.println(\"========================================================================================\");\n*/</span>\n\n  <span class=\"hljs-comment\">/*      queue.put(\"aa\");\n        queue.put(\"aa\");\n        queue.put(\"aa\");\n//        queue.put(\"aa\");    //这里本来只能放三个元素，但是想要添加四个元素，所以，最后的元素就会被阻塞，就相当于一直在等待消费去消费\n\n        queue.take();\n        queue.take();\n        queue.take();\n//        queue.take();   // 这队列里面本来只有三个元素，这里要获取第四个，所以就得一直等着，等生产者生产第四个\n\n\n\n*/</span><span class=\"hljs-comment\">/*\n        System.out.println(queue.take());\n        System.out.println(queue.take());\n        System.out.println(queue.take());\n*/</span><span class=\"hljs-comment\">/*\n\n         */</span>\n        System.out.println(queue.offer(<span class=\"hljs-string\">\"aa\"</span>));\n        System.out.println(queue.offer(<span class=\"hljs-string\">\"aa\"</span>));\n        System.out.println(queue.offer(<span class=\"hljs-string\">\"aa\"</span>));\n        <span class=\"hljs-comment\">// 这个是等三秒，三秒要是还没有蛋糕就走了，过时不候</span>\n        System.out.println(queue.offer(<span class=\"hljs-string\">\"aa\"</span>, <span class=\"hljs-number\">3L</span>, TimeUnit.SECONDS));\n\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"方法参数的值传递机制\"><a class=\"markdownIt-Anchor\" href=\"#方法参数的值传递机制\"></a> 方法参数的值传递机制</h2>\n<ul>\n<li><strong>方法</strong>，必须由其所在类或对象调用才有意义。若方法含有参数：\n<ul>\n<li><strong>形参</strong>：方法声明时的参数</li>\n<li><strong>实参</strong>：方法调用时实际传给形参的参数值</li>\n</ul>\n</li>\n</ul>\n<p>Java的实参值如何传入方法呢？ Java里方法的参数传递方式只有一种：<strong>值传递。 即将实际参数值的副本 （复制品）传入方法内，而参数本身不受影响。</strong></p>\n<p>形参是<strong>基本数据类型</strong>：将实参基本数据类型变量的**“数据值”**传递给形参</p>\n<p>形参是<strong>引用数据类型</strong>：将实参引用数据类型变量的**“地址值”**传递给形参</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/09    10:10\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestTransferValue</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changeValue1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> age)</span> </span>&#123;\n        age = <span class=\"hljs-number\">30</span>;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changeValue2</span><span class=\"hljs-params\">(Person person)</span> </span>&#123;\n        person.setName(<span class=\"hljs-string\">\"xxxx\"</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changeValue3</span><span class=\"hljs-params\">(String str)</span> </span>&#123;\n        str = <span class=\"hljs-string\">\"~~~~\"</span>;\n    &#125;\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        TestTransferValue transferValue = <span class=\"hljs-keyword\">new</span> TestTransferValue();\n        <span class=\"hljs-comment\">//  在一个方法里面，基本类型只传复印件，原件不动</span>\n        <span class=\"hljs-keyword\">int</span> age =<span class=\"hljs-number\">20</span>;\n        transferValue.changeValue1(age);\n\n        System.out.println(<span class=\"hljs-string\">\"age = \"</span> + age);\n\n        <span class=\"hljs-comment\">// 这个自定义类型Person穿的是引用类型</span>\n\n        Person person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"zsf\"</span>);\n        transferValue.changeValue2(person);\n        System.out.println(<span class=\"hljs-string\">\"personName -------------&gt;\"</span> + person.getName());\n\n        String str= <span class=\"hljs-string\">\"abc\"</span>;\n        transferValue.changeValue3(str);\n        System.out.println(<span class=\"hljs-string\">\"str = \"</span> + str);\n    &#125;\n\n\n&#125;\t\n</code></pre>\n<p>Person类</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-meta\">@AllArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> age;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">(String name)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.name = name;\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172926.png\" alt=\"image-20220109174059210\" /></p>\n<h1 id=\"threadpool线程池\"><a class=\"markdownIt-Anchor\" href=\"#threadpool线程池\"></a> ThreadPool线程池</h1>\n<hr />\n<h2 id=\"为什么用线程池\"><a class=\"markdownIt-Anchor\" href=\"#为什么用线程池\"></a> 为什么用线程池</h2>\n<p>例子：<br />\n10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br />\n现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>\n<p><strong>线程池的优势：</strong><br />\n线程池做的工作只要是控制运行的线程数量，**处理过程中将任务放入队列，**然后在线程创建后启动这些任务，**如果线程数量超过了最大数量，超出数量的线程排队等候，**等其他线程执行完毕，再从队列中取出任务来执行。</p>\n<p>**它的主要特点为：线程复用;控制最大并发数;管理线程。                                                                       **</p>\n<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br />\n第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br />\n第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>\n<h2 id=\"线程池如何使用\"><a class=\"markdownIt-Anchor\" href=\"#线程池如何使用\"></a> 线程池如何使用</h2>\n<h3 id=\"架构说明\"><a class=\"markdownIt-Anchor\" href=\"#架构说明\"></a> 架构说明</h3>\n<p>Java中的线程池是通过Executor框架实现的，该框架中用到了<code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code>这几个类</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172930.png\" alt=\"image-20220109172347156\" /></p>\n<h3 id=\"编码实现\"><a class=\"markdownIt-Anchor\" href=\"#编码实现\"></a> 编码实现</h3>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/09    14:10\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n * 线程池\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyThreadPoolDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n        <span class=\"hljs-comment\">// =================第一种=================</span>\n        <span class=\"hljs-comment\">// Executors是线程池的工具类</span>\n        <span class=\"hljs-comment\">// newFixedThreadPool创建\t一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。</span>\n        <span class=\"hljs-comment\">// 创建线程池，设置办理窗口(初始线程)为5</span>\n        <span class=\"hljs-comment\">// 一池5线程，类似一个银行有5个受理窗口</span>\n<span class=\"hljs-comment\">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);</span>\n\n        <span class=\"hljs-comment\">// =================第二种=================</span>\n        <span class=\"hljs-comment\">// 线程池只有一个工作线程，类似于，银行只有一个办理窗口</span>\n        <span class=\"hljs-comment\">//  ExecutorService threadPool = Executors.newSingleThreadExecutor();</span>\n        <span class=\"hljs-comment\">// 一池N线程，一个池子里面有多个线程，类似于银行有N个受理窗口，这和每个线程执行的事件有关</span>\n        <span class=\"hljs-comment\">// 创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程。</span>\n\n\n        <span class=\"hljs-comment\">// =================第三种=================</span>\n        ExecutorService threadPool = Executors.newCachedThreadPool();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">10</span>; i++) &#123;\n                threadPool.submit(() -&gt; &#123;\n\n                    System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t办理完成\"</span>);\n                &#125;);\n                <span class=\"hljs-comment\">// 暂停1秒钟，模拟办理时候的耗时</span>\n<span class=\"hljs-comment\">//                TimeUnit.SECONDS.sleep(1);</span>\n\n            &#125;\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-comment\">// 关闭线程池</span>\n            threadPool.shutdown();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"底层原理\"><a class=\"markdownIt-Anchor\" href=\"#底层原理\"></a> 底层原理</h3>\n<p>其实他底层都是创建一个<strong>ThreadPoolExecutor</strong>，然后传入不同类型的参数，调用不同的构造器</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Creates a new &#123;<span class=\"hljs-doctag\">@code</span> ThreadPoolExecutor&#125; with the given initial\n * parameters and default thread factory and rejected execution handler.\n * It may be more convenient to use one of the &#123;<span class=\"hljs-doctag\">@link</span> Executors&#125; factory\n * methods instead of this general purpose constructor.\n *\n * <span class=\"hljs-doctag\">@param</span> corePoolSize the number of threads to keep in the pool, even\n *        if they are idle, unless &#123;<span class=\"hljs-doctag\">@code</span> allowCoreThreadTimeOut&#125; is set\n * <span class=\"hljs-doctag\">@param</span> maximumPoolSize the maximum number of threads to allow in the\n *        pool\n * <span class=\"hljs-doctag\">@param</span> keepAliveTime when the number of threads is greater than\n *        the core, this is the maximum time that excess idle threads\n *        will wait for new tasks before terminating.\n * <span class=\"hljs-doctag\">@param</span> unit the time unit for the &#123;<span class=\"hljs-doctag\">@code</span> keepAliveTime&#125; argument\n * <span class=\"hljs-doctag\">@param</span> workQueue the queue to use for holding tasks before they are\n *        executed.  This queue will hold only the &#123;<span class=\"hljs-doctag\">@code</span> Runnable&#125;\n *        tasks submitted by the &#123;<span class=\"hljs-doctag\">@code</span> execute&#125; method.\n * <span class=\"hljs-doctag\">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;\n *         &#123;<span class=\"hljs-doctag\">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;\n *         &#123;<span class=\"hljs-doctag\">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;\n *         &#123;<span class=\"hljs-doctag\">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;\n *         &#123;<span class=\"hljs-doctag\">@code</span> maximumPoolSize &lt; corePoolSize&#125;\n * <span class=\"hljs-doctag\">@throws</span> NullPointerException if &#123;<span class=\"hljs-doctag\">@code</span> workQueue&#125; is null\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ThreadPoolExecutor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> corePoolSize,\n                          <span class=\"hljs-keyword\">int</span> maximumPoolSize,\n                          <span class=\"hljs-keyword\">long</span> keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n         Executors.defaultThreadFactory(), defaultHandler);\n&#125;\n</code></pre>\n<p><img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220109181909648.png\" alt=\"image-20220109181909648\" /></p>\n<h2 id=\"线程池几个重要参数\"><a class=\"markdownIt-Anchor\" href=\"#线程池几个重要参数\"></a> 线程池几个重要参数</h2>\n<ol>\n<li>\n<p><code>corePoolSize</code>：线程池中的常驻核心线程数</p>\n</li>\n<li>\n<p><code>maximumPoolSize</code>：线程池中能够容纳同时<br />\n执行的最大线程数，此值必须大于等于1</p>\n</li>\n<li>\n<p><code>keepAliveTime</code>：多余的空闲线程的存活时间<br />\n当前池中线程数量超过corePoolSize时，当空闲时间<br />\n达到<code>keepAliveTime</code>时，多余线程会被销毁直到<br />\n只剩下<code>corePoolSize</code>个线程为止</p>\n</li>\n<li>\n<p><code>unit：</code> <code>keepAliveTime</code>的单位</p>\n</li>\n<li>\n<p><code>workQueue</code>：任务队列，被提交但尚未被执行的任务</p>\n</li>\n<li>\n<p><code>threadFactory</code>：表示生成线程池中工作线程的线程工厂，<br />\n用于创建线程，一般默认的即可</p>\n</li>\n<li>\n<p><code>handler</code>：拒绝策略，表示当队列满了，并且工作线程大于<br />\n等于线程池的最大线程数（<code>maximumPoolSize</code>）时如何来拒绝<br />\n请求执行的runnable的策略</p>\n</li>\n</ol>\n<h2 id=\"线程池底层工作原理\"><a class=\"markdownIt-Anchor\" href=\"#线程池底层工作原理\"></a> 线程池底层工作原理</h2>\n<p>步骤是下面的1到4</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172935.png\" alt=\"image-20220109183737541\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172938.png\" alt=\"image-20220109203111160\" /></p>\n<p>下图的<code>corePoolSize</code>为2，<code>maximumPoolSize</code>为5，当一开始有两个客户（1，2线程）来办理业务的时候，两个今日窗口正好能够处理。当后面3，4，5又来时，<code>BlockingQueue</code>也正好满了（为5）；然后大堂经理就叫其他的员工来值班扩大到<code>maximumPoolSize</code>（也就是扩容到最大的线程数5）。当后面又进来三个线程（6，7，8）的时候就进入候客区（<code>BlockingQueue</code>），候客区也满了。但此时如果进来了另一个客户（9），就会告知本银行今天的业务繁忙，请到其他网点去办理业务（这里是按照拒绝策略处理）。如果设置了<code>keepAliveTime</code>的话，新增的扩容的员工，在处理完所有的业务之后，过<code>keepAliveTime</code>这么久时间，就会恢复到原来的<code>corePoolSize</code>.</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ThreadPoolExecutor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> corePoolSize,\n                          <span class=\"hljs-keyword\">int</span> maximumPoolSize,\n                          <span class=\"hljs-keyword\">long</span> keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue)</span>\n</span></code></pre>\n<p><img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220109195333905.png\" alt=\"image-20220109195333905\" /></p>\n<p><img src=\"C:%5CUsers%5Closser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220109201025539.png\" alt=\"image-20220109201025539\" /></p>\n<p><strong>以下重要：</strong></p>\n<ol>\n<li>\n<p>在创建了线程池后，开始等待请求。</p>\n</li>\n<li>\n<p>当调用**execute()**方法添加一个请求任务时，线程池会做出如下判断：</p>\n<pre><code> 2.2如果正在运行的线程数量小于**corePoolSize**，那么马上创建线程运行这个任务；\n\n 2.2如果正在运行的线程数量大于或等于**corePoolSize**，那么将这个任务放入队列；\n\n 2.3如果这个时候队列满了且正在运行的线程数量还小于**maximumPoolSize**，那么还是要创建非核心线程立刻运行这个任务；\n\n 2.4如果队列满了且正在运行的线程数量大于或等于**maximumPoolSize**，那么线程池会启动饱和拒绝策略来执行。\n</code></pre>\n</li>\n</ol>\n<p>3当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>\n<p>4当一个线程无事可做超过一定的时间（<strong>keepAliveTime</strong>）时，线程会判断：</p>\n<p>如果当前运行的线程数大于<strong>corePoolSize</strong>，那么这个线程就被停掉。</p>\n<p>所以线程池的所有任务完成后，它最终会收缩到<strong>corePoolSize</strong>的大小。</p>\n<h2 id=\"线程池用哪个生产中如设置合理参数\"><a class=\"markdownIt-Anchor\" href=\"#线程池用哪个生产中如设置合理参数\"></a> 线程池用哪个？生产中如设置合理参数</h2>\n<h3 id=\"线程池的拒绝策略\"><a class=\"markdownIt-Anchor\" href=\"#线程池的拒绝策略\"></a> 线程池的拒绝策略</h3>\n<h4 id=\"是什么\"><a class=\"markdownIt-Anchor\" href=\"#是什么\"></a> 是什么</h4>\n<p><strong>等待队列已经排满了</strong>，再也塞不下新任务了</p>\n<p>同时，<strong>线程池中的max线程也达到了</strong>，无法继续为新任务服务。</p>\n<p>这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p>\n<h4 id=\"jdk内置的拒绝策略\"><a class=\"markdownIt-Anchor\" href=\"#jdk内置的拒绝策略\"></a> JDK内置的拒绝策略</h4>\n<ul>\n<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>\n<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不<br />\n会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li>\n<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中<br />\n尝试再次提交当前任务。</li>\n<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br />\n如果允许任务丢失，这是最好的一种策略。</li>\n</ul>\n<h3 id=\"以上内置拒绝策略均实现了rejectedexecutionhandle接口\"><a class=\"markdownIt-Anchor\" href=\"#以上内置拒绝策略均实现了rejectedexecutionhandle接口\"></a> 以上内置拒绝策略均实现了RejectedExecutionHandle接口</h3>\n<h2 id=\"在工作中单一的固定数的可变的三种创建线程池的方法哪个用的多超级大坑\"><a class=\"markdownIt-Anchor\" href=\"#在工作中单一的固定数的可变的三种创建线程池的方法哪个用的多超级大坑\"></a> 在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</h2>\n<ol>\n<li>答案是一个都不用，我们工作中只能使用自定义的</li>\n<li>Executors中JDK已经给你提供了，为什么不用？</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172949.png\" alt=\"image-20220109184859628\" /></p>\n<h1 id=\"java8之流式计算复习\"><a class=\"markdownIt-Anchor\" href=\"#java8之流式计算复习\"></a> Java8之流式计算复习</h1>\n<h2 id=\"函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#函数式接口\"></a> 函数式接口</h2>\n<h3 id=\"javautilfunction\"><a class=\"markdownIt-Anchor\" href=\"#javautilfunction\"></a> java.util.function</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172952.png\" alt=\"image-20220111120945026\" /></p>\n<h3 id=\"java内置核心四大函数式接口\"><a class=\"markdownIt-Anchor\" href=\"#java内置核心四大函数式接口\"></a> java内置核心四大函数式接口</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172954.png\" alt=\"image-20220111121004428\" /></p>\n<p>伪代码：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">//R apply(T t);函数型接口，一个参数，一个返回值</span>\nFunction&lt;String,Integer&gt; function = t -&gt;&#123;<span class=\"hljs-keyword\">return</span> t.length();&#125;;\nSystem.out.println(function.apply(<span class=\"hljs-string\">\"abcd\"</span>));\n\n<span class=\"hljs-comment\">//boolean test(T t);断定型接口，一个参数，返回boolean</span>\nPredicate&lt;String&gt; predicate = t-&gt;&#123;<span class=\"hljs-keyword\">return</span> t.startsWith(<span class=\"hljs-string\">\"a\"</span>);&#125;;\nSystem.out.println(predicate.test(<span class=\"hljs-string\">\"a\"</span>));\n\n<span class=\"hljs-comment\">// void accept(T t);消费型接口，一个参数，没有返回值</span>\nConsumer&lt;String&gt; consumer = t-&gt;&#123;\n    System.out.println(t);\n&#125;;\nconsumer.accept(<span class=\"hljs-string\">\"javaXXXX\"</span>);\n\n<span class=\"hljs-comment\">//T get(); 供给型接口，无参数，有返回值</span>\nSupplier&lt;String&gt; supplier =()-&gt;&#123;<span class=\"hljs-keyword\">return</span> UUID.randomUUID().toString();&#125;;\nSystem.out.println(supplier.get());\n \n\n</code></pre>\n<h2 id=\"stream流\"><a class=\"markdownIt-Anchor\" href=\"#stream流\"></a> Stream流</h2>\n<h3 id=\"流是什么\"><a class=\"markdownIt-Anchor\" href=\"#流是什么\"></a> 流是什么</h3>\n<p>流(Stream) 到底是什么呢？<br />\n是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br />\n<strong>“集合讲的是数据，流讲的是计算！”</strong></p>\n<h3 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\"></a> 特点</h3>\n<ol>\n<li>Stream 自己不会存储元素</li>\n<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>\n<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n<h3 id=\"阶段\"><a class=\"markdownIt-Anchor\" href=\"#阶段\"></a> 阶段</h3>\n<ol>\n<li>创建一个Stream：一个数据源（数组、集合）</li>\n<li>中间操作：一个中间操作，处理数据源数据</li>\n<li>终止操作：一个终止操作，执行中间操作链，产生结果</li>\n</ol>\n<p>过程：</p>\n<p><strong>源头=&gt;中间流水线=&gt;结果</strong></p>\n<p>代码示例：</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/10    13:15\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n *\n *  (lambda表达式的几个步骤 ：\n *1 、 拷贝小括号 ( 如果只有一个参数的话, 可以省略参数类型和括号)\n *          2、写死右箭头\n *          3/落地大括号\n */</span>\n<span class=\"hljs-meta\">@AllArgsConstructor</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-comment\">// 支持链式调用</span>\n<span class=\"hljs-meta\">@Accessors</span>(chain = <span class=\"hljs-keyword\">true</span>)\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>&#123;\n\n    <span class=\"hljs-comment\">// 链式编程 +   流式计算</span>\n\n    <span class=\"hljs-keyword\">private</span> Integer id;\n    <span class=\"hljs-keyword\">private</span> String userName;\n    <span class=\"hljs-keyword\">private</span> Integer age;\n&#125;\n\n<span class=\"hljs-comment\">/**\n * 题目:请按照给出数据，找出同时满足以下条件的用户,也即以下条件全部满足\n * 偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序\n * 只输出一个用户名字\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StreamDemo</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\n\n        User u1 = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-number\">11</span>,  <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-number\">23</span>);\n        User u2 = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-number\">24</span>);\n        User u3 = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-number\">22</span>);\n        User u4 = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-number\">14</span>, <span class=\"hljs-string\">\"d\"</span>, <span class=\"hljs-number\">28</span>);\n        User u5 = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-number\">16</span>, <span class=\"hljs-string\">\"e\"</span>, <span class=\"hljs-number\">26</span>);\n\n        <span class=\"hljs-comment\">// 将数组转换成list集合</span>\n        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);\n        List&lt;User&gt; users = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        list.stream().filter(user -&gt; &#123;\n            <span class=\"hljs-comment\">// 过滤掉为id为偶数的</span>\n            <span class=\"hljs-keyword\">return</span> user.getId() % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>;\n        &#125;).filter(user -&gt; &#123;\n            <span class=\"hljs-comment\">// 过滤年龄大于24的</span>\n            <span class=\"hljs-keyword\">return</span> user.getAge() &gt; <span class=\"hljs-number\">24</span>;\n            <span class=\"hljs-comment\">// map是映射</span>\n            <span class=\"hljs-comment\">// sorted是stream的排序，默认是升序</span>\n        &#125;).map(user -&gt; user.getUserName().toUpperCase()).sorted((o1, o2) -&gt; &#123;\n            <span class=\"hljs-comment\">// 降序排列</span>\n            <span class=\"hljs-keyword\">return</span> -o1.compareTo(o2);\n            <span class=\"hljs-comment\">// limit和MySQL中的类似，限制个数.forEach进行遍历，然后加</span>\n        &#125;).limit(<span class=\"hljs-number\">1</span>).forEach(System.out::println);\n\n\n        list.stream().sorted((o1, o2) -&gt; &#123;\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        &#125;);\n\n<span class=\"hljs-comment\">/*        for (User user : list) &#123;\n            if (user.getId() % 2 == 0 &amp;&amp; user.getAge() &gt; 24) &#123;\n                user.setUserName(user.getUserName().toUpperCase());\n                users.add(user);\n            &#125;\n        &#125;*/</span>\n\n\n    &#125;\n\n&#125;\n</code></pre>\n<h1 id=\"分支合并框架\"><a class=\"markdownIt-Anchor\" href=\"#分支合并框架\"></a> 分支合并框架</h1>\n<h2 id=\"原理-5\"><a class=\"markdownIt-Anchor\" href=\"#原理-5\"></a> 原理</h2>\n<p>Fork：把一个复杂任务进行分拆，大事化小<br />\nJoin：把分拆任务的结果进行合并</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173002.png\" alt=\"image-20220111121606583\" /></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173004.png\" alt=\"image-20220111121613341\" /></p>\n<h2 id=\"相关类\"><a class=\"markdownIt-Anchor\" href=\"#相关类\"></a> 相关类</h2>\n<p>和Exector相关，以及线程池有关</p>\n<h3 id=\"forkjoinpool\"><a class=\"markdownIt-Anchor\" href=\"#forkjoinpool\"></a> ForkJoinPool</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173007.png\" alt=\"image-20220111134910595\" /></p>\n<p>分支合并池    类比=&gt;   线程池</p>\n<h3 id=\"forkjointask\"><a class=\"markdownIt-Anchor\" href=\"#forkjointask\"></a> ForkJoinTask</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173010.png\" alt=\"image-20220111134928706\" /></p>\n<p>ForkJoinTask    类比=&gt;   FutureTask</p>\n<h3 id=\"recursivetask\"><a class=\"markdownIt-Anchor\" href=\"#recursivetask\"></a> RecursiveTask</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173012.png\" alt=\"image-20220111135645753\" /></p>\n<p>递归任务：继承后可以实现递归(自己调自己)调用的任务</p>\n<p>伪代码</p>\n<pre class=\"highlight\"><code class=\"java\"> \n <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Fibonacci</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RecursiveTask</span>&lt;<span class=\"hljs-title\">Integer</span>&gt; </span>&#123;\n   <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> n;\n   Fibonacci(<span class=\"hljs-keyword\">int</span> n) &#123; <span class=\"hljs-keyword\">this</span>.n = n; &#125;\n   <span class=\"hljs-function\">Integer <span class=\"hljs-title\">compute</span><span class=\"hljs-params\">()</span> </span>&#123;\n     <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>)\n       <span class=\"hljs-keyword\">return</span> n;\n     Fibonacci f1 = <span class=\"hljs-keyword\">new</span> Fibonacci(n - <span class=\"hljs-number\">1</span>);\n     f1.fork();\n     Fibonacci f2 = <span class=\"hljs-keyword\">new</span> Fibonacci(n - <span class=\"hljs-number\">2</span>);\n     <span class=\"hljs-keyword\">return</span> f2.compute() + f1.join();\n   &#125;\n &#125;\n</code></pre>\n<p>ForkJoin的使用代码</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/10    22:05\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n * ForkJoin框架\n * 用到了分治算法\n * 基础回顾：\n * 抽象类被继承\n * 接口被实现\n */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyTask</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RecursiveTask</span>&lt;<span class=\"hljs-title\">Integer</span>&gt; </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Integer ADJUST_VALUE = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> begin;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> end;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> result;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MyTask</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> begin, <span class=\"hljs-keyword\">int</span> end)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.begin = begin;\n        <span class=\"hljs-keyword\">this</span>.end = end;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Integer <span class=\"hljs-title\">compute</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;\n            <span class=\"hljs-comment\">// 当数值差小于等于10的时候就直接进行累加</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = begin; i &lt;= end; i++) &#123;\n                result += i;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-keyword\">int</span> middle = (begin + end) / <span class=\"hljs-number\">2</span>;\n            <span class=\"hljs-comment\">// 这里是递归</span>\n            <span class=\"hljs-comment\">// 第一个任务从begin加到中间</span>\n            MyTask task01 = <span class=\"hljs-keyword\">new</span> MyTask(begin, middle);\n            <span class=\"hljs-comment\">// 第二个任务从中间加到最末尾</span>\n            MyTask task02 = <span class=\"hljs-keyword\">new</span> MyTask(middle + <span class=\"hljs-number\">1</span>, end);\n            <span class=\"hljs-comment\">// 回来调用compute</span>\n            task01.fork();\n            task02.fork();\n            <span class=\"hljs-comment\">// 当 is done返回计算结果。</span>\n            result = task01.join() + task02.join();\n        &#125;\n        <span class=\"hljs-keyword\">return</span> result;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ForkJoinDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        <span class=\"hljs-comment\">// 创建forkjoin池</span>\n        ForkJoinPool forkJoinPool = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            MyTask myTask = <span class=\"hljs-keyword\">new</span> MyTask(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>);\n\n            forkJoinPool = <span class=\"hljs-keyword\">new</span> ForkJoinPool();\n\n            <span class=\"hljs-comment\">// 计算任务</span>\n            ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(myTask);\n            <span class=\"hljs-comment\">// 获取计算的结果</span>\n            Integer integer = task.get();\n            System.out.println(<span class=\"hljs-string\">\"integer = \"</span> + integer);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n            <span class=\"hljs-keyword\">if</span> (forkJoinPool != <span class=\"hljs-keyword\">null</span>) &#123;\n                forkJoinPool.shutdown();\n            &#125;\n        &#125;\n\n    &#125;\n\n&#125;\n</code></pre>\n<h1 id=\"异步回调completablefuture\"><a class=\"markdownIt-Anchor\" href=\"#异步回调completablefuture\"></a> 异步回调CompletableFuture</h1>\n<h2 id=\"completablefuture\"><a class=\"markdownIt-Anchor\" href=\"#completablefuture\"></a> CompletableFuture</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173016.png\" alt=\"image-20220111145007736\" /></p>\n<p>这一段，听得挺迷的，有点类似于ajax的异步请求</p>\n<pre class=\"highlight\"><code class=\"java\"><span class=\"hljs-comment\">/**\n * Created with IntelliJ IDEA.\n * <span class=\"hljs-doctag\">@Author</span>: pzx\n * <span class=\"hljs-doctag\">@Date</span>: 2022/01/10    22:47\n * <span class=\"hljs-doctag\">@Version</span>:1.0\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CompletableFutureDemo</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;\n        <span class=\"hljs-comment\">// 没有返回值的</span>\n        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t没有返回值\"</span>);\n        &#125;);\n        completableFuture.get();\n\n\n        <span class=\"hljs-comment\">// 异步回调，有返回值supplyAsync供给型函数式接口</span>\n        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + <span class=\"hljs-string\">\"\\t completableFuture2\"</span>);\n<span class=\"hljs-comment\">//            return 10 / 0;</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1024</span>;\n        &#125;);\n        <span class=\"hljs-comment\">//  whenComplete方法返回一个新的CompletableFuture，当CompletableFuture完成时完成，</span>\n        <span class=\"hljs-comment\">//  whenComplete(</span>\n        <span class=\"hljs-comment\">//        BiConsumer&lt;? super T, ? super Throwable&gt; action)</span>\n        Integer result = completableFuture2.whenComplete((a, b) -&gt; &#123;\n            <span class=\"hljs-comment\">// 不出异常就走这一步</span>\n            System.out.println(<span class=\"hljs-string\">\"a = \"</span> + a);\n            <span class=\"hljs-comment\">// 这里为null就表示没有异常</span>\n            System.out.println(<span class=\"hljs-string\">\"b = \"</span> + b);\n            <span class=\"hljs-comment\">//结果是异常触发此CompletableFuture的完成特殊功能的给定功能;</span>\n            <span class=\"hljs-comment\">// 否则，如果此CompletableFuture正常完成，则返回的CompletableFuture也会以相同的值正常完成。</span>\n        &#125;).exceptionally(f -&gt; &#123;\n            <span class=\"hljs-comment\">//  CompletableFuture&lt;T&gt; exceptionally(</span>\n            <span class=\"hljs-comment\">//        Function&lt;Throwable, ? extends T&gt; fn)</span>\n\n            <span class=\"hljs-comment\">// 这个是当出现异常的时候就会走这一步</span>\n            System.out.println(f.getMessage());\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">444</span>;\n        &#125;).get();\n\n        System.out.println(result);\n\n    &#125;\n\n&#125;\n\n</code></pre>\n","categories":["juc"],"tags":["JUC"]}]