<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"losserlong.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="juc并发编程juc简介java.util .concurrent，Java并发包  笔试题目 手写单例模式 手写冒泡排序 生产者消费者变种题目  进程&#x2F;线程回顾进程&#x2F;线程是什么？进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。（简单来说，进程就是后台运行的一个程序） 线程：  通">
<meta property="og:type" content="article">
<meta property="og:title" content="newpapername">
<meta property="og:url" content="https://losserlong.github.io/2022/01/16/juc/index.html">
<meta property="og:site_name" content="Xiang&#39;s Blog">
<meta property="og:description" content="juc并发编程juc简介java.util .concurrent，Java并发包  笔试题目 手写单例模式 手写冒泡排序 生产者消费者变种题目  进程&#x2F;线程回顾进程&#x2F;线程是什么？进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。（简单来说，进程就是后台运行的一个程序） 线程：  通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172801.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172814.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172819.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172832.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172836.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172842.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172853.png">
<meta property="og:image" content="c:/Users/losser/AppData/Roaming/Typora/typora-user-images/image-20220108213632391.png">
<meta property="og:image" content="c:/Users/losser/AppData/Roaming/Typora/typora-user-images/image-20220107131432435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172859.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172920.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172926.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172930.png">
<meta property="og:image" content="c:/Users/losser/AppData/Roaming/Typora/typora-user-images/image-20220109181909648.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172935.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172938.png">
<meta property="og:image" content="c:/Users/losser/AppData/Roaming/Typora/typora-user-images/image-20220109195333905.png">
<meta property="og:image" content="c:/Users/losser/AppData/Roaming/Typora/typora-user-images/image-20220109201025539.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172949.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172952.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172954.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173002.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173004.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173010.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173012.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173016.png">
<meta property="article:published_time" content="2022-01-16T10:36:04.000Z">
<meta property="article:modified_time" content="2022-01-18T09:30:18.714Z">
<meta property="article:author" content="Xiang">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172801.png">

<link rel="canonical" href="https://losserlong.github.io/2022/01/16/juc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>newpapername | Xiang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xiang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">与买桂花重载酒，终不似，少年游</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://losserlong.github.io/2022/01/16/juc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xiang">
      <meta itemprop="description" content="Stay Hungry,Stay Foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          newpapername
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-16 18:36:04" itemprop="dateCreated datePublished" datetime="2022-01-16T18:36:04+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 17:30:18" itemprop="dateModified" datetime="2022-01-18T17:30:18+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="juc并发编程"><a href="#juc并发编程" class="headerlink" title="juc并发编程"></a>juc并发编程</h1><h2 id="juc简介"><a href="#juc简介" class="headerlink" title="juc简介"></a>juc简介</h2><p>java.util .concurrent，Java并发包</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172801.png" alt="image-20220103094918335"></p>
<h2 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h2><ol>
<li>手写单例模式</li>
<li>手写冒泡排序</li>
<li>生产者消费者变种题目</li>
</ol>
<h2 id="进程-线程回顾"><a href="#进程-线程回顾" class="headerlink" title="进程/线程回顾"></a>进程/线程回顾</h2><h3 id="进程-线程是什么？"><a href="#进程-线程是什么？" class="headerlink" title="进程/线程是什么？"></a>进程/线程是什么？</h3><p><strong>进程：</strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。（<strong>简单来说，进程就是后台运行的一个程序</strong>）</p>
<p><strong>线程：</strong>  <strong>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程</strong>，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把<strong>线程作为独立运行和独立调度的基本单位</strong>，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h3 id="进程-线程例子？"><a href="#进程-线程例子？" class="headerlink" title="进程/线程例子？"></a>进程/线程例子？</h3><p> 使用QQ，查看进程一定有一个QQ.exe的<strong>进程</strong>，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>
<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>
<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个<strong>线程</strong>：容灾备份，语法检查</p>
<h3 id="什么是并发？什么是并行？"><a href="#什么是并发？什么是并行？" class="headerlink" title="什么是并发？什么是并行？"></a>什么是并发？什么是并行？</h3><p><strong>并发：</strong>同一时刻多个线程在访问<strong>同一个资源</strong>，多个线程对一个点<br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br>**并行： ** <strong>多项工作一起执行</strong>，之后再汇总<br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172810.png" alt="image-20220114130053636"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172814.png" alt="image-20220103110849404"></p>
<h2 id="thread-start"><a href="#thread-start" class="headerlink" title="thread.start"></a>thread.start</h2><p>thread.start表示线程进入<strong>就绪状态</strong>（不是立刻进行调用），是在调用run方法是在cup和操作系统对这个<strong>线程进行调度</strong>的时候。</p>
<h2 id="Thread的状态"><a href="#Thread的状态" class="headerlink" title="Thread的状态"></a>Thread的状态</h2><p>waite()和sleep()的比较，wait放开去睡，放开了手里的锁。</p>
<p>sleep()捏紧了手去睡，醒了还有手里的锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172819.png" alt="image-20220103164224117"></p>
<pre><code>/**
 * Thread state for a thread which has not yet started.
 */
NEW,
</code></pre>
<pre><code>/**
 * Thread state for a runnable thread.  A thread in the runnable
 * state is executing in the Java virtual machine but it may
 * be waiting for other resources from the operating system
 * such as processor.
 */
RUNNABLE,
</code></pre>
<pre><code>/**
 * Thread state for a thread blocked waiting for a monitor lock.
 * A thread in the blocked state is waiting for a monitor lock
 * to enter a synchronized block/method or
 * reenter a synchronized block/method after calling
 * &#123;@link Object#wait() Object.wait&#125;.
 */
BLOCKED,
</code></pre>
<h3 id="WAITING和TIMED-WAITING的区别"><a href="#WAITING和TIMED-WAITING的区别" class="headerlink" title="WAITING和TIMED_WAITING的区别"></a>WAITING和TIMED_WAITING的区别</h3><p>WAITING这个是一直等，死死的等，俗称不见不散</p>
<pre><code class="java">等待线程的线程状态。

由于调用了一个

以下方法：

/**
 * Thread state for a waiting thread.
 * A thread is in the waiting state due to calling one of the
 * following methods:
 * &lt;ul&gt;
 *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;
 *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;
 *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;A thread in the waiting state is waiting for another thread to
 * perform a particular action.
 *
 * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
 * on an object is waiting for another thread to call
 * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
 * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
 * is waiting for a specified thread to terminate.
 */
WAITING,
</code></pre>
<p>TIMED_WAITING是定时等待，俗称过时不候</p>
<pre><code class="java">具有指定等待时间的等待线程的线程状态。

由于调用其中一个线程，线程处于定时等待状态

具有指定正等待时间的以下方法：

/**
 * Thread state for a waiting thread with a specified waiting time.
 * A thread is in the timed waiting state due to calling one of
 * the following methods with a specified positive waiting time:
 * &lt;ul&gt;
 *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;
 *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;
 *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;
 *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;
 *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;
 * &lt;/ul&gt;
 */
TIMED_WAITING,
</code></pre>
<h2 id="经典卖票问题"><a href="#经典卖票问题" class="headerlink" title="经典卖票问题"></a>经典卖票问题</h2><p>一般多线程问题可以简化为：线程        操作（资源类暴露的方法）        资源类</p>
<h3 id="版本1使用匿名内部类"><a href="#版本1使用匿名内部类" class="headerlink" title="版本1使用匿名内部类"></a>版本1使用匿名内部类</h3><p><strong>资源类</strong>：这里也可以使用同步方法或者同步代码块（但是粒度太大）</p>
<p>这里使用的Lock的实现类ReentrantLock()可重入锁，相比synchronized同步锁来说更加灵活，</p>
<pre><code class="java">/**
 * 资源类：票
 */
class Ticket1 &#123;

    // 设定初始值为30张
    private int number = 30;

    // ReentrantLock可重入锁
    private Lock lock = new ReentrantLock();

    /**
     * 操作,这里使用synchronized就相当于把这个saleTicket全部都锁住了，粒度太大
     */
    public void saleTicket() &#123;


        // 上锁
        lock.lock();
        try &#123;
            // 先判断number是否大于0
            if (number &gt; 0) &#123;
                System.out.println(&quot;ThreadName = &quot; + Thread.currentThread().getName() + &quot;\t卖出第：&quot; + (number--) + &quot;\t还剩下&quot; + number);
            &#125; else &#123;
                System.out.println(&quot;票已经卖完&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 释放锁
            lock.unlock();
        &#125;


    &#125;


&#125;
</code></pre>
<p><strong>抢票类</strong></p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/03    10:10
 * @Version:1.0
 *
 * 题目：三个售票员     卖出      30张票
 *多线程编程的企业套路+模板
 *
 * 1.在高内聚低耦合的前提下：线程         操作（资源类对外暴露的调用方法）          资源类
 *
 *抢票类
 *
 */
public class SaleTicket &#123;

    public static void main(String[] args) &#123;  // main程序一切入口




        // 创建两个线程t1，t2
//        Thread t1 = new Thread();
//        Thread t2 = new Thread();

        //Thread(Runnable target, String name)
//        // 启动线程
//        t1.start();
//        t2.start();


        // 下面三个线程(A、B、C)操作同一个资源类
        Ticket1 ticket = new Ticket1();
        // 匿名内部类

        new Thread(new Runnable() &#123;

            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 40; i++) &#123;
                    ticket.saleTicket();
                &#125;
            &#125;
        &#125;, &quot;A&quot;);


        new Thread(new Runnable() &#123;

            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 40; i++) &#123;
                    ticket.saleTicket();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();


        new Thread(new Runnable() &#123;

            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 40; i++) &#123;
                    ticket.saleTicket();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();


    &#125;


&#125;
</code></pre>
<h3 id="版本二使用lambda表达式"><a href="#版本二使用lambda表达式" class="headerlink" title="版本二使用lambda表达式"></a>版本二使用lambda表达式</h3><p>Lambda Express 使用的场景：当一个接口中只有一个抽象方法，其他的默认方法有几个无所谓。</p>
<p>Lambda Express表达式的小口诀： <strong>拷贝小括号（小括号是接口中的方法），写死右箭头，落地大括号。</strong></p>
<p>@FunctionalInterface注解声明式函数式接口，其实可以不用加，在底层默认给加上了</p>
<p>Foo接口</p>
<pre><code>/**
 * 有且只有一个抽象方法的接口称为“函数式接口”
 */
@FunctionalInterface
interface Foo &#123;
//    public void sayHello();

    int add(int a, int b);


    default int div(int a, int b) &#123;
        return a / b;
    &#125;

    /**
     * 静态方法实现
     * @param a
     * @param b
     * @return
     */
    static int mv(int a, int b) &#123;

        return a * b;
    &#125;


&#125;
</code></pre>
<p>使用Foo接口中的Lambda表达式</p>
<pre><code class="java">public class LambdaExpressDemo &#123;

    public static void main(String[] args) &#123;


    /*        Foo foo = new Foo() &#123;
            @Override
            public void sayHello() &#123;
                System.out.println(&quot;*******************hello java 2022&quot;);
            &#125;
        &#125;;*/

/*
        Foo foo = () -&gt; &#123;
            System.out.println(&quot;*******************hello java lambda&quot;);

        &#125;;


        foo.sayHello();
*/

        // 可以把方法的参数类型省略
        Foo foo = (a, b) -&gt; &#123;

            System.out.println(&quot;a+b = &quot; + a + b);

            return a + b;
        &#125;;

        foo.add(1234, 45);

        System.out.println(foo.div(10, 2));

        System.out.println(Foo.mv(5, 3));


    &#125;


&#125;
</code></pre>
<h2 id="线程交互问题：笔试题目之交替打印0和1"><a href="#线程交互问题：笔试题目之交替打印0和1" class="headerlink" title="线程交互问题：笔试题目之交替打印0和1"></a>线程交互问题：笔试题目之交替打印0和1</h2><p>这个就是<strong>生产者和消费者模型。</strong></p>
<p>笔试题目：<br>题目:现在两个线程，可以操作初始值为零的一个变量,<br>实现一个线程对该变量加，一个线程对该变量减i，<br>实现交替，来10轮，变量初始值为零。</p>
<h3 id="两个线程交替打印1-0版"><a href="#两个线程交替打印1-0版" class="headerlink" title="两个线程交替打印1.0版"></a>两个线程交替打印1.0版</h3><p>这里有一个坑，但是两个线程的时候不会出现，当线程多的时候就会出现。这里的判断条件不能用if，只能用while。</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/03    18:29
 * @Version:1.0
 * 笔试题目：
 * 题目:现在两个线程，可以操作初始值为零的一个变量,
 * 实现一个线程对该变量加，一个线程对该变量减i，
 * 实现交替，来10轮，变量初始值为零。
 *
 *
 * // 1.高内聚低耦合的前提下，线程       操作      资源类
 *    2.   判断/干活/通知
 *
 * 生产者消费者复习
 *
 *
 *
 */
public class ThreadWaitNotifyDemo &#123;

    public static void main(String[] args) &#123;

        AirCondition airCondition = new AirCondition();


        /**
         * 生产蛋糕，做加法
         */
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    airCondition.increment();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;
        &#125;, &quot;A&quot;).start();


        /**
         * 消费蛋糕，做减法
         */
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    airCondition.decrement();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();


    &#125;
&#125;

/**
 * 资源类
 *  1.0版
 */
class AirCondition &#123;
    private int number = 0;


    /**
     * 对number进行加1
     * 这里有三步，
     * 1、判断number的值是否为0
     * 2、做加法
     * 3、通知消费者来吃蛋糕
     *
     * 生产者线程
     *
     */
    public synchronized void increment() throws InterruptedException &#123;


        // 1.判断
        if (number != 0) &#123;
            this.wait();
        &#125;

        // 2.干活
        number++;

        System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + number);

        // 3.通知(唤醒等待的线程)
        this.notifyAll();


    &#125;


    /**
     * 对number进行减1
     * synchronized加上同步锁
     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待
     * 消费者线程
     *
     *
     */
    public synchronized void decrement() throws InterruptedException &#123;


        // 1.判断，等于0，没有蛋糕，就得先等
        if (number == 0) &#123;
            this.wait();
        &#125;

        // 2.干活
        number--;

        System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + number);

        // 3.通知(唤醒等待的线程)
        this.notifyAll();


    &#125;

&#125;
</code></pre>
<h3 id="两个线程交替打印2-0版（变成四个线程）"><a href="#两个线程交替打印2-0版（变成四个线程）" class="headerlink" title="两个线程交替打印2.0版（变成四个线程）"></a>两个线程交替打印2.0版（变成四个线程）</h3><p>这里升级为四个线程进行操作，一个加一个减，一个加一个减</p>
<p>/*        if (number != 0) {</p>
<pre><code class="java">        //  A可能没有执行下面的wait的时候，线程调度的时候就停止了，
        //  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)
        // 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了
        this.wait();
    &#125;*/
</code></pre>
<pre><code class="java">public class ThreadWaitNotifyDemo2 &#123;

    public static void main(String[] args) &#123;
        AirCondition1 ac1 = new AirCondition1();

        // 消费者线程A
        new Thread(() -&gt; &#123;

            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    Thread.sleep(200);
                    ac1.increment();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();


        // 消费者线程B
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    Thread.sleep(400);
                    ac1.decrement();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();


        // 消费者线程C
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    Thread.sleep(500);
                    ac1.increment();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();


        // 消费者线程D
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                try &#123;
                    ac1.decrement();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;D&quot;).start();


    &#125;


&#125;


/**
 * 资源类
 * 2.0版
 */
class AirCondition1 &#123;
    private int number = 0;


    /**
     * 对number进行加1
     * 这里有三步，
     * 1、判断number的值是否为0
     * 2、做加法
     * 3、通知消费者来吃蛋糕
     *
     * 生产者线程
     *
     */
    public synchronized void increment() throws InterruptedException &#123;


        /**
         * sleep不会释放线程的所有权(锁)而wait会，所以下面配合synchronized使用
         *
         * 这个式调用无参的wait
         * 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。
         * 换句话说，这个方法的行为就好像简单地执行呼叫wait(0) 。
         *
         *
         * wait()
         * 当前的线程必须拥有该对象的显示器。 线程释放此监视器的所有权(锁)，并等待直到发生以下两种情况之一：
         *
         * 另一个线程通知等待该对象的监视器的线程通过调用notify方法或notifyAll方法来唤醒。
         * 由timeout毫秒加nanos纳秒参数指定的超时时间已过。
         *
         *
         *
         * 像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用：
         *
         *   synchronized (obj) &#123;
         *          while (&lt;condition does not hold&gt;)
         *              obj.wait(timeout, nanos);
         *          ... // Perform action appropriate to condition
         *      &#125;
         *
         *
         */
        // 1.判断


        // 注意这里不能用if进行判断，如果使用if的话会出现虚假唤醒，因为if只判断一次（这个是最主要原因）
/*        if (number != 0) &#123;

            //  A可能没有执行下面的wait的时候，线程调度的时候就停止了，
            //  但是他苏醒过来了之后，没有进行判断，因为number可能已经加成1了(下面的消费者也一样)
            // 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了
            this.wait();
        &#125;*/


        // 1.判断
        while (number != 0) &#123;
            // 一直等待进入阻塞状态，当有其他线程notify()或者notifyAll()就被唤醒了
            this.wait();
        &#125;


        // 2.干活
        number++;

        System.out.println(Thread.currentThread().getName() + &quot;生产了数据:&quot; + number);

        // 3.通知(唤醒等待的线程)
        this.notifyAll();


    &#125;


    /**
     * 对number进行减1
     * synchronized加上同步锁
     * 就相当于，消费者去买蛋糕，如果没有蛋糕，就先得等待
     * 消费者线程
     *
     *
     */
    public synchronized void decrement() throws InterruptedException &#123;


        // 1.判断，等于0，没有蛋糕，就得先等
        while (number == 0) &#123;
            this.wait();
        &#125;


        // 2.干活
        number--;

        System.out.println(Thread.currentThread().getName() + &quot;消费了数据:&quot; + number);

        // 3.通知(唤醒等待的线程)
        this.notifyAll();


    &#125;

&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172832.png" alt="image-20220104161856205"></p>
<h3 id="改编题目"><a href="#改编题目" class="headerlink" title="改编题目"></a>改编题目</h3><p>题目内容</p>
<pre><code>多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下:
AA打印5次，BB打10次，CC打印15次接着  (这里又线程之间的通信,这里是精确通知)
AA打印5次，BB打印10次，CC打印15次
</code></pre>
<p>由于这里是三个线程进行打印而且还有顺序，通过使用标志位加Condition接口中的signal();实现精准通知。当A线程进入执行完打印操作之后，将标志位进行改变，就精准通知B线程。同理B完成之后通知C，C然后再通知A实现A-&gt;B-&gt;C（其实都是number标志位起了作用）</p>
<p><strong>资源类的代码如下</strong></p>
<ul>
<li>第一种使用Lock锁</li>
</ul>
<pre><code class="java">/**
 * 资源类
 * 作业：将三个方法合并成一个方法
 */
class ShareResource &#123;
    // 1:A  2:B   3:C   标志位1对于A,2对应B,3对应C
    private int number = 1;    // 设定标志位的初始值为1
    // lock就相当于锁，而下面的condition就相当于钥匙，一把锁配三把钥匙
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    /**
     * 打印五次
     */
    public void print5() &#123;

        lock.lock();
        try &#123;

            // 1.判断
            while (number != 1) &#123;
                // 进行等待
                condition1.await();
            &#125;

            // 2.干活
            for (int i = 1; i &lt;= 5; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:\t&quot; + i);
            &#125;

            // 3.通知
            // 将标志位进行更改
            number = 2;

            // 这里精准唤醒2线程
            // 唤醒condition2锁了的线程（唤醒2线程）
            condition2.signal();


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    /**
     * 打印十次
     */
    public void print10() &#123;

        lock.lock();

        try &#123;

            // 1.判断
            while (number != 2) &#123;
                // 进行等待
                condition2.await();
            &#125;

            // 2.干活
            for (int i = 1; i &lt;= 10; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:\t&quot; + i);
            &#125;

            // 3.通知
            // 将标志位进行更改
            number = 3;
            // 唤醒等待的线程 （唤醒3线程）
            condition3.signal();


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    /**
     * 打印十五次
     */
    public void print15() &#123;

        lock.lock();

        try &#123;

            // 1.判断
            while (number != 3) &#123;
                // 进行等待
                condition3.await();
            &#125;

            // 2.干活
            for (int i = 1; i &lt;= 15; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:\t&quot; + i);
            &#125;

            // 3.通知
            // 将标志位进行更改
            number = 1;
            // 唤醒等待的线程（唤醒1线程）
            condition1.signal();


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>第二种使用同步方法</li>
</ul>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/07    9:15
 * @Version:1.0
 * 也可以用synchronized同步方法和wait和notifyAll，其实就是number标志位起了作用
 *
 */
class AirCondition3&#123;

    // 1代表A ，   2代表B    3代表C
    private int number = 1;


    public synchronized void print5s() &#123;

        // 判断
        while (number != 1) &#123;
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        for (int i = 1; i &lt;= 5; i++) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + i);
        &#125;
        number = 2;
        notifyAll();
    &#125;

    public synchronized void print10s() &#123;

        // 判断
        while (number != 2) &#123;
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        for (int i = 1; i &lt;= 10; i++) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + i);
        &#125;
        number = 3;
        notifyAll();
    &#125;

    public synchronized void print15s() &#123;

        // 判断
        while (number != 3) &#123;
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        for (int i = 1; i &lt;= 15; i++) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + i);
        &#125;
        number = 1;
        notifyAll();
    &#125;


&#125;
public class ThreadWaitNotifyDemo1 &#123;

    public static void main(String[] args) &#123;
        AirCondition3 airCondition2 = new AirCondition3();
        new Thread(() -&gt; &#123;
            for (int i = 1; i &lt;= 5; i++) &#123;
                airCondition2.print5s();
            &#125;
        &#125;, &quot;线程A&quot;).start();
        new Thread(() -&gt; &#123;
            for (int i = 1; i &lt;= 10; i++) &#123;
                airCondition2.print10s();
            &#125;
        &#125;, &quot;线程B&quot;).start();
        new Thread(() -&gt; &#123;
            for (int i = 1; i &lt;= 15; i++) &#123;
                airCondition2.print15s();
            &#125;
        &#125;, &quot;线程C&quot;).start();
    &#125;


&#125;

</code></pre>
<h2 id="使用lock替换synchronized"><a href="#使用lock替换synchronized" class="headerlink" title="使用lock替换synchronized"></a>使用lock替换<strong>synchronized</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172836.png" alt="image-20220104163122288"></p>
<p>将synchronized同步方法换成Lock锁，Lock更加灵活，<strong>synchronized使用的是Object类中wait和notify/notifyAll。</strong>而在Lock中<code>Lock</code>实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。  它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象<code>Condition</code>。</p>
<p><code>Condition</code>因素出<code>Object</code>监视器方法（ <a href="../../../../java/lang/Object.html#wait--"><code>wait</code></a> ， <a href="../../../../java/lang/Object.html#notify--"><code>notify</code></a>和<a href="../../../../java/lang/Object.html#notifyAll--"><code>notifyAll</code></a>  ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果<code>Lock</code>实现。 <code>Lock</code>替换<code>synchronized</code>方法和语句的使用，  <code>Condition</code>取代了对象监视器方法的使用。 <code>Condition</code>使用的是<code>await()</code> 和<code>signal()</code> /<code>signalAll()</code>对应Object类的<strong>wait和notify/notifyAll。</strong></p>
<p><strong>资源类和操作类的代码。</strong></p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/04    16:49
 * @Version:1.0
 *
 * 将锁换成Lock
 * 1.高内聚低耦合的前提下，线程       操作      资源类
 * 2.   判断/干活/通知
 * 3.   多线程交互的过程中，必须要防止多线程的虚假唤醒，也即(判断使用while，不能用if)
 * (在方法的判断中不许用if，只能用while)
 * 4.   注意标志位的修改和定位
 *
 */
public class ThreadWaitNotifyDemo2 &#123;
    public static void main(String[] args) &#123;
        AirCondition2 airCondition2 = new AirCondition2();
        new Thread(()-&gt;&#123;
            for (int i = 0; i &lt;10 ; i++) &#123;
                try &#123;
                    airCondition2.increase();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;线程A&quot;).start();

            new Thread(()-&gt;&#123;
            for (int i = 0; i &lt;10 ; i++) &#123;
                try &#123;
                    airCondition2.decrease();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;线程B&quot;).start();
            new Thread(()-&gt;&#123;
            for (int i = 0; i &lt;10 ; i++) &#123;
                try &#123;
                    airCondition2.increase();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;线程C&quot;).start();
            new Thread(()-&gt;&#123;
            for (int i = 0; i &lt;10 ; i++) &#123;
                try &#123;
                    airCondition2.decrease();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;线程D&quot;).start();
    &#125;
&#125;

class AirCondition2 &#123;

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    private int number = 0;


    // 生产者对number的值进行加1
    public void increase() throws InterruptedException &#123;

        // 对资源进行上锁
        lock.lock();

        try &#123;
            // 1.判断
            while (number != 0) &#123;
            //    this.wait();
                condition.await();
            &#125;

            // 2.干活
            ++number;
            System.out.println(Thread.currentThread().getName() + &quot;生产了&quot; +&quot;\t&quot;+ number);
            // 通知
//            this.notify();
            condition.signalAll();

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 对资源进行释放锁
            lock.unlock();
        &#125;


    &#125;


    // 生产者对number的值进行减1
    public void decrease() throws InterruptedException &#123;

        // 对资源进行上锁
        lock.lock();

        try &#123;
            // 1.判断
            while (number == 0) &#123;
                //    this.wait();
                condition.await();
            &#125;

            // 2.干活
            number--;
            System.out.println(Thread.currentThread().getName() + &quot;消费了&quot; +&quot;\t&quot;+ number);
            // 通知
//            this.notify();
            condition.signalAll();

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 对资源进行释放锁
            lock.unlock();
        &#125;

&#125;
    &#125;
</code></pre>
<h2 id="多线程8锁"><a href="#多线程8锁" class="headerlink" title="多线程8锁"></a>多线程8锁</h2><pre><code class="text">题目：多线程8锁
    其实下面就是看synchronized锁的是什么对象
    普通同步方法锁的就是this这个当前对象，而不是锁住这个单独的synchronized方法，也就是说同一时间段，只能有一个线程进入当前类，访问一个synchronized方法
    静态同步方法锁的就是类.Class这个对象也就是类对象，同时去复习一下static关键字
    普通方法没有加synchronized就不会上锁
    对于同步方法块，锁是Synchonized括号里配置的对象
</code></pre>
<pre><code>A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，
其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法
锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法
 
加个普通方法后发现和同步锁无关
换成两个对象后，不是同一把锁了，情况立刻变化。
 
 
synchronized实现同步的基础：Java中的每一个对象都可以作为锁。
具体表现为以下3种形式。
对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchonized括号里配置的对象
 
当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
 
也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，
可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，
所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。
 
所有的静态同步方法用的也是同一把锁——类对象本身，
这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。
但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，
而不管是同一个实例对象的静态同步方法之间，
还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！
 
 
 
</code></pre>
<ul>
<li>1、标准访问，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>2、 停4秒在短信方法内，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>3 、普通的hello方法，是先打短信还是hello</li>
</ul>
<p><code>hello</code></p>
<ul>
<li>4 、现在有两部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<ul>
<li>5 、两个静态同步方法，1部手机，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>6 、两个静态同步方法，2部手机，先打印短信还是邮件</li>
</ul>
<p><code>邮件</code></p>
<ul>
<li>7 、1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<ul>
<li>8 、1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</li>
</ul>
<p><code>短信</code></p>
<pre><code class="java">public class Lock8 &#123;
    public static void main(String[] args) throws InterruptedException &#123;


        Phone phone = new Phone();
        Phone phone2 = new Phone();
        new Thread(() -&gt; &#123;
            phone.sendEmail();
        &#125;, &quot;线程A&quot;).start();

        // 由于这里线程睡了0.2秒钟，线程A就已经完成启动和调度了
        Thread.sleep(200);

        new Thread(() -&gt; &#123;
//                phone.sendMsg();


            phone2.sendMsg();
//            phone.hello();
        &#125;, &quot;线程B&quot;).start();


    &#125;


&#125;

class Phone &#123;


    /**
     * 发送邮件的方法
     */
    public static synchronized void sendEmail() &#123;
        try &#123;
            // 线程睡四秒钟
            TimeUnit.SECONDS.sleep(4);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot;---------------sendEmail&quot;);
    &#125;


    /**
     * 发送短信方法
     */
    public  static synchronized void sendMsg() &#123;
        System.out.println(Thread.currentThread().getName() + &quot;---------------sendMsg&quot;);
    &#125;


    /**
     * 普通方法，没有加锁，就不用争抢锁资源
     */
    public void hello() &#123;
        System.out.println(Thread.currentThread().getName() + &quot;-------------------------hello&quot;);
    &#125;

&#125;
</code></pre>
<h2 id="交替打印100以内的奇数和偶数"><a href="#交替打印100以内的奇数和偶数" class="headerlink" title="交替打印100以内的奇数和偶数"></a>交替打印100以内的奇数和偶数</h2><p>这里有一个大坑，你要先将另一把锁唤醒之后，然后将自己进入等待状态。不然的话，会出现死锁，连哥哥线程都在等待对方唤醒。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>是指多个进程在运行过程中因争夺资源而造成的一种僵局，</strong>当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程T1，按照先锁R1再获得锁R2的的顺序获得锁，而在此同时又有另外一个线程T2，按照先锁T2再锁T1的顺序获得锁。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172842.png" alt="image-20220106100435845"></p>
<h3 id="第一种使用Lock锁"><a href="#第一种使用Lock锁" class="headerlink" title="第一种使用Lock锁"></a>第一种使用Lock锁</h3><pre><code class="java">public class Test2 &#123;
    public static void main(String[] args) &#123;

        ShareSource1 ss = new ShareSource1();
        new Thread(()-&gt;&#123;ss.print();&#125;,&quot;线程A&quot;).start();
        new Thread(()-&gt;&#123;ss.print();&#125;,&quot;线程B&quot;).start();


    &#125;

&#125;

class ShareSource1 &#123;

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    private int number = 1;

    public void print() &#123;

        // 判断
        lock.lock();
        try &#123;
            while (number &lt;= 100) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + number);
                number++;
                //    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.
                // 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁
//                this.wait();
//                this.notify();
                // 为了避免死锁，得先将进行唤醒，然后再去等待

                condition.signal();
                condition.await();

            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;
</code></pre>
<h3 id="第二种使用synchronized静态代码块"><a href="#第二种使用synchronized静态代码块" class="headerlink" title="第二种使用synchronized静态代码块"></a>第二种使用synchronized静态代码块</h3><p>​    </p>
<pre><code class="java">public class Test3 &#123;
    public static void main(String[] args) &#123;
        ShareSource2 ss2 = new ShareSource2();
        new Thread(() -&gt; &#123;
            try &#123;
                ss2.print();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, &quot;线程A&quot;).start();
        new Thread(() -&gt; &#123;
            try &#123;
                ss2.print();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, &quot;线程B&quot;).start();
    &#125;
&#125;

class ShareSource2 &#123;


    private int number = 1;

    public void print() throws InterruptedException &#123;

        // 判断

        synchronized (this) &#123;
       while (number &lt;= 100) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + number);
                number++;


                //    线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止.
                // 不能先wait，因为假如先wait之后，B再进来也是wait然后他俩就相互等待，就会死锁
//                this.wait();
//                this.notify();
                // 为了避免死锁，得先将进行唤醒，然后再去等待
                this.notify();
                this.wait();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="集合中的一些比较"><a href="#集合中的一些比较" class="headerlink" title="集合中的一些比较"></a>集合中的一些比较</h1><h2 id="请举例说明集合类是不安全的"><a href="#请举例说明集合类是不安全的" class="headerlink" title="请举例说明集合类是不安全的"></a>请举例说明集合类是不安全的</h2><h3 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h3><p>ArrayList、HashMap、HashSet都是线程不安全的</p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();   // Collections.synchronizedList(new ArrayList&lt;String&gt;());


// 出现异常java.util.ConcurrentModificationException
// 多线程条件下，既要读又要写
for (int i = 1; i &lt;= 30; i++) &#123;

    new Thread(() -&gt; &#123;
        list.add(UUID.randomUUID().toString().substring(0, 8));
        System.out.println(Thread.currentThread().getName() + list);
    &#125;, String.valueOf(i)).start();

&#125;
</code></pre>
<ol>
<li><p><strong>故障现象</strong></p>
<p>java.util.ConcurrentModificationException并发修改异常</p>
</li>
<li><p><strong>导致原因</strong><br>多线程条件下，既要读又要写</p>
</li>
<li><p><strong>解决方案</strong></p>
<p>3.1 用Vector,它的底层在add方法加了同步锁<br>3.2 Collections.synchronizedList(new ArrayList<String>());<br>3.3 new CopyOnWriteArrayList&lt;&gt;();    </p>
</li>
<li><p>将代码块抽取成方法的快捷键<strong>Ctrl+Alt+m</strong></p>
</li>
</ol>
<p>ArrayList的add方法</p>
<pre><code class="java">public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
&#125;
</code></pre>
<h3 id="在多线程条件下不使用ArrayList"><a href="#在多线程条件下不使用ArrayList" class="headerlink" title="在多线程条件下不使用ArrayList"></a>在多线程条件下不使用ArrayList</h3><pre><code class="java">   public static void main(String[] args) &#123;

/*        // 将数组转List
        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        // 方法的引用
        list.forEach(System.out ::println);*/

        // 生成当前的时间戳
        //    System.currentTimeMillis();

        // 第一种方法：（线程不安全） new ArrayList&lt;&gt;();
        // 第二种方法（不推荐）   new Vector&lt;&gt;();
        // 第三种：使用Collections.synchronizedList将线程不安全的的List转换成线程安全的
        // 第四种：使用  new CopyOnWriteArrayList&lt;&gt;();


        // HashMap线程不安全使用ConcurrentHashMap

        List&lt;String&gt; list = new ArrayList&lt;&gt;();   // Collections.synchronizedList(new ArrayList&lt;String&gt;());


        // 出现异常java.util.ConcurrentModificationException
        // 多线程条件下，既要读又要写
        for (int i = 1; i &lt;= 30; i++) &#123;

            new Thread(() -&gt; &#123;
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(Thread.currentThread().getName() + list);
            &#125;, String.valueOf(i)).start();

        &#125;



    &#125;
</code></pre>
<h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>多线程条件下，一般使用这个报下面的类，后面的三个都是java.util.concurrent并发包下面的。</p>
<ul>
<li>ArrayList   ——&gt;    CopyOnWriteArrayList</li>
<li>HashSet    ——&gt;    CopyOnWriteArraySet</li>
<li>HashMap   ——&gt;    ConcurrentHashMap</li>
</ul>
<h3 id="回忆集合的基础知识"><a href="#回忆集合的基础知识" class="headerlink" title="回忆集合的基础知识"></a>回忆集合的基础知识</h3><p>HashSet的底层数据结构是HashMap，存的是map的key，它的value是一个写死的Object的常量</p>
<p>HashSet的add方法是调用的HashMap的put方法</p>
<p>HashMap的底层1.8是<strong>Node数组+链表+红黑树，1.7是哈希表</strong></p>
<p>jdk1.8</p>
<p>构造求一个空的HashMap，默认的初始容量是（16），默认的负载因子是（0.75）</p>
<p>HashMap和HashSet都是无序的</p>
<p>无序性：无序性不等于随机性。指的是存储的数据在底层数组中并非按照数组索引的顺序进行添加的，而使根据数值的哈希值决定的。</p>
<p>ArrayList扩容是扩容为原来的1.5倍</p>
<p>HashMap扩容是扩大到原来的两倍，在使用的时候可以将他的初始容量设大，这样就可以避免它反复扩容了。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul>
<li><strong>java.util.concurrent.CopyOnWriteArrayList<E></strong> </li>
</ul>
<p><font color='orange'><strong>写时复制技术原理</strong></font></p>
<p><strong>CopyOnWrite容器即写时复制的容器。</strong>往一个容器添加元素的时候，不直接往当前容器Object[]添加，<br>而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。<br>添加元素后，再将原容器的引用指向新的容器setArray(newElements)。<br>这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<hr>
<p>CopyOnWriteArrayList的原理：简单的来说当A线程去写的时候，先复制一份1.1版的，然后自己用这个1.1版的去写，如果其他的线程要读的时候就去读1.0版本的，当A写完之后再发布1.1版的。<strong>（其实也就是读写分离思想）</strong></p>
<p>CopyOnWriteArrayList是线程安全的，下面是它的add方法的源码，它会先将传入的集合进行复制一份，然后将新的</p>
<pre><code class="java">   /** The array, accessed only via getArray/setArray. */
    private transient volatile Object[] array;

    /**
     * Gets the array.  Non-private so as to also be accessible
     * from CopyOnWriteArraySet class.
     */
    final Object[] getArray() &#123;
        return array;
    &#125;

    /**
     * Sets the array.
     */
    final void setArray(Object[] a) &#123;
        array = a;
    &#125;
   

/**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)
     */
public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        // 这里就是复制一份新的，然后用Object数组进行接收
        Object[] elements = getArray();
        // 获得原来的集合的长度
        int len = elements.length;
        // 对elements数组进行扩容长度加一得到新的newElements
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 将要添加的e，添加到数组的最后
        newElements[len] = e;
        // 再将newElements重新设置回CopyOnWriteArrayList对象中，就是相当于1.1版本的替换1.0版本的 
        setArray(newElements);
        // 添加完成
        return true;
    &#125; finally &#123;
        // 释放锁
        lock.unlock();
    &#125;
&#125;
</code></pre>
<p>HashMap的put方法，put里面其实装的是一个个的Node结点</p>
<pre><code class="java">    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V put(K key, V value) &#123;
        return putVal(hash(key), key, value, false, true);
    &#125;


    /**
     * Implements Map.put and related methods.
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don&#39;t change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        // HashMap的put装的是一个个的Node结点
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123; // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><h2 id="复习获得多线程的方式"><a href="#复习获得多线程的方式" class="headerlink" title="复习获得多线程的方式"></a>复习获得多线程的方式</h2><p>面试题：获得多线程的方法几种？</p>
<ul>
<li>继承Thread类</li>
</ul>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/06    19:39
 * @Version:1.0
 * 实现多线程的方式二继承Thread类，重写run方法
 *
 *
 */
public class ThreadDemo1 &#123;

    public static void main(String[] args) &#123;

        MyThread1 t1 = new MyThread1();

        new Thread(t1,&quot;线程1&quot;).start();
        new Thread(t1,&quot;线程2&quot;).start();

/*
        t1.setName(&quot;线程A&quot;);
        t1.start();
        MyThread1 t2 = new MyThread1();
        t2.setName(&quot;线程B&quot;);
        t2.start();*/

    &#125;


&#125;

class MyThread1 extends Thread &#123;
    private static int ticket = 100;


    @Override
    public void run() &#123;
        synchronized (this) &#123;
            while (true) &#123;
                if (ticket &gt; 0) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;\t\t&quot; + ticket);
                    ticket--;
                &#125; else &#123;
                    break;
                &#125;

            &#125;

        &#125;

    &#125;
&#125;
</code></pre>
<ul>
<li>实现Runnable接口</li>
</ul>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/06    19:35
 * @Version:1.0
 * 实现多线程的方式一
 * 实现Runnable接口
 */
class MyThread implements Runnable &#123;
    private int number = 100;

    @Override
    public  void run() &#123;

        synchronized (this) &#123;
            while (true) &#123;
                if (number&gt;0)&#123;
                    System.out.println(Thread.currentThread().getName() +&quot;\t\t&quot;+ number);
                    number--;
                &#125;else&#123;
                    break;
                &#125;

            &#125;
        &#125;


    &#125;
&#125;




public class ThreadDemo &#123;
    public static void main(String[] args) &#123;

        MyThread myThread = new MyThread();
        new Thread(myThread,&quot;线程A&quot;).start();
        new Thread(myThread,&quot;线程B&quot;).start();

    &#125;


&#125;
</code></pre>
<h2 id="Callable的简单使用"><a href="#Callable的简单使用" class="headerlink" title="Callable的简单使用"></a>Callable的简单使用</h2><ul>
<li>实现Callable接口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172853.png" alt="image-20220108212709371"></p>
<p><strong>实现多线程的方式三之实现Callable接口</strong>，之前两种太简单了就不写了</p>
<p><strong>get方法</strong>一般请放在最后一行,因为如果实现的Callable类中有阻塞的话，它会等它执行完才会执行下面的</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/06    20:11
 * @Version:1.0
 *
 * 选中那个接口，然后使用Ctrl+Alt+U查看这个类或者接口的类图
 * get方法一般请放在最后一行,因为如果实现的Callable类中有阻塞的话
 * 它会等它执行完才会执行下面的
 *在·
 */

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

/**
 * 多线程实现方法三实现Callable接口
 */
class MyThread2 implements Callable&lt;Integer&gt; &#123;

    @Override
    public Integer call() throws Exception &#123;
        System.out.println(Thread.currentThread().getName()+&quot;\t\t  hello world&quot;);
        TimeUnit.SECONDS.sleep(4);
        return 1024;
    &#125;
&#125;

public class CallableDemo &#123;

    public static void main(String[] args) throws Exception &#123;

        // Interface RunnableFuture&lt;V&gt; 是Runnable的子接口 。FutureTask实现了RunnableFuture接口、
        // FutureTask的一个构造方法   FutureTask(Callable&lt;V&gt; callable)
        // Thread(Runnable target, String name) ， 在Thread的构造器中只要传入Runnable或者Runnable的子接口或者实现类即可
        // 这里主要是多态的的思想
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MyThread2());
        /**
         * 打印结果
         * hello world
         * 1024
         * main计算完成、
         * 这里只会打印一次hello world，因为它有缓存
         */
        new Thread(futureTask,&quot;线程a&quot;).start();
        new Thread(futureTask,&quot;线程b&quot;).start();
        System.out.println(futureTask.get());
        System.out.println(Thread.currentThread().getName() + &quot;计算完成&quot;);
        
    &#125;

&#125;
</code></pre>
<p> 面试题:callable接口与runnable接口的区别？</p>
<p> 答：（1）是否有返回值<br>       （2）是否抛异常<br>       （3）落地方法不一样，一个是run，一个是call</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>未来的任务，用它就干一件事，异步调用<br>main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p>
<p>  <img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220108213632391.png" alt="image-20220108213632391"></p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，<br>水买回来了放桌上，我需要的时候再去get。<br>（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，<br>FutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果<br>（3）高考：会做的先做，不会的放在后面做</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，<br>就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，<br>然后会返回结果或者抛出异常。 </p>
<p><strong>只计算一次</strong><br><strong>get方法放到最后</strong></p>
<p>FutureTask类图 <img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220107131432435.png" alt="image-20220107131432435"></p>
<h1 id="JUC强大的辅助类讲解"><a href="#JUC强大的辅助类讲解" class="headerlink" title="JUC强大的辅助类讲解"></a>JUC强大的辅助类讲解</h1><h2 id="CountDownLatch-减少计数"><a href="#CountDownLatch-减少计数" class="headerlink" title="CountDownLatch 减少计数"></a>CountDownLatch 减少计数</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>生活中的实例就是晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门，减少计数</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/07    15:19
 * @Version:1.0
 * CountDownLatch
 * 这个类似生活中的例子：晚自习，班长关门，也就是说要等所有的同学出去之后，班长才去关门
 * 减少计数
 */
public class CountDownLatchDemo &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        // 构造一个以给定计数 CountDownLatch CountDownLatch。 java.util.concurrent
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i &lt;= 6; i++) &#123;
            new Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + &quot;离开教室&quot;);
                //countDown() 减少锁存器的计数，如果计数达到零，释放所有等待的线程。
                countDownLatch.countDown();
            &#125;, String.valueOf(i)).start();
        &#125;
        // 导致当前线程等到锁存器计数到零，除非线程是 interrupted,
        // 其实也就是说当里面的count减少到0就不用等待了，唤醒线程
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + &quot;\t班长关闭教室&quot;);
    &#125;
    private static void closeDoor() &#123;
        for (int i = 1; i &lt;= 6; i++) &#123;
            new Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + &quot;离开教室&quot;);
            &#125;, String.valueOf(i)).start();

        &#125;
    System.out.println(Thread.currentThread().getName() + &quot;\t班长关闭教室&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier  循环栅栏"></a>CyclicBarrier  循环栅栏</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><strong>CyclicBarrier</strong> 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞， 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p>
<p>这个可以举一个简单的例子就<strong>是，集齐七颗龙珠召唤神龙，还有就是开会，必须要等到人到齐了才能开会。</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/07    15:55
 * @Version:1.0
 * java.util.concurrent  CyclicBarrier
 * 其实这个有点像生活中的例子：开会，还有七龙珠，集齐七颗龙珠召唤神龙
 * 开会必须等待所有人都到齐了才行
 *
 *
 */
public class CyclicBarrierDemo &#123;

    public static void main(String[] args) &#123;

        CyclicBarrier cb = new CyclicBarrier(7, () -&gt; &#123;
            System.out.println(&quot;召唤神龙&quot;);
        &#125;);

        /**
         * 等待所有parties已经在这个障碍上调用了await 。
         * 如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：
         * 最后一个线程到达; 要么
         * 一些其他线程当前线程为interrupts ; 要么
         * 一些其他线程interrupts其他等待线程之一; 要么
         * 一些其他线程在等待屏障时超时; 要么
         * 其他一些线程在这个屏障上调用reset() 。
         */

        for (int i = 1; i &lt;= 7; i++) &#123;
            int temp = i;
            new Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + &quot;收集到的\t第&quot; + temp + &quot;颗龙珠&quot;);
                try &#123;
                    //等待所有parties已经在这个障碍上调用了await 。
                    //如果当前线程不是最后一个线程，那么它被禁用以进行线程调度，并且处于休眠状态，直到发生下列事情之一：最后一个线程到了
                    // 也就是等到最后一个线程到了，然后就开始执行start，start之后，线程的调度顺序还得看操作系统和cup的调度
                    cb.await();
                    // 执行完成之后，就调用CyclicBarrier(int parties, Runnable barrierAction) 里面的barrierAction线程
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; catch (BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;, &quot;线程\t&quot; + i).start();

        &#125;


    &#125;


&#125;
</code></pre>
<h2 id="Semaphore-信号灯"><a href="#Semaphore-信号灯" class="headerlink" title="Semaphore 信号灯"></a>Semaphore 信号灯</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在信号量上我们定义两种操作：</p>
<p>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</p>
<p> release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</p>
<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<p><strong>这个可以用生活中的抢车位来类比</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/07    16:40
 * @Version:1.0
 * Semaphore这个主要是应用于抢车位
 * 这个主要用于多线程的并发控制和资源的互斥
 *
 *
 */
public class SemaphoreDemo &#123;


    public static void main(String[] args) &#123;




        // 模拟资源类，有三个空车位
        // 当permits设置为1就相当于synchronized了
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i &lt;= 7; i++) &#123;


            new Thread(() -&gt; &#123;
                try &#123;
                    //从此信号量获取许可证，阻止直到可用，否则线程为interrupted 。
                    //获得许可证，如果有可用并立即返回，则将可用许可证数量减少一个。
                    // 这里相当于抢占到车位
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;\t抢到了车位&quot;);
                    // 线程睡4秒钟，模拟停车停了4秒钟
                    TimeUnit.SECONDS.sleep(4);
                    System.out.println(Thread.currentThread().getName() + &quot;\t离开了车位&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    //发放许可证，将可用许可证的数量增加一个。 如果任何线程尝试获取许可证，
                    // 那么选择一个被授予刚被释放的许可证。 （重新）线程调度用于线程调度。
                    // 这里相当于释放掉车位
                    semaphore.release();
                &#125;
            &#125;, &quot;线程&quot; + i).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="ReentrantReadWriteLock读写锁"><a href="#ReentrantReadWriteLock读写锁" class="headerlink" title="ReentrantReadWriteLock读写锁"></a>ReentrantReadWriteLock读写锁</h1><h2 id="类似案例"><a href="#类似案例" class="headerlink" title="类似案例"></a>类似案例</h2><p>红蜘蛛、缓存、数据库的更新和查询操作。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/07    22:00
 * @Version:1.0
 * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行
 * 但是
 * 如果有一个线程想去写共享资源来，就不应该再有其他线程可以对该资源进行读或者写
 * 小总结：
 *          读-读能共存
 *          读-写不能共存
 *          写-写不能共存
 * 使用读写锁，保证了数据的一致性操作  读锁是共享锁
 * 其实就是写加写锁,读就加读锁       写锁是排他锁
 *
 *
 */
class MyCache &#123;

    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    /**
     * 添加操作
     * @param key
     * @param value
     */
    public void put(String key, Object value) &#123;

        try &#123;
            // 加写锁
            readWriteLock.writeLock().lock();
            // 写入开始
            System.out.println(Thread.currentThread().getName() + &quot;\t------写入开始&quot;);
            map.put(key, value);
            TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName() + &quot;\t------写入完成&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 释放锁
            readWriteLock.writeLock().unlock();
        &#125;
    &#125;

    /**
     * 读取操作
     * @param key
     */
    public void get(String key) &#123;

        try &#123;
            // 加写锁
            readWriteLock.readLock().lock();
            // 读取开始
            System.out.println(Thread.currentThread().getName() + &quot;\t~~~~~~~~~~~~~~~~~~~~~~读取开始&quot;);
            map.get(key);
            TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName() + &quot;\t~~~~~~~~~~~~~~~~~~~~~~&quot; +
                    &quot;.读取完成&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 释放锁
            readWriteLock.readLock().unlock();
        &#125;
    &#125;

&#125;

public class ReadWriteLockDemo &#123;
    public static void main(String[] args) &#123;

        MyCache myCache = new MyCache();
        for (int i = 1; i &lt;= 5; i++) &#123;
            final int temp = i;
            new Thread(() -&gt; &#123;

                myCache.put(temp + &quot;\t&quot;, temp + &quot;\t&quot;);
            &#125;, String.valueOf(i)).start();

        &#125;
        for (int i = 1; i &lt;=5 ; i++) &#123;
            final int temp = i;
            new Thread(() -&gt; &#123;
                myCache.get(temp + &quot;\t&quot;);
            &#125;, String.valueOf(i)).start();
        &#125;

    &#125;
&#125;
</code></pre>
<p>阻塞队列，空的时候不能消费，满的时候不能增加</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172859.png" alt="image-20220109110721761"></p>
<h1 id="BlockingQueueDemo-阻塞队列"><a href="#BlockingQueueDemo-阻塞队列" class="headerlink" title="BlockingQueueDemo  阻塞队列"></a>BlockingQueueDemo  阻塞队列</h1><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈：先进后出，<strong>后进先出</strong></p>
<p>队列：先进先出</p>
<h2 id="阻塞队列的简单说明"><a href="#阻塞队列的简单说明" class="headerlink" title="阻塞队列的简单说明"></a>阻塞队列的简单说明</h2><p><strong>阻塞：必须要阻塞/不得不阻塞</strong><br>阻塞队列是一个队列，在数据结构中起的作用如下图：<img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172904.png" alt="image-20220109154737709"></p>
<p>当队列是空的，从队列中<strong>获取</strong>元素的操作将会被<strong>阻塞</strong><br>当队列是满的，从队列中<strong>添加</strong>元素的操作将会被<strong>阻塞</strong></p>
<p>试图从<strong>空的队列中获取元素的线程将会被阻塞</strong>，<strong>直到其他线程往空的队列插入新的元素</strong></p>
<p>试图<strong>向已满的队列中添加新元素的线程将会被阻塞</strong>，<strong>直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</strong>    </p>
<h2 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h2><p>在多线程领域：所谓阻塞，在某些情况下会<strong>挂起</strong>线程（即阻塞），一旦条件满足，被挂起的线程又会自动<strong>被唤起</strong></p>
<p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，**我们每个程序员都必须去自己控制这些细节，尤其还要兼顾    **效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="阻塞队列的类图"><a href="#阻塞队列的类图" class="headerlink" title="阻塞队列的类图"></a>阻塞队列的类图</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172907.png" alt="image-20220109155943058"></p>
<p>下面三个最常用</p>
<ul>
<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</li>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172913.png" alt="image-20220109084253324"></p>
<h2 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172920.png" alt="image-20220109160455125"></p>
<table>
<thead>
<tr>
<th>抛出异常</th>
<th>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</th>
</tr>
</thead>
<tbody><tr>
<td>特殊值</td>
<td>插入方法，成功ture失败false<br/>移除方法，成功返回出队列的元素，队列里没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出<br/>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h2 id="阻塞队列代码"><a href="#阻塞队列代码" class="headerlink" title="阻塞队列代码"></a>阻塞队列代码</h2><pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/09    8:56
 * @Version:1.0
 *
 * 队列：先进先出，FIFO，就相当于食堂排队
 *
 */
public class BlockingQueueDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3);

        /**
         * 抛出异常
         * add:添加方法
         * remove：移除方法
         * element：检查方法， element是返回队首的元素，如果队列没有元素就返回null
         */

        // add方法是添加元素
 /*       System.out.println(queue.add(&quot;a&quot;));
        System.out.println(queue.add(&quot;a&quot;));
        System.out.println(queue.add(&quot;c&quot;));
        // 队列满了
//        queue.add(&quot;d&quot;);  // Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full
        System.out.println(&quot;========================================================================================&quot;);
        // element是返回队首的元素
        System.out.println(queue.element());
        // remove是移除元素
        System.out.println(queue.remove());
        System.out.println(queue.remove());
        System.out.println(queue.remove());
        // 队列为空了
//        System.out.println(queue.remove()); // Exception in thread &quot;main&quot; java.util.NoSuchElementException

        System.out.println(&quot;========================================================================================&quot;);
*/
        /**
         * 特殊值
         * offer：插入成功返回true
         * poll：移除操作(移除队首的操作)，成功返回出队列的元素，队列里面没有就返回null
         * peek：检索但不删除由此queue表示的队列的头部（换句话说，该deque的第一个元素），
         * 如果此deque为空，则返回 null 。
         */
/*
        System.out.println(queue.offer(&quot;aa&quot;));
        System.out.println(queue.offer(&quot;bb&quot;));
        System.out.println(queue.offer(&quot;cc&quot;));
//        System.out.println(queue.offer(&quot;cc&quot;)); // false

        System.out.println(queue.peek());
        System.out.println(queue.peek());
        System.out.println(queue.peek());

        System.out.println(queue.poll());
        System.out.println(queue.poll());
        System.out.println(queue.poll());
//        System.out.println(queue.poll()); // null
        System.out.println(&quot;========================================================================================&quot;);
*/

  /*      queue.put(&quot;aa&quot;);
        queue.put(&quot;aa&quot;);
        queue.put(&quot;aa&quot;);
//        queue.put(&quot;aa&quot;);    //这里本来只能放三个元素，但是想要添加四个元素，所以，最后的元素就会被阻塞，就相当于一直在等待消费去消费

        queue.take();
        queue.take();
        queue.take();
//        queue.take();   // 这队列里面本来只有三个元素，这里要获取第四个，所以就得一直等着，等生产者生产第四个



*//*
        System.out.println(queue.take());
        System.out.println(queue.take());
        System.out.println(queue.take());
*//*

         */
        System.out.println(queue.offer(&quot;aa&quot;));
        System.out.println(queue.offer(&quot;aa&quot;));
        System.out.println(queue.offer(&quot;aa&quot;));
        // 这个是等三秒，三秒要是还没有蛋糕就走了，过时不候
        System.out.println(queue.offer(&quot;aa&quot;, 3L, TimeUnit.SECONDS));


    &#125;
&#125;
</code></pre>
<h2 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h2><ul>
<li><strong>方法</strong>，必须由其所在类或对象调用才有意义。若方法含有参数： <ul>
<li><strong>形参</strong>：方法声明时的参数 </li>
<li><strong>实参</strong>：方法调用时实际传给形参的参数值</li>
</ul>
</li>
</ul>
<p>Java的实参值如何传入方法呢？ Java里方法的参数传递方式只有一种：<strong>值传递。 即将实际参数值的副本 （复制品）传入方法内，而参数本身不受影响。</strong> </p>
<p>形参是<strong>基本数据类型</strong>：将实参基本数据类型变量的<strong>“数据值”</strong>传递给形参 </p>
<p>形参是<strong>引用数据类型</strong>：将实参引用数据类型变量的<strong>“地址值”</strong>传递给形参</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/09    10:10
 * @Version:1.0
 */
public class TestTransferValue &#123;

    public void changeValue1(int age) &#123;
        age = 30;
    &#125;

    public void changeValue2(Person person) &#123;
        person.setName(&quot;xxxx&quot;);
    &#125;

    public void changeValue3(String str) &#123;
        str = &quot;~~~~&quot;;
    &#125;


    public static void main(String[] args) &#123;
        TestTransferValue transferValue = new TestTransferValue();
        //  在一个方法里面，基本类型只传复印件，原件不动
        int age =20;
        transferValue.changeValue1(age);

        System.out.println(&quot;age = &quot; + age);

        // 这个自定义类型Person穿的是引用类型

        Person person = new Person(&quot;zsf&quot;);
        transferValue.changeValue2(person);
        System.out.println(&quot;personName -------------&gt;&quot; + person.getName());

        String str= &quot;abc&quot;;
        transferValue.changeValue3(str);
        System.out.println(&quot;str = &quot; + str);
    &#125;


&#125;    
</code></pre>
<p>Person类</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;

    private String name;
    private int age;

    public Person(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172926.png" alt="image-20220109174059210"></p>
<h1 id="ThreadPool线程池"><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1><hr>
<h2 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h2><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>
<p><strong>线程池的优势：</strong><br>线程池做的工作只要是控制运行的线程数量，<strong>处理过程中将任务放入队列，</strong>然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量，超出数量的线程排队等候，</strong>等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>**它的主要特点为：线程复用;控制最大并发数;管理线程。                                                                       **</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="线程池如何使用"><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h2><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了<code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code>这几个类</p>
<p> <img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172930.png" alt="image-20220109172347156"></p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/09    14:10
 * @Version:1.0
 *
 * 线程池
 *
 */
public class MyThreadPoolDemo &#123;

    public static void main(String[] args) &#123;

        // =================第一种=================
        // Executors是线程池的工具类
        // newFixedThreadPool创建    一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程。
        // 创建线程池，设置办理窗口(初始线程)为5
        // 一池5线程，类似一个银行有5个受理窗口
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);

        // =================第二种=================
        // 线程池只有一个工作线程，类似于，银行只有一个办理窗口
        //  ExecutorService threadPool = Executors.newSingleThreadExecutor();
        // 一池N线程，一个池子里面有多个线程，类似于银行有N个受理窗口，这和每个线程执行的事件有关
        // 创建一个根据需要创建新线程的线程池，但在可用时将重新使用以前构造的线程。


        // =================第三种=================
        ExecutorService threadPool = Executors.newCachedThreadPool();

        try &#123;
            for (int i = 1; i &lt;= 10; i++) &#123;
                threadPool.submit(() -&gt; &#123;

                    System.out.println(Thread.currentThread().getName() + &quot;\t办理完成&quot;);
                &#125;);
                // 暂停1秒钟，模拟办理时候的耗时
//                TimeUnit.SECONDS.sleep(1);

            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            // 关闭线程池
            threadPool.shutdown();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>其实他底层都是创建一个<strong>ThreadPoolExecutor</strong>，然后传入不同类型的参数，调用不同的构造器</p>
<pre><code class="java">/**
 * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial
 * parameters and default thread factory and rejected execution handler.
 * It may be more convenient to use one of the &#123;@link Executors&#125; factory
 * methods instead of this general purpose constructor.
 *
 * @param corePoolSize the number of threads to keep in the pool, even
 *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set
 * @param maximumPoolSize the maximum number of threads to allow in the
 *        pool
 * @param keepAliveTime when the number of threads is greater than
 *        the core, this is the maximum time that excess idle threads
 *        will wait for new tasks before terminating.
 * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument
 * @param workQueue the queue to use for holding tasks before they are
 *        executed.  This queue will hold only the &#123;@code Runnable&#125;
 *        tasks submitted by the &#123;@code execute&#125; method.
 * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
 *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;
 *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;
 *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;
 *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;
 * @throws NullPointerException if &#123;@code workQueue&#125; is null
 */
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
&#125;
</code></pre>
<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109181909648.png" alt="image-20220109181909648"></p>
<h2 id="线程池几个重要参数"><a href="#线程池几个重要参数" class="headerlink" title="线程池几个重要参数"></a>线程池几个重要参数</h2><ol>
<li><p><code>corePoolSize</code>：线程池中的常驻核心线程数</p>
</li>
<li><p><code>maximumPoolSize</code>：线程池中能够容纳同时<br>执行的最大线程数，此值必须大于等于1</p>
</li>
<li><p><code>keepAliveTime</code>：多余的空闲线程的存活时间<br>当前池中线程数量超过corePoolSize时，当空闲时间<br>达到<code>keepAliveTime</code>时，多余线程会被销毁直到<br>只剩下<code>corePoolSize</code>个线程为止</p>
</li>
<li><p><code>unit：</code> <code>keepAliveTime</code>的单位 </p>
</li>
<li><p><code>workQueue</code>：任务队列，被提交但尚未被执行的任务</p>
</li>
<li><p><code>threadFactory</code>：表示生成线程池中工作线程的线程工厂，<br>用于创建线程，一般默认的即可</p>
</li>
<li><p><code>handler</code>：拒绝策略，表示当队列满了，并且工作线程大于<br>等于线程池的最大线程数（<code>maximumPoolSize</code>）时如何来拒绝<br>请求执行的runnable的策略</p>
</li>
</ol>
<h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><p>步骤是下面的1到4</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172935.png" alt="image-20220109183737541"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172938.png" alt="image-20220109203111160"></p>
<p>下图的<code>corePoolSize</code>为2，<code>maximumPoolSize</code>为5，当一开始有两个客户（1，2线程）来办理业务的时候，两个今日窗口正好能够处理。当后面3，4，5又来时，<code>BlockingQueue</code>也正好满了（为5）；然后大堂经理就叫其他的员工来值班扩大到<code>maximumPoolSize</code>（也就是扩容到最大的线程数5）。当后面又进来三个线程（6，7，8）的时候就进入候客区（<code>BlockingQueue</code>），候客区也满了。但此时如果进来了另一个客户（9），就会告知本银行今天的业务繁忙，请到其他网点去办理业务（这里是按照拒绝策略处理）。如果设置了<code>keepAliveTime</code>的话，新增的扩容的员工，在处理完所有的业务之后，过<code>keepAliveTime</code>这么久时间，就会恢复到原来的<code>corePoolSize</code>.</p>
<pre><code class="java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue)
</code></pre>
<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109195333905.png" alt="image-20220109195333905"></p>
<p><img src="C:\Users\losser\AppData\Roaming\Typora\typora-user-images\image-20220109201025539.png" alt="image-20220109201025539"></p>
<p> <strong>以下重要：</strong></p>
<ol>
<li><p>在创建了线程池后，开始等待请求。</p>
</li>
<li><p>当调用**execute()**方法添加一个请求任务时，线程池会做出如下判断：</p>
<pre><code>  2.2如果正在运行的线程数量小于**corePoolSize**，那么马上创建线程运行这个任务；

  2.2如果正在运行的线程数量大于或等于**corePoolSize**，那么将这个任务放入队列；

  2.3如果这个时候队列满了且正在运行的线程数量还小于**maximumPoolSize**，那么还是要创建非核心线程立刻运行这个任务；

  2.4如果队列满了且正在运行的线程数量大于或等于**maximumPoolSize**，那么线程池会启动饱和拒绝策略来执行。
</code></pre>
</li>
</ol>
<p>3当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
<p>4当一个线程无事可做超过一定的时间（<strong>keepAliveTime</strong>）时，线程会判断：</p>
<p>如果当前运行的线程数大于<strong>corePoolSize</strong>，那么这个线程就被停掉。</p>
<p>所以线程池的所有任务完成后，它最终会收缩到<strong>corePoolSize</strong>的大小。</p>
<h2 id="线程池用哪个？生产中如设置合理参数"><a href="#线程池用哪个？生产中如设置合理参数" class="headerlink" title="线程池用哪个？生产中如设置合理参数"></a>线程池用哪个？生产中如设置合理参数</h2><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><strong>等待队列已经排满了</strong>，再也塞不下新任务了</p>
<p>同时，<strong>线程池中的max线程也达到了</strong>，无法继续为新任务服务。</p>
<p>这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<h4 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h4><ul>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不<br>会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中<br>尝试再次提交当前任务。</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</li>
</ul>
<h3 id="以上内置拒绝策略均实现了RejectedExecutionHandle接口"><a href="#以上内置拒绝策略均实现了RejectedExecutionHandle接口" class="headerlink" title="以上内置拒绝策略均实现了RejectedExecutionHandle接口"></a>以上内置拒绝策略均实现了RejectedExecutionHandle接口</h3><h2 id="在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多？超级大坑"><a href="#在工作中单一的-固定数的-可变的三种创建线程池的方法哪个用的多？超级大坑" class="headerlink" title="在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑"></a>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</h2><ol>
<li>答案是一个都不用，我们工作中只能使用自定义的</li>
<li>Executors中JDK已经给你提供了，为什么不用？</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172949.png" alt="image-20220109184859628"></p>
<h1 id="Java8之流式计算复习"><a href="#Java8之流式计算复习" class="headerlink" title="Java8之流式计算复习"></a>Java8之流式计算复习</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="java-util-function"><a href="#java-util-function" class="headerlink" title="java.util.function"></a>java.util.function</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172952.png" alt="image-20220111120945026"></p>
<h3 id="java内置核心四大函数式接口"><a href="#java内置核心四大函数式接口" class="headerlink" title="java内置核心四大函数式接口"></a>java内置核心四大函数式接口</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118172954.png" alt="image-20220111121004428"></p>
<p>伪代码：</p>
<pre><code class="java">//R apply(T t);函数型接口，一个参数，一个返回值
Function&lt;String,Integer&gt; function = t -&gt;&#123;return t.length();&#125;;
System.out.println(function.apply(&quot;abcd&quot;));

//boolean test(T t);断定型接口，一个参数，返回boolean
Predicate&lt;String&gt; predicate = t-&gt;&#123;return t.startsWith(&quot;a&quot;);&#125;;
System.out.println(predicate.test(&quot;a&quot;));

// void accept(T t);消费型接口，一个参数，没有返回值
Consumer&lt;String&gt; consumer = t-&gt;&#123;
    System.out.println(t);
&#125;;
consumer.accept(&quot;javaXXXX&quot;);

//T get(); 供给型接口，无参数，有返回值
Supplier&lt;String&gt; supplier =()-&gt;&#123;return UUID.randomUUID().toString();&#125;;
System.out.println(supplier.get());
 
</code></pre>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br><strong>“集合讲的是数据，流讲的是计算！”</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ol>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><ol>
<li>创建一个Stream：一个数据源（数组、集合）</li>
<li>中间操作：一个中间操作，处理数据源数据</li>
<li>终止操作：一个终止操作，执行中间操作链，产生结果</li>
</ol>
<p>过程：</p>
<p><strong>源头=&gt;中间流水线=&gt;结果</strong></p>
<p>代码示例：</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/10    13:15
 * @Version:1.0
 *
 *  (lambda表达式的几个步骤 ：
 *1 、 拷贝小括号 ( 如果只有一个参数的话, 可以省略参数类型和括号)
 *          2、写死右箭头
 *          3/落地大括号
 */
@AllArgsConstructor
@NoArgsConstructor
@Data
// 支持链式调用
@Accessors(chain = true)
class User &#123;

    // 链式编程 +   流式计算

    private Integer id;
    private String userName;
    private Integer age;
&#125;

/**
 * 题目:请按照给出数据，找出同时满足以下条件的用户,也即以下条件全部满足
 * 偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序
 * 只输出一个用户名字
 */
public class StreamDemo &#123;
    public static void main(String[] args) &#123;


        User u1 = new User(11,  &quot;a&quot;, 23);
        User u2 = new User(12, &quot;b&quot;, 24);
        User u3 = new User(13, &quot;c&quot;, 22);
        User u4 = new User(14, &quot;d&quot;, 28);
        User u5 = new User(16, &quot;e&quot;, 26);

        // 将数组转换成list集合
        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);
        List&lt;User&gt; users = new ArrayList&lt;&gt;();
        list.stream().filter(user -&gt; &#123;
            // 过滤掉为id为偶数的
            return user.getId() % 2 == 0;
        &#125;).filter(user -&gt; &#123;
            // 过滤年龄大于24的
            return user.getAge() &gt; 24;
            // map是映射
            // sorted是stream的排序，默认是升序
        &#125;).map(user -&gt; user.getUserName().toUpperCase()).sorted((o1, o2) -&gt; &#123;
            // 降序排列
            return -o1.compareTo(o2);
            // limit和MySQL中的类似，限制个数.forEach进行遍历，然后加
        &#125;).limit(1).forEach(System.out::println);


        list.stream().sorted((o1, o2) -&gt; &#123;
            return -1;
        &#125;);

/*        for (User user : list) &#123;
            if (user.getId() % 2 == 0 &amp;&amp; user.getAge() &gt; 24) &#123;
                user.setUserName(user.getUserName().toUpperCase());
                users.add(user);
            &#125;
        &#125;*/


    &#125;

&#125;
</code></pre>
<h1 id="分支合并框架"><a href="#分支合并框架" class="headerlink" title="分支合并框架"></a>分支合并框架</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并</p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173002.png" alt="image-20220111121606583"></p>
<p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173004.png" alt="image-20220111121613341"></p>
<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>和Exector相关，以及线程池有关</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173007.png" alt="image-20220111134910595"></p>
<p>分支合并池    类比=&gt;   线程池</p>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p> <img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173010.png" alt="image-20220111134928706"></p>
<p>ForkJoinTask    类比=&gt;   FutureTask</p>
<h3 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h3><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173012.png" alt="image-20220111135645753"></p>
<p>递归任务：继承后可以实现递归(自己调自己)调用的任务</p>
<p>伪代码</p>
<pre><code class="java"> 
 class Fibonacci extends RecursiveTask&lt;Integer&gt; &#123;
   final int n;
   Fibonacci(int n) &#123; this.n = n; &#125;
   Integer compute() &#123;
     if (n &lt;= 1)
       return n;
     Fibonacci f1 = new Fibonacci(n - 1);
     f1.fork();
     Fibonacci f2 = new Fibonacci(n - 2);
     return f2.compute() + f1.join();
   &#125;
 &#125;
</code></pre>
<p>ForkJoin的使用代码</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/10    22:05
 * @Version:1.0
 * ForkJoin框架
 * 用到了分治算法
 * 基础回顾：
 * 抽象类被继承
 * 接口被实现
 */
class MyTask extends RecursiveTask&lt;Integer&gt; &#123;

    private static final Integer ADJUST_VALUE = 10;

    public int begin;
    public int end;
    public int result;

    public MyTask(int begin, int end) &#123;
        this.begin = begin;
        this.end = end;
    &#125;

    @Override
    protected Integer compute() &#123;
        if (end - begin &lt;= ADJUST_VALUE) &#123;
            // 当数值差小于等于10的时候就直接进行累加
            for (int i = begin; i &lt;= end; i++) &#123;
                result += i;
            &#125;
        &#125; else &#123;
            int middle = (begin + end) / 2;
            // 这里是递归
            // 第一个任务从begin加到中间
            MyTask task01 = new MyTask(begin, middle);
            // 第二个任务从中间加到最末尾
            MyTask task02 = new MyTask(middle + 1, end);
            // 回来调用compute
            task01.fork();
            task02.fork();
            // 当 is done返回计算结果。
            result = task01.join() + task02.join();
        &#125;
        return result;
    &#125;
&#125;

public class ForkJoinDemo &#123;

    public static void main(String[] args) &#123;
        // 创建forkjoin池
        ForkJoinPool forkJoinPool = null;
        try &#123;
            MyTask myTask = new MyTask(0, 100);

            forkJoinPool = new ForkJoinPool();

            // 计算任务
            ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(myTask);
            // 获取计算的结果
            Integer integer = task.get();
            System.out.println(&quot;integer = &quot; + integer);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (forkJoinPool != null) &#123;
                forkJoinPool.shutdown();
            &#125;
        &#125;

    &#125;

&#125;
</code></pre>
<h1 id="异步回调CompletableFuture"><a href="#异步回调CompletableFuture" class="headerlink" title="异步回调CompletableFuture"></a>异步回调CompletableFuture</h1><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><img src="https://cdn.jsdelivr.net/gh/losserlong/pictures/20220118173016.png" alt="image-20220111145007736"></p>
<p>这一段，听得挺迷的，有点类似于ajax的异步请求</p>
<pre><code class="java">/**
 * Created with IntelliJ IDEA.
 * @Author: pzx
 * @Date: 2022/01/10    22:47
 * @Version:1.0
 */
public class CompletableFutureDemo &#123;

    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        // 没有返回值的
        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + &quot;\t没有返回值&quot;);
        &#125;);
        completableFuture.get();


        // 异步回调，有返回值supplyAsync供给型函数式接口
        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + &quot;\t completableFuture2&quot;);
//            return 10 / 0;
            return 1024;
        &#125;);
        //  whenComplete方法返回一个新的CompletableFuture，当CompletableFuture完成时完成，
        //  whenComplete(
        //        BiConsumer&lt;? super T, ? super Throwable&gt; action)
        Integer result = completableFuture2.whenComplete((a, b) -&gt; &#123;
            // 不出异常就走这一步
            System.out.println(&quot;a = &quot; + a);
            // 这里为null就表示没有异常
            System.out.println(&quot;b = &quot; + b);
            //结果是异常触发此CompletableFuture的完成特殊功能的给定功能;
            // 否则，如果此CompletableFuture正常完成，则返回的CompletableFuture也会以相同的值正常完成。
        &#125;).exceptionally(f -&gt; &#123;
            //  CompletableFuture&lt;T&gt; exceptionally(
            //        Function&lt;Throwable, ? extends T&gt; fn)

            // 这个是当出现异常的时候就会走这一步
            System.out.println(f.getMessage());
            return 444;
        &#125;).get();

        System.out.println(result);

    &#125;

&#125;
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/16/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/18/mysql/" rel="next" title="mysql">
      mysql <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#juc%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">juc并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#juc%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">juc简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">笔试题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.3.</span> <span class="nav-text">进程&#x2F;线程回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程&#x2F;线程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">进程&#x2F;线程例子？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是并发？什么是并行？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-start"><span class="nav-number">1.4.</span> <span class="nav-text">thread.start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.</span> <span class="nav-text">Thread的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WAITING%E5%92%8CTIMED-WAITING%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.1.</span> <span class="nav-text">WAITING和TIMED_WAITING的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.</span> <span class="nav-text">经典卖票问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC1%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">版本1使用匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E4%BA%8C%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">版本二使用lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92%E9%97%AE%E9%A2%98%EF%BC%9A%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E4%B9%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B00%E5%92%8C1"><span class="nav-number">1.7.</span> <span class="nav-text">线程交互问题：笔试题目之交替打印0和1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-0%E7%89%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">两个线程交替打印1.0版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B02-0%E7%89%88%EF%BC%88%E5%8F%98%E6%88%90%E5%9B%9B%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-number">1.7.2.</span> <span class="nav-text">两个线程交替打印2.0版（变成四个线程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E7%BC%96%E9%A2%98%E7%9B%AE"><span class="nav-number">1.7.3.</span> <span class="nav-text">改编题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lock%E6%9B%BF%E6%8D%A2synchronized"><span class="nav-number">1.8.</span> <span class="nav-text">使用lock替换synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B8%E9%94%81"><span class="nav-number">1.9.</span> <span class="nav-text">多线程8锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0100%E4%BB%A5%E5%86%85%E7%9A%84%E5%A5%87%E6%95%B0%E5%92%8C%E5%81%B6%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">交替打印100以内的奇数和偶数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.10.1.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E4%BD%BF%E7%94%A8Lock%E9%94%81"><span class="nav-number">1.10.2.</span> <span class="nav-text">第一种使用Lock锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E4%BD%BF%E7%94%A8synchronized%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.10.3.</span> <span class="nav-text">第二种使用synchronized静态代码块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83"><span class="nav-number">2.</span> <span class="nav-text">集合中的一些比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-number">2.1.</span> <span class="nav-text">请举例说明集合类是不安全的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">ArrayList线程不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E4%B8%8B%E4%B8%8D%E4%BD%BF%E7%94%A8ArrayList"><span class="nav-number">2.1.2.</span> <span class="nav-text">在多线程条件下不使用ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-concurrent"><span class="nav-number">2.1.3.</span> <span class="nav-text">java.util.concurrent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%BF%86%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">回忆集合的基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">2.1.5.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">Callable接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%E8%8E%B7%E5%BE%97%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">复习获得多线程的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">Callable的简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">3.3.</span> <span class="nav-text">FutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">例子：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.2.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB%E8%AE%B2%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">JUC强大的辅助类讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-%E5%87%8F%E5%B0%91%E8%AE%A1%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">CountDownLatch 减少计数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="nav-number">4.2.</span> <span class="nav-text">CyclicBarrier  循环栅栏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E7%81%AF"><span class="nav-number">4.3.</span> <span class="nav-text">Semaphore 信号灯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-number">4.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">ReentrantReadWriteLock读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%BC%BC%E6%A1%88%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">类似案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">5.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BlockingQueueDemo-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text">BlockingQueueDemo  阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">栈与队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E"><span class="nav-number">6.2.</span> <span class="nav-text">阻塞队列的简单说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%A8%E5%A4%84"><span class="nav-number">6.3.</span> <span class="nav-text">阻塞队列的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9B%BE"><span class="nav-number">6.4.</span> <span class="nav-text">阻塞队列的类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-number">6.5.</span> <span class="nav-text">BlockingQueue核心方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81"><span class="nav-number">6.6.</span> <span class="nav-text">阻塞队列代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">6.7.</span> <span class="nav-text">方法参数的值传递机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadPool%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.</span> <span class="nav-text">ThreadPool线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.1.</span> <span class="nav-text">为什么用线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">线程池如何使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="nav-number">7.2.1.</span> <span class="nav-text">架构说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.2.</span> <span class="nav-text">编码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.3.</span> <span class="nav-text">底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">线程池几个重要参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.</span> <span class="nav-text">线程池底层工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F%E7%94%9F%E4%BA%A7%E4%B8%AD%E5%A6%82%E8%AE%BE%E7%BD%AE%E5%90%88%E7%90%86%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">线程池用哪个？生产中如设置合理参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">7.5.1.</span> <span class="nav-text">线程池的拒绝策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">7.5.1.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E5%86%85%E7%BD%AE%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">7.5.1.2.</span> <span class="nav-text">JDK内置的拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8A%E5%86%85%E7%BD%AE%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E5%9D%87%E5%AE%9E%E7%8E%B0%E4%BA%86RejectedExecutionHandle%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.5.2.</span> <span class="nav-text">以上内置拒绝策略均实现了RejectedExecutionHandle接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%8D%95%E4%B8%80%E7%9A%84-%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%9A%84-%E5%8F%AF%E5%8F%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%93%AA%E4%B8%AA%E7%94%A8%E7%9A%84%E5%A4%9A%EF%BC%9F%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91"><span class="nav-number">7.6.</span> <span class="nav-text">在工作中单一的&#x2F;固定数的&#x2F;可变的三种创建线程池的方法哪个用的多？超级大坑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java8%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0"><span class="nav-number">8.</span> <span class="nav-text">Java8之流式计算复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.1.</span> <span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-function"><span class="nav-number">8.1.1.</span> <span class="nav-text">java.util.function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.1.2.</span> <span class="nav-text">java内置核心四大函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E6%B5%81"><span class="nav-number">8.2.</span> <span class="nav-text">Stream流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.2.1.</span> <span class="nav-text">流是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">8.2.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5"><span class="nav-number">8.2.3.</span> <span class="nav-text">阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">9.</span> <span class="nav-text">分支合并框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-number">9.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">9.2.</span> <span class="nav-text">相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">9.2.1.</span> <span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinTask"><span class="nav-number">9.2.2.</span> <span class="nav-text">ForkJoinTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RecursiveTask"><span class="nav-number">9.2.3.</span> <span class="nav-text">RecursiveTask</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83CompletableFuture"><span class="nav-number">10.</span> <span class="nav-text">异步回调CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">10.1.</span> <span class="nav-text">CompletableFuture</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xiang</p>
  <div class="site-description" itemprop="description">Stay Hungry,Stay Foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
